Grammar:

Rule 0     S' -> start
Rule 1     empty -> <empty>
Rule 2     start -> empty
Rule 3     start -> statement start
Rule 4     statement -> FOR ID = range loopblock
Rule 5     statement -> WHILE expr loopblock  [precedence=left, level=2]
Rule 6     statement -> IF expr ifblock ELSE ifblock  [precedence=right, level=5]
Rule 7     statement -> IF expr ifblock  [precedence=left, level=2]
Rule 8     statement -> PRINT expr ;
Rule 9     statement -> expr ;
Rule 10    statement -> RETURN
Rule 11    statement -> ID DASSIGN expr ;
Rule 12    statement -> ID TASSIGN expr ;
Rule 13    statement -> ID MASSIGN expr ;
Rule 14    statement -> ID PASSIGN expr ;
Rule 15    statement -> ID = expr ;
Rule 16    ifblock -> { start }
Rule 17    ifblock -> statement
Rule 18    loopblock -> { loopstart }
Rule 19    loopblock -> statement
Rule 20    loopstart -> empty
Rule 21    loopstart -> BREAK ;
Rule 22    loopstart -> CONTINUE ;
Rule 23    loopstart -> statement loopstart
Rule 24    expr -> EYE ( expr )
Rule 25    expr -> ONES ( expr )
Rule 26    expr -> ZEROS ( expr )
Rule 27    expr -> ID
Rule 28    expr -> [ outerlist ]
Rule 29    expr -> STRING
Rule 30    expr -> FLOAT
Rule 31    expr -> INT
Rule 32    expr -> expr '  [precedence=right, level=5]
Rule 33    expr -> ( expr )
Rule 34    expr -> expr NEQ expr  [precedence=nonassoc, level=1]
Rule 35    expr -> expr EQ expr  [precedence=nonassoc, level=1]
Rule 36    expr -> expr GEQ expr  [precedence=nonassoc, level=1]
Rule 37    expr -> expr > expr  [precedence=nonassoc, level=1]
Rule 38    expr -> expr LEQ expr  [precedence=nonassoc, level=1]
Rule 39    expr -> expr < expr  [precedence=nonassoc, level=1]
Rule 40    expr -> ' expr  [precedence=right, level=5]
Rule 41    expr -> expr MDIVIDE expr  [precedence=left, level=4]
Rule 42    expr -> expr MTIMES expr  [precedence=left, level=4]
Rule 43    expr -> expr MMINUS expr  [precedence=left, level=3]
Rule 44    expr -> expr MPLUS expr  [precedence=left, level=3]
Rule 45    expr -> expr / expr  [precedence=left, level=4]
Rule 46    expr -> expr * expr  [precedence=left, level=4]
Rule 47    expr -> expr - expr  [precedence=left, level=3]
Rule 48    expr -> expr + expr  [precedence=left, level=3]
Rule 49    range -> INT : ID
Rule 50    range -> ID : INT
Rule 51    range -> ID : ID
Rule 52    range -> INT : INT
Rule 53    outerlist -> [ innerlist ]
Rule 54    outerlist -> outerlist , [ innerlist ]
Rule 55    innerlist -> elem
Rule 56    innerlist -> innerlist , elem
Rule 57    elem -> STRING
Rule 58    elem -> FLOAT
Rule 59    elem -> INT

Terminals, with rules where they appear:

'                    : 32 40
(                    : 24 25 26 33
)                    : 24 25 26 33
*                    : 46
+                    : 48
,                    : 54 56
-                    : 47
/                    : 45
:                    : 49 50 51 52
;                    : 8 9 11 12 13 14 15 21 22
<                    : 39
=                    : 4 15
>                    : 37
BREAK                : 21
CONTINUE             : 22
DASSIGN              : 11
ELSE                 : 6
EQ                   : 35
EYE                  : 24
FLOAT                : 30 58
FOR                  : 4
GEQ                  : 36
ID                   : 4 11 12 13 14 15 27 49 50 51 51
IF                   : 6 7
INT                  : 31 49 50 52 52 59
LEQ                  : 38
MASSIGN              : 13
MDIVIDE              : 41
MMINUS               : 43
MPLUS                : 44
MTIMES               : 42
NEQ                  : 34
ONES                 : 25
PASSIGN              : 14
PRINT                : 8
RETURN               : 10
STRING               : 29 57
TASSIGN              : 12
WHILE                : 5
ZEROS                : 26
[                    : 28 53 54
]                    : 28 53 54
error                : 
{                    : 16 18
}                    : 16 18

Nonterminals, with rules where they appear:

elem                 : 55 56
empty                : 2 20
expr                 : 5 6 7 8 9 11 12 13 14 15 24 25 26 32 33 34 34 35 35 36 36 37 37 38 38 39 39 40 41 41 42 42 43 43 44 44 45 45 46 46 47 47 48 48
ifblock              : 6 6 7
innerlist            : 53 54 56
loopblock            : 4 5
loopstart            : 18 23
outerlist            : 28 54
range                : 4
start                : 3 16 0
statement            : 3 17 19 23


state 0

    (0) S' -> . start
    (2) start -> . empty
    (3) start -> . statement start
    (1) empty -> .
    (4) statement -> . FOR ID = range loopblock
    (5) statement -> . WHILE expr loopblock
    (6) statement -> . IF expr ifblock ELSE ifblock
    (7) statement -> . IF expr ifblock
    (8) statement -> . PRINT expr ;
    (9) statement -> . expr ;
    (10) statement -> . RETURN
    (11) statement -> . ID DASSIGN expr ;
    (12) statement -> . ID TASSIGN expr ;
    (13) statement -> . ID MASSIGN expr ;
    (14) statement -> . ID PASSIGN expr ;
    (15) statement -> . ID = expr ;
    (24) expr -> . EYE ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ID
    (28) expr -> . [ outerlist ]
    (29) expr -> . STRING
    (30) expr -> . FLOAT
    (31) expr -> . INT
    (32) expr -> . expr '
    (33) expr -> . ( expr )
    (34) expr -> . expr NEQ expr
    (35) expr -> . expr EQ expr
    (36) expr -> . expr GEQ expr
    (37) expr -> . expr > expr
    (38) expr -> . expr LEQ expr
    (39) expr -> . expr < expr
    (40) expr -> . ' expr
    (41) expr -> . expr MDIVIDE expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MMINUS expr
    (44) expr -> . expr MPLUS expr
    (45) expr -> . expr / expr
    (46) expr -> . expr * expr
    (47) expr -> . expr - expr
    (48) expr -> . expr + expr
    $end            reduce using rule 1 (empty -> .)
    FOR             shift and go to state 4
    WHILE           shift and go to state 6
    IF              shift and go to state 8
    PRINT           shift and go to state 9
    RETURN          shift and go to state 10
    ID              shift and go to state 5
    EYE             shift and go to state 11
    ONES            shift and go to state 13
    ZEROS           shift and go to state 14
    [               shift and go to state 15
    STRING          shift and go to state 16
    FLOAT           shift and go to state 17
    INT             shift and go to state 18
    (               shift and go to state 12
    '               shift and go to state 19

    start                          shift and go to state 1
    empty                          shift and go to state 2
    statement                      shift and go to state 3
    expr                           shift and go to state 7

state 1

    (0) S' -> start .


state 2

    (2) start -> empty .
    $end            reduce using rule 2 (start -> empty .)
    }               reduce using rule 2 (start -> empty .)


state 3

    (3) start -> statement . start
    (2) start -> . empty
    (3) start -> . statement start
    (1) empty -> .
    (4) statement -> . FOR ID = range loopblock
    (5) statement -> . WHILE expr loopblock
    (6) statement -> . IF expr ifblock ELSE ifblock
    (7) statement -> . IF expr ifblock
    (8) statement -> . PRINT expr ;
    (9) statement -> . expr ;
    (10) statement -> . RETURN
    (11) statement -> . ID DASSIGN expr ;
    (12) statement -> . ID TASSIGN expr ;
    (13) statement -> . ID MASSIGN expr ;
    (14) statement -> . ID PASSIGN expr ;
    (15) statement -> . ID = expr ;
    (24) expr -> . EYE ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ID
    (28) expr -> . [ outerlist ]
    (29) expr -> . STRING
    (30) expr -> . FLOAT
    (31) expr -> . INT
    (32) expr -> . expr '
    (33) expr -> . ( expr )
    (34) expr -> . expr NEQ expr
    (35) expr -> . expr EQ expr
    (36) expr -> . expr GEQ expr
    (37) expr -> . expr > expr
    (38) expr -> . expr LEQ expr
    (39) expr -> . expr < expr
    (40) expr -> . ' expr
    (41) expr -> . expr MDIVIDE expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MMINUS expr
    (44) expr -> . expr MPLUS expr
    (45) expr -> . expr / expr
    (46) expr -> . expr * expr
    (47) expr -> . expr - expr
    (48) expr -> . expr + expr
    $end            reduce using rule 1 (empty -> .)
    }               reduce using rule 1 (empty -> .)
    FOR             shift and go to state 4
    WHILE           shift and go to state 6
    IF              shift and go to state 8
    PRINT           shift and go to state 9
    RETURN          shift and go to state 10
    ID              shift and go to state 5
    EYE             shift and go to state 11
    ONES            shift and go to state 13
    ZEROS           shift and go to state 14
    [               shift and go to state 15
    STRING          shift and go to state 16
    FLOAT           shift and go to state 17
    INT             shift and go to state 18
    (               shift and go to state 12
    '               shift and go to state 19

    statement                      shift and go to state 3
    start                          shift and go to state 20
    empty                          shift and go to state 2
    expr                           shift and go to state 7

state 4

    (4) statement -> FOR . ID = range loopblock
    ID              shift and go to state 21


state 5

    (11) statement -> ID . DASSIGN expr ;
    (12) statement -> ID . TASSIGN expr ;
    (13) statement -> ID . MASSIGN expr ;
    (14) statement -> ID . PASSIGN expr ;
    (15) statement -> ID . = expr ;
    (27) expr -> ID .
    DASSIGN         shift and go to state 22
    TASSIGN         shift and go to state 23
    MASSIGN         shift and go to state 24
    PASSIGN         shift and go to state 25
    =               shift and go to state 26
    ;               reduce using rule 27 (expr -> ID .)
    '               reduce using rule 27 (expr -> ID .)
    NEQ             reduce using rule 27 (expr -> ID .)
    EQ              reduce using rule 27 (expr -> ID .)
    GEQ             reduce using rule 27 (expr -> ID .)
    >               reduce using rule 27 (expr -> ID .)
    LEQ             reduce using rule 27 (expr -> ID .)
    <               reduce using rule 27 (expr -> ID .)
    MDIVIDE         reduce using rule 27 (expr -> ID .)
    MTIMES          reduce using rule 27 (expr -> ID .)
    MMINUS          reduce using rule 27 (expr -> ID .)
    MPLUS           reduce using rule 27 (expr -> ID .)
    /               reduce using rule 27 (expr -> ID .)
    *               reduce using rule 27 (expr -> ID .)
    -               reduce using rule 27 (expr -> ID .)
    +               reduce using rule 27 (expr -> ID .)


state 6

    (5) statement -> WHILE . expr loopblock
    (24) expr -> . EYE ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ID
    (28) expr -> . [ outerlist ]
    (29) expr -> . STRING
    (30) expr -> . FLOAT
    (31) expr -> . INT
    (32) expr -> . expr '
    (33) expr -> . ( expr )
    (34) expr -> . expr NEQ expr
    (35) expr -> . expr EQ expr
    (36) expr -> . expr GEQ expr
    (37) expr -> . expr > expr
    (38) expr -> . expr LEQ expr
    (39) expr -> . expr < expr
    (40) expr -> . ' expr
    (41) expr -> . expr MDIVIDE expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MMINUS expr
    (44) expr -> . expr MPLUS expr
    (45) expr -> . expr / expr
    (46) expr -> . expr * expr
    (47) expr -> . expr - expr
    (48) expr -> . expr + expr
    EYE             shift and go to state 11
    ONES            shift and go to state 13
    ZEROS           shift and go to state 14
    ID              shift and go to state 28
    [               shift and go to state 15
    STRING          shift and go to state 16
    FLOAT           shift and go to state 17
    INT             shift and go to state 18
    (               shift and go to state 12
    '               shift and go to state 19

    expr                           shift and go to state 27

state 7

    (9) statement -> expr . ;
    (32) expr -> expr . '
    (34) expr -> expr . NEQ expr
    (35) expr -> expr . EQ expr
    (36) expr -> expr . GEQ expr
    (37) expr -> expr . > expr
    (38) expr -> expr . LEQ expr
    (39) expr -> expr . < expr
    (41) expr -> expr . MDIVIDE expr
    (42) expr -> expr . MTIMES expr
    (43) expr -> expr . MMINUS expr
    (44) expr -> expr . MPLUS expr
    (45) expr -> expr . / expr
    (46) expr -> expr . * expr
    (47) expr -> expr . - expr
    (48) expr -> expr . + expr
    ;               shift and go to state 29
    '               shift and go to state 30
    NEQ             shift and go to state 31
    EQ              shift and go to state 32
    GEQ             shift and go to state 33
    >               shift and go to state 34
    LEQ             shift and go to state 35
    <               shift and go to state 36
    MDIVIDE         shift and go to state 37
    MTIMES          shift and go to state 38
    MMINUS          shift and go to state 39
    MPLUS           shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44


state 8

    (6) statement -> IF . expr ifblock ELSE ifblock
    (7) statement -> IF . expr ifblock
    (24) expr -> . EYE ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ID
    (28) expr -> . [ outerlist ]
    (29) expr -> . STRING
    (30) expr -> . FLOAT
    (31) expr -> . INT
    (32) expr -> . expr '
    (33) expr -> . ( expr )
    (34) expr -> . expr NEQ expr
    (35) expr -> . expr EQ expr
    (36) expr -> . expr GEQ expr
    (37) expr -> . expr > expr
    (38) expr -> . expr LEQ expr
    (39) expr -> . expr < expr
    (40) expr -> . ' expr
    (41) expr -> . expr MDIVIDE expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MMINUS expr
    (44) expr -> . expr MPLUS expr
    (45) expr -> . expr / expr
    (46) expr -> . expr * expr
    (47) expr -> . expr - expr
    (48) expr -> . expr + expr
    EYE             shift and go to state 11
    ONES            shift and go to state 13
    ZEROS           shift and go to state 14
    ID              shift and go to state 28
    [               shift and go to state 15
    STRING          shift and go to state 16
    FLOAT           shift and go to state 17
    INT             shift and go to state 18
    (               shift and go to state 12
    '               shift and go to state 19

    expr                           shift and go to state 45

state 9

    (8) statement -> PRINT . expr ;
    (24) expr -> . EYE ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ID
    (28) expr -> . [ outerlist ]
    (29) expr -> . STRING
    (30) expr -> . FLOAT
    (31) expr -> . INT
    (32) expr -> . expr '
    (33) expr -> . ( expr )
    (34) expr -> . expr NEQ expr
    (35) expr -> . expr EQ expr
    (36) expr -> . expr GEQ expr
    (37) expr -> . expr > expr
    (38) expr -> . expr LEQ expr
    (39) expr -> . expr < expr
    (40) expr -> . ' expr
    (41) expr -> . expr MDIVIDE expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MMINUS expr
    (44) expr -> . expr MPLUS expr
    (45) expr -> . expr / expr
    (46) expr -> . expr * expr
    (47) expr -> . expr - expr
    (48) expr -> . expr + expr
    EYE             shift and go to state 11
    ONES            shift and go to state 13
    ZEROS           shift and go to state 14
    ID              shift and go to state 28
    [               shift and go to state 15
    STRING          shift and go to state 16
    FLOAT           shift and go to state 17
    INT             shift and go to state 18
    (               shift and go to state 12
    '               shift and go to state 19

    expr                           shift and go to state 46

state 10

    (10) statement -> RETURN .
    FOR             reduce using rule 10 (statement -> RETURN .)
    WHILE           reduce using rule 10 (statement -> RETURN .)
    IF              reduce using rule 10 (statement -> RETURN .)
    PRINT           reduce using rule 10 (statement -> RETURN .)
    RETURN          reduce using rule 10 (statement -> RETURN .)
    ID              reduce using rule 10 (statement -> RETURN .)
    EYE             reduce using rule 10 (statement -> RETURN .)
    ONES            reduce using rule 10 (statement -> RETURN .)
    ZEROS           reduce using rule 10 (statement -> RETURN .)
    [               reduce using rule 10 (statement -> RETURN .)
    STRING          reduce using rule 10 (statement -> RETURN .)
    FLOAT           reduce using rule 10 (statement -> RETURN .)
    INT             reduce using rule 10 (statement -> RETURN .)
    (               reduce using rule 10 (statement -> RETURN .)
    '               reduce using rule 10 (statement -> RETURN .)
    $end            reduce using rule 10 (statement -> RETURN .)
    }               reduce using rule 10 (statement -> RETURN .)
    ELSE            reduce using rule 10 (statement -> RETURN .)
    BREAK           reduce using rule 10 (statement -> RETURN .)
    CONTINUE        reduce using rule 10 (statement -> RETURN .)


state 11

    (24) expr -> EYE . ( expr )
    (               shift and go to state 47


state 12

    (33) expr -> ( . expr )
    (24) expr -> . EYE ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ID
    (28) expr -> . [ outerlist ]
    (29) expr -> . STRING
    (30) expr -> . FLOAT
    (31) expr -> . INT
    (32) expr -> . expr '
    (33) expr -> . ( expr )
    (34) expr -> . expr NEQ expr
    (35) expr -> . expr EQ expr
    (36) expr -> . expr GEQ expr
    (37) expr -> . expr > expr
    (38) expr -> . expr LEQ expr
    (39) expr -> . expr < expr
    (40) expr -> . ' expr
    (41) expr -> . expr MDIVIDE expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MMINUS expr
    (44) expr -> . expr MPLUS expr
    (45) expr -> . expr / expr
    (46) expr -> . expr * expr
    (47) expr -> . expr - expr
    (48) expr -> . expr + expr
    EYE             shift and go to state 11
    ONES            shift and go to state 13
    ZEROS           shift and go to state 14
    ID              shift and go to state 28
    [               shift and go to state 15
    STRING          shift and go to state 16
    FLOAT           shift and go to state 17
    INT             shift and go to state 18
    (               shift and go to state 12
    '               shift and go to state 19

    expr                           shift and go to state 48

state 13

    (25) expr -> ONES . ( expr )
    (               shift and go to state 49


state 14

    (26) expr -> ZEROS . ( expr )
    (               shift and go to state 50


state 15

    (28) expr -> [ . outerlist ]
    (53) outerlist -> . [ innerlist ]
    (54) outerlist -> . outerlist , [ innerlist ]
    [               shift and go to state 51

    outerlist                      shift and go to state 52

state 16

    (29) expr -> STRING .
    ;               reduce using rule 29 (expr -> STRING .)
    '               reduce using rule 29 (expr -> STRING .)
    NEQ             reduce using rule 29 (expr -> STRING .)
    EQ              reduce using rule 29 (expr -> STRING .)
    GEQ             reduce using rule 29 (expr -> STRING .)
    >               reduce using rule 29 (expr -> STRING .)
    LEQ             reduce using rule 29 (expr -> STRING .)
    <               reduce using rule 29 (expr -> STRING .)
    MDIVIDE         reduce using rule 29 (expr -> STRING .)
    MTIMES          reduce using rule 29 (expr -> STRING .)
    MMINUS          reduce using rule 29 (expr -> STRING .)
    MPLUS           reduce using rule 29 (expr -> STRING .)
    /               reduce using rule 29 (expr -> STRING .)
    *               reduce using rule 29 (expr -> STRING .)
    -               reduce using rule 29 (expr -> STRING .)
    +               reduce using rule 29 (expr -> STRING .)
    {               reduce using rule 29 (expr -> STRING .)
    FOR             reduce using rule 29 (expr -> STRING .)
    WHILE           reduce using rule 29 (expr -> STRING .)
    IF              reduce using rule 29 (expr -> STRING .)
    PRINT           reduce using rule 29 (expr -> STRING .)
    RETURN          reduce using rule 29 (expr -> STRING .)
    ID              reduce using rule 29 (expr -> STRING .)
    EYE             reduce using rule 29 (expr -> STRING .)
    ONES            reduce using rule 29 (expr -> STRING .)
    ZEROS           reduce using rule 29 (expr -> STRING .)
    [               reduce using rule 29 (expr -> STRING .)
    STRING          reduce using rule 29 (expr -> STRING .)
    FLOAT           reduce using rule 29 (expr -> STRING .)
    INT             reduce using rule 29 (expr -> STRING .)
    (               reduce using rule 29 (expr -> STRING .)
    )               reduce using rule 29 (expr -> STRING .)


state 17

    (30) expr -> FLOAT .
    ;               reduce using rule 30 (expr -> FLOAT .)
    '               reduce using rule 30 (expr -> FLOAT .)
    NEQ             reduce using rule 30 (expr -> FLOAT .)
    EQ              reduce using rule 30 (expr -> FLOAT .)
    GEQ             reduce using rule 30 (expr -> FLOAT .)
    >               reduce using rule 30 (expr -> FLOAT .)
    LEQ             reduce using rule 30 (expr -> FLOAT .)
    <               reduce using rule 30 (expr -> FLOAT .)
    MDIVIDE         reduce using rule 30 (expr -> FLOAT .)
    MTIMES          reduce using rule 30 (expr -> FLOAT .)
    MMINUS          reduce using rule 30 (expr -> FLOAT .)
    MPLUS           reduce using rule 30 (expr -> FLOAT .)
    /               reduce using rule 30 (expr -> FLOAT .)
    *               reduce using rule 30 (expr -> FLOAT .)
    -               reduce using rule 30 (expr -> FLOAT .)
    +               reduce using rule 30 (expr -> FLOAT .)
    {               reduce using rule 30 (expr -> FLOAT .)
    FOR             reduce using rule 30 (expr -> FLOAT .)
    WHILE           reduce using rule 30 (expr -> FLOAT .)
    IF              reduce using rule 30 (expr -> FLOAT .)
    PRINT           reduce using rule 30 (expr -> FLOAT .)
    RETURN          reduce using rule 30 (expr -> FLOAT .)
    ID              reduce using rule 30 (expr -> FLOAT .)
    EYE             reduce using rule 30 (expr -> FLOAT .)
    ONES            reduce using rule 30 (expr -> FLOAT .)
    ZEROS           reduce using rule 30 (expr -> FLOAT .)
    [               reduce using rule 30 (expr -> FLOAT .)
    STRING          reduce using rule 30 (expr -> FLOAT .)
    FLOAT           reduce using rule 30 (expr -> FLOAT .)
    INT             reduce using rule 30 (expr -> FLOAT .)
    (               reduce using rule 30 (expr -> FLOAT .)
    )               reduce using rule 30 (expr -> FLOAT .)


state 18

    (31) expr -> INT .
    ;               reduce using rule 31 (expr -> INT .)
    '               reduce using rule 31 (expr -> INT .)
    NEQ             reduce using rule 31 (expr -> INT .)
    EQ              reduce using rule 31 (expr -> INT .)
    GEQ             reduce using rule 31 (expr -> INT .)
    >               reduce using rule 31 (expr -> INT .)
    LEQ             reduce using rule 31 (expr -> INT .)
    <               reduce using rule 31 (expr -> INT .)
    MDIVIDE         reduce using rule 31 (expr -> INT .)
    MTIMES          reduce using rule 31 (expr -> INT .)
    MMINUS          reduce using rule 31 (expr -> INT .)
    MPLUS           reduce using rule 31 (expr -> INT .)
    /               reduce using rule 31 (expr -> INT .)
    *               reduce using rule 31 (expr -> INT .)
    -               reduce using rule 31 (expr -> INT .)
    +               reduce using rule 31 (expr -> INT .)
    {               reduce using rule 31 (expr -> INT .)
    FOR             reduce using rule 31 (expr -> INT .)
    WHILE           reduce using rule 31 (expr -> INT .)
    IF              reduce using rule 31 (expr -> INT .)
    PRINT           reduce using rule 31 (expr -> INT .)
    RETURN          reduce using rule 31 (expr -> INT .)
    ID              reduce using rule 31 (expr -> INT .)
    EYE             reduce using rule 31 (expr -> INT .)
    ONES            reduce using rule 31 (expr -> INT .)
    ZEROS           reduce using rule 31 (expr -> INT .)
    [               reduce using rule 31 (expr -> INT .)
    STRING          reduce using rule 31 (expr -> INT .)
    FLOAT           reduce using rule 31 (expr -> INT .)
    INT             reduce using rule 31 (expr -> INT .)
    (               reduce using rule 31 (expr -> INT .)
    )               reduce using rule 31 (expr -> INT .)


state 19

    (40) expr -> ' . expr
    (24) expr -> . EYE ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ID
    (28) expr -> . [ outerlist ]
    (29) expr -> . STRING
    (30) expr -> . FLOAT
    (31) expr -> . INT
    (32) expr -> . expr '
    (33) expr -> . ( expr )
    (34) expr -> . expr NEQ expr
    (35) expr -> . expr EQ expr
    (36) expr -> . expr GEQ expr
    (37) expr -> . expr > expr
    (38) expr -> . expr LEQ expr
    (39) expr -> . expr < expr
    (40) expr -> . ' expr
    (41) expr -> . expr MDIVIDE expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MMINUS expr
    (44) expr -> . expr MPLUS expr
    (45) expr -> . expr / expr
    (46) expr -> . expr * expr
    (47) expr -> . expr - expr
    (48) expr -> . expr + expr
    EYE             shift and go to state 11
    ONES            shift and go to state 13
    ZEROS           shift and go to state 14
    ID              shift and go to state 28
    [               shift and go to state 15
    STRING          shift and go to state 16
    FLOAT           shift and go to state 17
    INT             shift and go to state 18
    (               shift and go to state 12
    '               shift and go to state 19

    expr                           shift and go to state 53

state 20

    (3) start -> statement start .
    $end            reduce using rule 3 (start -> statement start .)
    }               reduce using rule 3 (start -> statement start .)


state 21

    (4) statement -> FOR ID . = range loopblock
    =               shift and go to state 54


state 22

    (11) statement -> ID DASSIGN . expr ;
    (24) expr -> . EYE ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ID
    (28) expr -> . [ outerlist ]
    (29) expr -> . STRING
    (30) expr -> . FLOAT
    (31) expr -> . INT
    (32) expr -> . expr '
    (33) expr -> . ( expr )
    (34) expr -> . expr NEQ expr
    (35) expr -> . expr EQ expr
    (36) expr -> . expr GEQ expr
    (37) expr -> . expr > expr
    (38) expr -> . expr LEQ expr
    (39) expr -> . expr < expr
    (40) expr -> . ' expr
    (41) expr -> . expr MDIVIDE expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MMINUS expr
    (44) expr -> . expr MPLUS expr
    (45) expr -> . expr / expr
    (46) expr -> . expr * expr
    (47) expr -> . expr - expr
    (48) expr -> . expr + expr
    EYE             shift and go to state 11
    ONES            shift and go to state 13
    ZEROS           shift and go to state 14
    ID              shift and go to state 28
    [               shift and go to state 15
    STRING          shift and go to state 16
    FLOAT           shift and go to state 17
    INT             shift and go to state 18
    (               shift and go to state 12
    '               shift and go to state 19

    expr                           shift and go to state 55

state 23

    (12) statement -> ID TASSIGN . expr ;
    (24) expr -> . EYE ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ID
    (28) expr -> . [ outerlist ]
    (29) expr -> . STRING
    (30) expr -> . FLOAT
    (31) expr -> . INT
    (32) expr -> . expr '
    (33) expr -> . ( expr )
    (34) expr -> . expr NEQ expr
    (35) expr -> . expr EQ expr
    (36) expr -> . expr GEQ expr
    (37) expr -> . expr > expr
    (38) expr -> . expr LEQ expr
    (39) expr -> . expr < expr
    (40) expr -> . ' expr
    (41) expr -> . expr MDIVIDE expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MMINUS expr
    (44) expr -> . expr MPLUS expr
    (45) expr -> . expr / expr
    (46) expr -> . expr * expr
    (47) expr -> . expr - expr
    (48) expr -> . expr + expr
    EYE             shift and go to state 11
    ONES            shift and go to state 13
    ZEROS           shift and go to state 14
    ID              shift and go to state 28
    [               shift and go to state 15
    STRING          shift and go to state 16
    FLOAT           shift and go to state 17
    INT             shift and go to state 18
    (               shift and go to state 12
    '               shift and go to state 19

    expr                           shift and go to state 56

state 24

    (13) statement -> ID MASSIGN . expr ;
    (24) expr -> . EYE ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ID
    (28) expr -> . [ outerlist ]
    (29) expr -> . STRING
    (30) expr -> . FLOAT
    (31) expr -> . INT
    (32) expr -> . expr '
    (33) expr -> . ( expr )
    (34) expr -> . expr NEQ expr
    (35) expr -> . expr EQ expr
    (36) expr -> . expr GEQ expr
    (37) expr -> . expr > expr
    (38) expr -> . expr LEQ expr
    (39) expr -> . expr < expr
    (40) expr -> . ' expr
    (41) expr -> . expr MDIVIDE expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MMINUS expr
    (44) expr -> . expr MPLUS expr
    (45) expr -> . expr / expr
    (46) expr -> . expr * expr
    (47) expr -> . expr - expr
    (48) expr -> . expr + expr
    EYE             shift and go to state 11
    ONES            shift and go to state 13
    ZEROS           shift and go to state 14
    ID              shift and go to state 28
    [               shift and go to state 15
    STRING          shift and go to state 16
    FLOAT           shift and go to state 17
    INT             shift and go to state 18
    (               shift and go to state 12
    '               shift and go to state 19

    expr                           shift and go to state 57

state 25

    (14) statement -> ID PASSIGN . expr ;
    (24) expr -> . EYE ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ID
    (28) expr -> . [ outerlist ]
    (29) expr -> . STRING
    (30) expr -> . FLOAT
    (31) expr -> . INT
    (32) expr -> . expr '
    (33) expr -> . ( expr )
    (34) expr -> . expr NEQ expr
    (35) expr -> . expr EQ expr
    (36) expr -> . expr GEQ expr
    (37) expr -> . expr > expr
    (38) expr -> . expr LEQ expr
    (39) expr -> . expr < expr
    (40) expr -> . ' expr
    (41) expr -> . expr MDIVIDE expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MMINUS expr
    (44) expr -> . expr MPLUS expr
    (45) expr -> . expr / expr
    (46) expr -> . expr * expr
    (47) expr -> . expr - expr
    (48) expr -> . expr + expr
    EYE             shift and go to state 11
    ONES            shift and go to state 13
    ZEROS           shift and go to state 14
    ID              shift and go to state 28
    [               shift and go to state 15
    STRING          shift and go to state 16
    FLOAT           shift and go to state 17
    INT             shift and go to state 18
    (               shift and go to state 12
    '               shift and go to state 19

    expr                           shift and go to state 58

state 26

    (15) statement -> ID = . expr ;
    (24) expr -> . EYE ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ID
    (28) expr -> . [ outerlist ]
    (29) expr -> . STRING
    (30) expr -> . FLOAT
    (31) expr -> . INT
    (32) expr -> . expr '
    (33) expr -> . ( expr )
    (34) expr -> . expr NEQ expr
    (35) expr -> . expr EQ expr
    (36) expr -> . expr GEQ expr
    (37) expr -> . expr > expr
    (38) expr -> . expr LEQ expr
    (39) expr -> . expr < expr
    (40) expr -> . ' expr
    (41) expr -> . expr MDIVIDE expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MMINUS expr
    (44) expr -> . expr MPLUS expr
    (45) expr -> . expr / expr
    (46) expr -> . expr * expr
    (47) expr -> . expr - expr
    (48) expr -> . expr + expr
    EYE             shift and go to state 11
    ONES            shift and go to state 13
    ZEROS           shift and go to state 14
    ID              shift and go to state 28
    [               shift and go to state 15
    STRING          shift and go to state 16
    FLOAT           shift and go to state 17
    INT             shift and go to state 18
    (               shift and go to state 12
    '               shift and go to state 19

    expr                           shift and go to state 59

state 27

    (5) statement -> WHILE expr . loopblock
    (32) expr -> expr . '
    (34) expr -> expr . NEQ expr
    (35) expr -> expr . EQ expr
    (36) expr -> expr . GEQ expr
    (37) expr -> expr . > expr
    (38) expr -> expr . LEQ expr
    (39) expr -> expr . < expr
    (41) expr -> expr . MDIVIDE expr
    (42) expr -> expr . MTIMES expr
    (43) expr -> expr . MMINUS expr
    (44) expr -> expr . MPLUS expr
    (45) expr -> expr . / expr
    (46) expr -> expr . * expr
    (47) expr -> expr . - expr
    (48) expr -> expr . + expr
    (18) loopblock -> . { loopstart }
    (19) loopblock -> . statement
    (4) statement -> . FOR ID = range loopblock
    (5) statement -> . WHILE expr loopblock
    (6) statement -> . IF expr ifblock ELSE ifblock
    (7) statement -> . IF expr ifblock
    (8) statement -> . PRINT expr ;
    (9) statement -> . expr ;
    (10) statement -> . RETURN
    (11) statement -> . ID DASSIGN expr ;
    (12) statement -> . ID TASSIGN expr ;
    (13) statement -> . ID MASSIGN expr ;
    (14) statement -> . ID PASSIGN expr ;
    (15) statement -> . ID = expr ;
    (24) expr -> . EYE ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ID
    (28) expr -> . [ outerlist ]
    (29) expr -> . STRING
    (30) expr -> . FLOAT
    (31) expr -> . INT
    (32) expr -> . expr '
    (33) expr -> . ( expr )
    (34) expr -> . expr NEQ expr
    (35) expr -> . expr EQ expr
    (36) expr -> . expr GEQ expr
    (37) expr -> . expr > expr
    (38) expr -> . expr LEQ expr
    (39) expr -> . expr < expr
    (40) expr -> . ' expr
    (41) expr -> . expr MDIVIDE expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MMINUS expr
    (44) expr -> . expr MPLUS expr
    (45) expr -> . expr / expr
    (46) expr -> . expr * expr
    (47) expr -> . expr - expr
    (48) expr -> . expr + expr
    '               shift and go to state 61
    NEQ             shift and go to state 31
    EQ              shift and go to state 32
    GEQ             shift and go to state 33
    >               shift and go to state 34
    LEQ             shift and go to state 35
    <               shift and go to state 36
    MDIVIDE         shift and go to state 37
    MTIMES          shift and go to state 38
    MMINUS          shift and go to state 39
    MPLUS           shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44
    {               shift and go to state 62
    FOR             shift and go to state 4
    WHILE           shift and go to state 6
    IF              shift and go to state 8
    PRINT           shift and go to state 9
    RETURN          shift and go to state 10
    ID              shift and go to state 5
    EYE             shift and go to state 11
    ONES            shift and go to state 13
    ZEROS           shift and go to state 14
    [               shift and go to state 15
    STRING          shift and go to state 16
    FLOAT           shift and go to state 17
    INT             shift and go to state 18
    (               shift and go to state 12

    expr                           shift and go to state 7
    loopblock                      shift and go to state 60
    statement                      shift and go to state 63

state 28

    (27) expr -> ID .
    '               reduce using rule 27 (expr -> ID .)
    NEQ             reduce using rule 27 (expr -> ID .)
    EQ              reduce using rule 27 (expr -> ID .)
    GEQ             reduce using rule 27 (expr -> ID .)
    >               reduce using rule 27 (expr -> ID .)
    LEQ             reduce using rule 27 (expr -> ID .)
    <               reduce using rule 27 (expr -> ID .)
    MDIVIDE         reduce using rule 27 (expr -> ID .)
    MTIMES          reduce using rule 27 (expr -> ID .)
    MMINUS          reduce using rule 27 (expr -> ID .)
    MPLUS           reduce using rule 27 (expr -> ID .)
    /               reduce using rule 27 (expr -> ID .)
    *               reduce using rule 27 (expr -> ID .)
    -               reduce using rule 27 (expr -> ID .)
    +               reduce using rule 27 (expr -> ID .)
    {               reduce using rule 27 (expr -> ID .)
    FOR             reduce using rule 27 (expr -> ID .)
    WHILE           reduce using rule 27 (expr -> ID .)
    IF              reduce using rule 27 (expr -> ID .)
    PRINT           reduce using rule 27 (expr -> ID .)
    RETURN          reduce using rule 27 (expr -> ID .)
    ID              reduce using rule 27 (expr -> ID .)
    EYE             reduce using rule 27 (expr -> ID .)
    ONES            reduce using rule 27 (expr -> ID .)
    ZEROS           reduce using rule 27 (expr -> ID .)
    [               reduce using rule 27 (expr -> ID .)
    STRING          reduce using rule 27 (expr -> ID .)
    FLOAT           reduce using rule 27 (expr -> ID .)
    INT             reduce using rule 27 (expr -> ID .)
    (               reduce using rule 27 (expr -> ID .)
    ;               reduce using rule 27 (expr -> ID .)
    )               reduce using rule 27 (expr -> ID .)


state 29

    (9) statement -> expr ; .
    FOR             reduce using rule 9 (statement -> expr ; .)
    WHILE           reduce using rule 9 (statement -> expr ; .)
    IF              reduce using rule 9 (statement -> expr ; .)
    PRINT           reduce using rule 9 (statement -> expr ; .)
    RETURN          reduce using rule 9 (statement -> expr ; .)
    ID              reduce using rule 9 (statement -> expr ; .)
    EYE             reduce using rule 9 (statement -> expr ; .)
    ONES            reduce using rule 9 (statement -> expr ; .)
    ZEROS           reduce using rule 9 (statement -> expr ; .)
    [               reduce using rule 9 (statement -> expr ; .)
    STRING          reduce using rule 9 (statement -> expr ; .)
    FLOAT           reduce using rule 9 (statement -> expr ; .)
    INT             reduce using rule 9 (statement -> expr ; .)
    (               reduce using rule 9 (statement -> expr ; .)
    '               reduce using rule 9 (statement -> expr ; .)
    $end            reduce using rule 9 (statement -> expr ; .)
    }               reduce using rule 9 (statement -> expr ; .)
    ELSE            reduce using rule 9 (statement -> expr ; .)
    BREAK           reduce using rule 9 (statement -> expr ; .)
    CONTINUE        reduce using rule 9 (statement -> expr ; .)


state 30

    (32) expr -> expr ' .
    ;               reduce using rule 32 (expr -> expr ' .)
    '               reduce using rule 32 (expr -> expr ' .)
    NEQ             reduce using rule 32 (expr -> expr ' .)
    EQ              reduce using rule 32 (expr -> expr ' .)
    GEQ             reduce using rule 32 (expr -> expr ' .)
    >               reduce using rule 32 (expr -> expr ' .)
    LEQ             reduce using rule 32 (expr -> expr ' .)
    <               reduce using rule 32 (expr -> expr ' .)
    MDIVIDE         reduce using rule 32 (expr -> expr ' .)
    MTIMES          reduce using rule 32 (expr -> expr ' .)
    MMINUS          reduce using rule 32 (expr -> expr ' .)
    MPLUS           reduce using rule 32 (expr -> expr ' .)
    /               reduce using rule 32 (expr -> expr ' .)
    *               reduce using rule 32 (expr -> expr ' .)
    -               reduce using rule 32 (expr -> expr ' .)
    +               reduce using rule 32 (expr -> expr ' .)
    )               reduce using rule 32 (expr -> expr ' .)
    {               reduce using rule 32 (expr -> expr ' .)
    FOR             reduce using rule 32 (expr -> expr ' .)
    WHILE           reduce using rule 32 (expr -> expr ' .)
    IF              reduce using rule 32 (expr -> expr ' .)
    PRINT           reduce using rule 32 (expr -> expr ' .)
    RETURN          reduce using rule 32 (expr -> expr ' .)
    ID              reduce using rule 32 (expr -> expr ' .)
    EYE             reduce using rule 32 (expr -> expr ' .)
    ONES            reduce using rule 32 (expr -> expr ' .)
    ZEROS           reduce using rule 32 (expr -> expr ' .)
    [               reduce using rule 32 (expr -> expr ' .)
    STRING          reduce using rule 32 (expr -> expr ' .)
    FLOAT           reduce using rule 32 (expr -> expr ' .)
    INT             reduce using rule 32 (expr -> expr ' .)
    (               reduce using rule 32 (expr -> expr ' .)


state 31

    (34) expr -> expr NEQ . expr
    (24) expr -> . EYE ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ID
    (28) expr -> . [ outerlist ]
    (29) expr -> . STRING
    (30) expr -> . FLOAT
    (31) expr -> . INT
    (32) expr -> . expr '
    (33) expr -> . ( expr )
    (34) expr -> . expr NEQ expr
    (35) expr -> . expr EQ expr
    (36) expr -> . expr GEQ expr
    (37) expr -> . expr > expr
    (38) expr -> . expr LEQ expr
    (39) expr -> . expr < expr
    (40) expr -> . ' expr
    (41) expr -> . expr MDIVIDE expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MMINUS expr
    (44) expr -> . expr MPLUS expr
    (45) expr -> . expr / expr
    (46) expr -> . expr * expr
    (47) expr -> . expr - expr
    (48) expr -> . expr + expr
    EYE             shift and go to state 11
    ONES            shift and go to state 13
    ZEROS           shift and go to state 14
    ID              shift and go to state 28
    [               shift and go to state 15
    STRING          shift and go to state 16
    FLOAT           shift and go to state 17
    INT             shift and go to state 18
    (               shift and go to state 12
    '               shift and go to state 19

    expr                           shift and go to state 64

state 32

    (35) expr -> expr EQ . expr
    (24) expr -> . EYE ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ID
    (28) expr -> . [ outerlist ]
    (29) expr -> . STRING
    (30) expr -> . FLOAT
    (31) expr -> . INT
    (32) expr -> . expr '
    (33) expr -> . ( expr )
    (34) expr -> . expr NEQ expr
    (35) expr -> . expr EQ expr
    (36) expr -> . expr GEQ expr
    (37) expr -> . expr > expr
    (38) expr -> . expr LEQ expr
    (39) expr -> . expr < expr
    (40) expr -> . ' expr
    (41) expr -> . expr MDIVIDE expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MMINUS expr
    (44) expr -> . expr MPLUS expr
    (45) expr -> . expr / expr
    (46) expr -> . expr * expr
    (47) expr -> . expr - expr
    (48) expr -> . expr + expr
    EYE             shift and go to state 11
    ONES            shift and go to state 13
    ZEROS           shift and go to state 14
    ID              shift and go to state 28
    [               shift and go to state 15
    STRING          shift and go to state 16
    FLOAT           shift and go to state 17
    INT             shift and go to state 18
    (               shift and go to state 12
    '               shift and go to state 19

    expr                           shift and go to state 65

state 33

    (36) expr -> expr GEQ . expr
    (24) expr -> . EYE ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ID
    (28) expr -> . [ outerlist ]
    (29) expr -> . STRING
    (30) expr -> . FLOAT
    (31) expr -> . INT
    (32) expr -> . expr '
    (33) expr -> . ( expr )
    (34) expr -> . expr NEQ expr
    (35) expr -> . expr EQ expr
    (36) expr -> . expr GEQ expr
    (37) expr -> . expr > expr
    (38) expr -> . expr LEQ expr
    (39) expr -> . expr < expr
    (40) expr -> . ' expr
    (41) expr -> . expr MDIVIDE expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MMINUS expr
    (44) expr -> . expr MPLUS expr
    (45) expr -> . expr / expr
    (46) expr -> . expr * expr
    (47) expr -> . expr - expr
    (48) expr -> . expr + expr
    EYE             shift and go to state 11
    ONES            shift and go to state 13
    ZEROS           shift and go to state 14
    ID              shift and go to state 28
    [               shift and go to state 15
    STRING          shift and go to state 16
    FLOAT           shift and go to state 17
    INT             shift and go to state 18
    (               shift and go to state 12
    '               shift and go to state 19

    expr                           shift and go to state 66

state 34

    (37) expr -> expr > . expr
    (24) expr -> . EYE ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ID
    (28) expr -> . [ outerlist ]
    (29) expr -> . STRING
    (30) expr -> . FLOAT
    (31) expr -> . INT
    (32) expr -> . expr '
    (33) expr -> . ( expr )
    (34) expr -> . expr NEQ expr
    (35) expr -> . expr EQ expr
    (36) expr -> . expr GEQ expr
    (37) expr -> . expr > expr
    (38) expr -> . expr LEQ expr
    (39) expr -> . expr < expr
    (40) expr -> . ' expr
    (41) expr -> . expr MDIVIDE expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MMINUS expr
    (44) expr -> . expr MPLUS expr
    (45) expr -> . expr / expr
    (46) expr -> . expr * expr
    (47) expr -> . expr - expr
    (48) expr -> . expr + expr
    EYE             shift and go to state 11
    ONES            shift and go to state 13
    ZEROS           shift and go to state 14
    ID              shift and go to state 28
    [               shift and go to state 15
    STRING          shift and go to state 16
    FLOAT           shift and go to state 17
    INT             shift and go to state 18
    (               shift and go to state 12
    '               shift and go to state 19

    expr                           shift and go to state 67

state 35

    (38) expr -> expr LEQ . expr
    (24) expr -> . EYE ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ID
    (28) expr -> . [ outerlist ]
    (29) expr -> . STRING
    (30) expr -> . FLOAT
    (31) expr -> . INT
    (32) expr -> . expr '
    (33) expr -> . ( expr )
    (34) expr -> . expr NEQ expr
    (35) expr -> . expr EQ expr
    (36) expr -> . expr GEQ expr
    (37) expr -> . expr > expr
    (38) expr -> . expr LEQ expr
    (39) expr -> . expr < expr
    (40) expr -> . ' expr
    (41) expr -> . expr MDIVIDE expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MMINUS expr
    (44) expr -> . expr MPLUS expr
    (45) expr -> . expr / expr
    (46) expr -> . expr * expr
    (47) expr -> . expr - expr
    (48) expr -> . expr + expr
    EYE             shift and go to state 11
    ONES            shift and go to state 13
    ZEROS           shift and go to state 14
    ID              shift and go to state 28
    [               shift and go to state 15
    STRING          shift and go to state 16
    FLOAT           shift and go to state 17
    INT             shift and go to state 18
    (               shift and go to state 12
    '               shift and go to state 19

    expr                           shift and go to state 68

state 36

    (39) expr -> expr < . expr
    (24) expr -> . EYE ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ID
    (28) expr -> . [ outerlist ]
    (29) expr -> . STRING
    (30) expr -> . FLOAT
    (31) expr -> . INT
    (32) expr -> . expr '
    (33) expr -> . ( expr )
    (34) expr -> . expr NEQ expr
    (35) expr -> . expr EQ expr
    (36) expr -> . expr GEQ expr
    (37) expr -> . expr > expr
    (38) expr -> . expr LEQ expr
    (39) expr -> . expr < expr
    (40) expr -> . ' expr
    (41) expr -> . expr MDIVIDE expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MMINUS expr
    (44) expr -> . expr MPLUS expr
    (45) expr -> . expr / expr
    (46) expr -> . expr * expr
    (47) expr -> . expr - expr
    (48) expr -> . expr + expr
    EYE             shift and go to state 11
    ONES            shift and go to state 13
    ZEROS           shift and go to state 14
    ID              shift and go to state 28
    [               shift and go to state 15
    STRING          shift and go to state 16
    FLOAT           shift and go to state 17
    INT             shift and go to state 18
    (               shift and go to state 12
    '               shift and go to state 19

    expr                           shift and go to state 69

state 37

    (41) expr -> expr MDIVIDE . expr
    (24) expr -> . EYE ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ID
    (28) expr -> . [ outerlist ]
    (29) expr -> . STRING
    (30) expr -> . FLOAT
    (31) expr -> . INT
    (32) expr -> . expr '
    (33) expr -> . ( expr )
    (34) expr -> . expr NEQ expr
    (35) expr -> . expr EQ expr
    (36) expr -> . expr GEQ expr
    (37) expr -> . expr > expr
    (38) expr -> . expr LEQ expr
    (39) expr -> . expr < expr
    (40) expr -> . ' expr
    (41) expr -> . expr MDIVIDE expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MMINUS expr
    (44) expr -> . expr MPLUS expr
    (45) expr -> . expr / expr
    (46) expr -> . expr * expr
    (47) expr -> . expr - expr
    (48) expr -> . expr + expr
    EYE             shift and go to state 11
    ONES            shift and go to state 13
    ZEROS           shift and go to state 14
    ID              shift and go to state 28
    [               shift and go to state 15
    STRING          shift and go to state 16
    FLOAT           shift and go to state 17
    INT             shift and go to state 18
    (               shift and go to state 12
    '               shift and go to state 19

    expr                           shift and go to state 70

state 38

    (42) expr -> expr MTIMES . expr
    (24) expr -> . EYE ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ID
    (28) expr -> . [ outerlist ]
    (29) expr -> . STRING
    (30) expr -> . FLOAT
    (31) expr -> . INT
    (32) expr -> . expr '
    (33) expr -> . ( expr )
    (34) expr -> . expr NEQ expr
    (35) expr -> . expr EQ expr
    (36) expr -> . expr GEQ expr
    (37) expr -> . expr > expr
    (38) expr -> . expr LEQ expr
    (39) expr -> . expr < expr
    (40) expr -> . ' expr
    (41) expr -> . expr MDIVIDE expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MMINUS expr
    (44) expr -> . expr MPLUS expr
    (45) expr -> . expr / expr
    (46) expr -> . expr * expr
    (47) expr -> . expr - expr
    (48) expr -> . expr + expr
    EYE             shift and go to state 11
    ONES            shift and go to state 13
    ZEROS           shift and go to state 14
    ID              shift and go to state 28
    [               shift and go to state 15
    STRING          shift and go to state 16
    FLOAT           shift and go to state 17
    INT             shift and go to state 18
    (               shift and go to state 12
    '               shift and go to state 19

    expr                           shift and go to state 71

state 39

    (43) expr -> expr MMINUS . expr
    (24) expr -> . EYE ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ID
    (28) expr -> . [ outerlist ]
    (29) expr -> . STRING
    (30) expr -> . FLOAT
    (31) expr -> . INT
    (32) expr -> . expr '
    (33) expr -> . ( expr )
    (34) expr -> . expr NEQ expr
    (35) expr -> . expr EQ expr
    (36) expr -> . expr GEQ expr
    (37) expr -> . expr > expr
    (38) expr -> . expr LEQ expr
    (39) expr -> . expr < expr
    (40) expr -> . ' expr
    (41) expr -> . expr MDIVIDE expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MMINUS expr
    (44) expr -> . expr MPLUS expr
    (45) expr -> . expr / expr
    (46) expr -> . expr * expr
    (47) expr -> . expr - expr
    (48) expr -> . expr + expr
    EYE             shift and go to state 11
    ONES            shift and go to state 13
    ZEROS           shift and go to state 14
    ID              shift and go to state 28
    [               shift and go to state 15
    STRING          shift and go to state 16
    FLOAT           shift and go to state 17
    INT             shift and go to state 18
    (               shift and go to state 12
    '               shift and go to state 19

    expr                           shift and go to state 72

state 40

    (44) expr -> expr MPLUS . expr
    (24) expr -> . EYE ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ID
    (28) expr -> . [ outerlist ]
    (29) expr -> . STRING
    (30) expr -> . FLOAT
    (31) expr -> . INT
    (32) expr -> . expr '
    (33) expr -> . ( expr )
    (34) expr -> . expr NEQ expr
    (35) expr -> . expr EQ expr
    (36) expr -> . expr GEQ expr
    (37) expr -> . expr > expr
    (38) expr -> . expr LEQ expr
    (39) expr -> . expr < expr
    (40) expr -> . ' expr
    (41) expr -> . expr MDIVIDE expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MMINUS expr
    (44) expr -> . expr MPLUS expr
    (45) expr -> . expr / expr
    (46) expr -> . expr * expr
    (47) expr -> . expr - expr
    (48) expr -> . expr + expr
    EYE             shift and go to state 11
    ONES            shift and go to state 13
    ZEROS           shift and go to state 14
    ID              shift and go to state 28
    [               shift and go to state 15
    STRING          shift and go to state 16
    FLOAT           shift and go to state 17
    INT             shift and go to state 18
    (               shift and go to state 12
    '               shift and go to state 19

    expr                           shift and go to state 73

state 41

    (45) expr -> expr / . expr
    (24) expr -> . EYE ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ID
    (28) expr -> . [ outerlist ]
    (29) expr -> . STRING
    (30) expr -> . FLOAT
    (31) expr -> . INT
    (32) expr -> . expr '
    (33) expr -> . ( expr )
    (34) expr -> . expr NEQ expr
    (35) expr -> . expr EQ expr
    (36) expr -> . expr GEQ expr
    (37) expr -> . expr > expr
    (38) expr -> . expr LEQ expr
    (39) expr -> . expr < expr
    (40) expr -> . ' expr
    (41) expr -> . expr MDIVIDE expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MMINUS expr
    (44) expr -> . expr MPLUS expr
    (45) expr -> . expr / expr
    (46) expr -> . expr * expr
    (47) expr -> . expr - expr
    (48) expr -> . expr + expr
    EYE             shift and go to state 11
    ONES            shift and go to state 13
    ZEROS           shift and go to state 14
    ID              shift and go to state 28
    [               shift and go to state 15
    STRING          shift and go to state 16
    FLOAT           shift and go to state 17
    INT             shift and go to state 18
    (               shift and go to state 12
    '               shift and go to state 19

    expr                           shift and go to state 74

state 42

    (46) expr -> expr * . expr
    (24) expr -> . EYE ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ID
    (28) expr -> . [ outerlist ]
    (29) expr -> . STRING
    (30) expr -> . FLOAT
    (31) expr -> . INT
    (32) expr -> . expr '
    (33) expr -> . ( expr )
    (34) expr -> . expr NEQ expr
    (35) expr -> . expr EQ expr
    (36) expr -> . expr GEQ expr
    (37) expr -> . expr > expr
    (38) expr -> . expr LEQ expr
    (39) expr -> . expr < expr
    (40) expr -> . ' expr
    (41) expr -> . expr MDIVIDE expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MMINUS expr
    (44) expr -> . expr MPLUS expr
    (45) expr -> . expr / expr
    (46) expr -> . expr * expr
    (47) expr -> . expr - expr
    (48) expr -> . expr + expr
    EYE             shift and go to state 11
    ONES            shift and go to state 13
    ZEROS           shift and go to state 14
    ID              shift and go to state 28
    [               shift and go to state 15
    STRING          shift and go to state 16
    FLOAT           shift and go to state 17
    INT             shift and go to state 18
    (               shift and go to state 12
    '               shift and go to state 19

    expr                           shift and go to state 75

state 43

    (47) expr -> expr - . expr
    (24) expr -> . EYE ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ID
    (28) expr -> . [ outerlist ]
    (29) expr -> . STRING
    (30) expr -> . FLOAT
    (31) expr -> . INT
    (32) expr -> . expr '
    (33) expr -> . ( expr )
    (34) expr -> . expr NEQ expr
    (35) expr -> . expr EQ expr
    (36) expr -> . expr GEQ expr
    (37) expr -> . expr > expr
    (38) expr -> . expr LEQ expr
    (39) expr -> . expr < expr
    (40) expr -> . ' expr
    (41) expr -> . expr MDIVIDE expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MMINUS expr
    (44) expr -> . expr MPLUS expr
    (45) expr -> . expr / expr
    (46) expr -> . expr * expr
    (47) expr -> . expr - expr
    (48) expr -> . expr + expr
    EYE             shift and go to state 11
    ONES            shift and go to state 13
    ZEROS           shift and go to state 14
    ID              shift and go to state 28
    [               shift and go to state 15
    STRING          shift and go to state 16
    FLOAT           shift and go to state 17
    INT             shift and go to state 18
    (               shift and go to state 12
    '               shift and go to state 19

    expr                           shift and go to state 76

state 44

    (48) expr -> expr + . expr
    (24) expr -> . EYE ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ID
    (28) expr -> . [ outerlist ]
    (29) expr -> . STRING
    (30) expr -> . FLOAT
    (31) expr -> . INT
    (32) expr -> . expr '
    (33) expr -> . ( expr )
    (34) expr -> . expr NEQ expr
    (35) expr -> . expr EQ expr
    (36) expr -> . expr GEQ expr
    (37) expr -> . expr > expr
    (38) expr -> . expr LEQ expr
    (39) expr -> . expr < expr
    (40) expr -> . ' expr
    (41) expr -> . expr MDIVIDE expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MMINUS expr
    (44) expr -> . expr MPLUS expr
    (45) expr -> . expr / expr
    (46) expr -> . expr * expr
    (47) expr -> . expr - expr
    (48) expr -> . expr + expr
    EYE             shift and go to state 11
    ONES            shift and go to state 13
    ZEROS           shift and go to state 14
    ID              shift and go to state 28
    [               shift and go to state 15
    STRING          shift and go to state 16
    FLOAT           shift and go to state 17
    INT             shift and go to state 18
    (               shift and go to state 12
    '               shift and go to state 19

    expr                           shift and go to state 77

state 45

    (6) statement -> IF expr . ifblock ELSE ifblock
    (7) statement -> IF expr . ifblock
    (32) expr -> expr . '
    (34) expr -> expr . NEQ expr
    (35) expr -> expr . EQ expr
    (36) expr -> expr . GEQ expr
    (37) expr -> expr . > expr
    (38) expr -> expr . LEQ expr
    (39) expr -> expr . < expr
    (41) expr -> expr . MDIVIDE expr
    (42) expr -> expr . MTIMES expr
    (43) expr -> expr . MMINUS expr
    (44) expr -> expr . MPLUS expr
    (45) expr -> expr . / expr
    (46) expr -> expr . * expr
    (47) expr -> expr . - expr
    (48) expr -> expr . + expr
    (16) ifblock -> . { start }
    (17) ifblock -> . statement
    (4) statement -> . FOR ID = range loopblock
    (5) statement -> . WHILE expr loopblock
    (6) statement -> . IF expr ifblock ELSE ifblock
    (7) statement -> . IF expr ifblock
    (8) statement -> . PRINT expr ;
    (9) statement -> . expr ;
    (10) statement -> . RETURN
    (11) statement -> . ID DASSIGN expr ;
    (12) statement -> . ID TASSIGN expr ;
    (13) statement -> . ID MASSIGN expr ;
    (14) statement -> . ID PASSIGN expr ;
    (15) statement -> . ID = expr ;
    (24) expr -> . EYE ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ID
    (28) expr -> . [ outerlist ]
    (29) expr -> . STRING
    (30) expr -> . FLOAT
    (31) expr -> . INT
    (32) expr -> . expr '
    (33) expr -> . ( expr )
    (34) expr -> . expr NEQ expr
    (35) expr -> . expr EQ expr
    (36) expr -> . expr GEQ expr
    (37) expr -> . expr > expr
    (38) expr -> . expr LEQ expr
    (39) expr -> . expr < expr
    (40) expr -> . ' expr
    (41) expr -> . expr MDIVIDE expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MMINUS expr
    (44) expr -> . expr MPLUS expr
    (45) expr -> . expr / expr
    (46) expr -> . expr * expr
    (47) expr -> . expr - expr
    (48) expr -> . expr + expr
    '               shift and go to state 61
    NEQ             shift and go to state 31
    EQ              shift and go to state 32
    GEQ             shift and go to state 33
    >               shift and go to state 34
    LEQ             shift and go to state 35
    <               shift and go to state 36
    MDIVIDE         shift and go to state 37
    MTIMES          shift and go to state 38
    MMINUS          shift and go to state 39
    MPLUS           shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44
    {               shift and go to state 79
    FOR             shift and go to state 4
    WHILE           shift and go to state 6
    IF              shift and go to state 8
    PRINT           shift and go to state 9
    RETURN          shift and go to state 10
    ID              shift and go to state 5
    EYE             shift and go to state 11
    ONES            shift and go to state 13
    ZEROS           shift and go to state 14
    [               shift and go to state 15
    STRING          shift and go to state 16
    FLOAT           shift and go to state 17
    INT             shift and go to state 18
    (               shift and go to state 12

    expr                           shift and go to state 7
    ifblock                        shift and go to state 78
    statement                      shift and go to state 80

state 46

    (8) statement -> PRINT expr . ;
    (32) expr -> expr . '
    (34) expr -> expr . NEQ expr
    (35) expr -> expr . EQ expr
    (36) expr -> expr . GEQ expr
    (37) expr -> expr . > expr
    (38) expr -> expr . LEQ expr
    (39) expr -> expr . < expr
    (41) expr -> expr . MDIVIDE expr
    (42) expr -> expr . MTIMES expr
    (43) expr -> expr . MMINUS expr
    (44) expr -> expr . MPLUS expr
    (45) expr -> expr . / expr
    (46) expr -> expr . * expr
    (47) expr -> expr . - expr
    (48) expr -> expr . + expr
    ;               shift and go to state 81
    '               shift and go to state 30
    NEQ             shift and go to state 31
    EQ              shift and go to state 32
    GEQ             shift and go to state 33
    >               shift and go to state 34
    LEQ             shift and go to state 35
    <               shift and go to state 36
    MDIVIDE         shift and go to state 37
    MTIMES          shift and go to state 38
    MMINUS          shift and go to state 39
    MPLUS           shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44


state 47

    (24) expr -> EYE ( . expr )
    (24) expr -> . EYE ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ID
    (28) expr -> . [ outerlist ]
    (29) expr -> . STRING
    (30) expr -> . FLOAT
    (31) expr -> . INT
    (32) expr -> . expr '
    (33) expr -> . ( expr )
    (34) expr -> . expr NEQ expr
    (35) expr -> . expr EQ expr
    (36) expr -> . expr GEQ expr
    (37) expr -> . expr > expr
    (38) expr -> . expr LEQ expr
    (39) expr -> . expr < expr
    (40) expr -> . ' expr
    (41) expr -> . expr MDIVIDE expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MMINUS expr
    (44) expr -> . expr MPLUS expr
    (45) expr -> . expr / expr
    (46) expr -> . expr * expr
    (47) expr -> . expr - expr
    (48) expr -> . expr + expr
    EYE             shift and go to state 11
    ONES            shift and go to state 13
    ZEROS           shift and go to state 14
    ID              shift and go to state 28
    [               shift and go to state 15
    STRING          shift and go to state 16
    FLOAT           shift and go to state 17
    INT             shift and go to state 18
    (               shift and go to state 12
    '               shift and go to state 19

    expr                           shift and go to state 82

state 48

    (33) expr -> ( expr . )
    (32) expr -> expr . '
    (34) expr -> expr . NEQ expr
    (35) expr -> expr . EQ expr
    (36) expr -> expr . GEQ expr
    (37) expr -> expr . > expr
    (38) expr -> expr . LEQ expr
    (39) expr -> expr . < expr
    (41) expr -> expr . MDIVIDE expr
    (42) expr -> expr . MTIMES expr
    (43) expr -> expr . MMINUS expr
    (44) expr -> expr . MPLUS expr
    (45) expr -> expr . / expr
    (46) expr -> expr . * expr
    (47) expr -> expr . - expr
    (48) expr -> expr . + expr
    )               shift and go to state 83
    '               shift and go to state 30
    NEQ             shift and go to state 31
    EQ              shift and go to state 32
    GEQ             shift and go to state 33
    >               shift and go to state 34
    LEQ             shift and go to state 35
    <               shift and go to state 36
    MDIVIDE         shift and go to state 37
    MTIMES          shift and go to state 38
    MMINUS          shift and go to state 39
    MPLUS           shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44


state 49

    (25) expr -> ONES ( . expr )
    (24) expr -> . EYE ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ID
    (28) expr -> . [ outerlist ]
    (29) expr -> . STRING
    (30) expr -> . FLOAT
    (31) expr -> . INT
    (32) expr -> . expr '
    (33) expr -> . ( expr )
    (34) expr -> . expr NEQ expr
    (35) expr -> . expr EQ expr
    (36) expr -> . expr GEQ expr
    (37) expr -> . expr > expr
    (38) expr -> . expr LEQ expr
    (39) expr -> . expr < expr
    (40) expr -> . ' expr
    (41) expr -> . expr MDIVIDE expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MMINUS expr
    (44) expr -> . expr MPLUS expr
    (45) expr -> . expr / expr
    (46) expr -> . expr * expr
    (47) expr -> . expr - expr
    (48) expr -> . expr + expr
    EYE             shift and go to state 11
    ONES            shift and go to state 13
    ZEROS           shift and go to state 14
    ID              shift and go to state 28
    [               shift and go to state 15
    STRING          shift and go to state 16
    FLOAT           shift and go to state 17
    INT             shift and go to state 18
    (               shift and go to state 12
    '               shift and go to state 19

    expr                           shift and go to state 84

state 50

    (26) expr -> ZEROS ( . expr )
    (24) expr -> . EYE ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ID
    (28) expr -> . [ outerlist ]
    (29) expr -> . STRING
    (30) expr -> . FLOAT
    (31) expr -> . INT
    (32) expr -> . expr '
    (33) expr -> . ( expr )
    (34) expr -> . expr NEQ expr
    (35) expr -> . expr EQ expr
    (36) expr -> . expr GEQ expr
    (37) expr -> . expr > expr
    (38) expr -> . expr LEQ expr
    (39) expr -> . expr < expr
    (40) expr -> . ' expr
    (41) expr -> . expr MDIVIDE expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MMINUS expr
    (44) expr -> . expr MPLUS expr
    (45) expr -> . expr / expr
    (46) expr -> . expr * expr
    (47) expr -> . expr - expr
    (48) expr -> . expr + expr
    EYE             shift and go to state 11
    ONES            shift and go to state 13
    ZEROS           shift and go to state 14
    ID              shift and go to state 28
    [               shift and go to state 15
    STRING          shift and go to state 16
    FLOAT           shift and go to state 17
    INT             shift and go to state 18
    (               shift and go to state 12
    '               shift and go to state 19

    expr                           shift and go to state 85

state 51

    (53) outerlist -> [ . innerlist ]
    (55) innerlist -> . elem
    (56) innerlist -> . innerlist , elem
    (57) elem -> . STRING
    (58) elem -> . FLOAT
    (59) elem -> . INT
    STRING          shift and go to state 88
    FLOAT           shift and go to state 89
    INT             shift and go to state 90

    innerlist                      shift and go to state 86
    elem                           shift and go to state 87

state 52

    (28) expr -> [ outerlist . ]
    (54) outerlist -> outerlist . , [ innerlist ]
    ]               shift and go to state 91
    ,               shift and go to state 92


state 53

    (40) expr -> ' expr .
    (32) expr -> expr . '
    (34) expr -> expr . NEQ expr
    (35) expr -> expr . EQ expr
    (36) expr -> expr . GEQ expr
    (37) expr -> expr . > expr
    (38) expr -> expr . LEQ expr
    (39) expr -> expr . < expr
    (41) expr -> expr . MDIVIDE expr
    (42) expr -> expr . MTIMES expr
    (43) expr -> expr . MMINUS expr
    (44) expr -> expr . MPLUS expr
    (45) expr -> expr . / expr
    (46) expr -> expr . * expr
    (47) expr -> expr . - expr
    (48) expr -> expr . + expr
    ;               reduce using rule 40 (expr -> ' expr .)
    NEQ             reduce using rule 40 (expr -> ' expr .)
    EQ              reduce using rule 40 (expr -> ' expr .)
    GEQ             reduce using rule 40 (expr -> ' expr .)
    >               reduce using rule 40 (expr -> ' expr .)
    LEQ             reduce using rule 40 (expr -> ' expr .)
    <               reduce using rule 40 (expr -> ' expr .)
    MDIVIDE         reduce using rule 40 (expr -> ' expr .)
    MTIMES          reduce using rule 40 (expr -> ' expr .)
    MMINUS          reduce using rule 40 (expr -> ' expr .)
    MPLUS           reduce using rule 40 (expr -> ' expr .)
    /               reduce using rule 40 (expr -> ' expr .)
    *               reduce using rule 40 (expr -> ' expr .)
    -               reduce using rule 40 (expr -> ' expr .)
    +               reduce using rule 40 (expr -> ' expr .)
    {               reduce using rule 40 (expr -> ' expr .)
    FOR             reduce using rule 40 (expr -> ' expr .)
    WHILE           reduce using rule 40 (expr -> ' expr .)
    IF              reduce using rule 40 (expr -> ' expr .)
    PRINT           reduce using rule 40 (expr -> ' expr .)
    RETURN          reduce using rule 40 (expr -> ' expr .)
    ID              reduce using rule 40 (expr -> ' expr .)
    EYE             reduce using rule 40 (expr -> ' expr .)
    ONES            reduce using rule 40 (expr -> ' expr .)
    ZEROS           reduce using rule 40 (expr -> ' expr .)
    [               reduce using rule 40 (expr -> ' expr .)
    STRING          reduce using rule 40 (expr -> ' expr .)
    FLOAT           reduce using rule 40 (expr -> ' expr .)
    INT             reduce using rule 40 (expr -> ' expr .)
    (               reduce using rule 40 (expr -> ' expr .)
    )               reduce using rule 40 (expr -> ' expr .)
    '               shift and go to state 30


state 54

    (4) statement -> FOR ID = . range loopblock
    (49) range -> . INT : ID
    (50) range -> . ID : INT
    (51) range -> . ID : ID
    (52) range -> . INT : INT
    INT             shift and go to state 95
    ID              shift and go to state 93

    range                          shift and go to state 94

state 55

    (11) statement -> ID DASSIGN expr . ;
    (32) expr -> expr . '
    (34) expr -> expr . NEQ expr
    (35) expr -> expr . EQ expr
    (36) expr -> expr . GEQ expr
    (37) expr -> expr . > expr
    (38) expr -> expr . LEQ expr
    (39) expr -> expr . < expr
    (41) expr -> expr . MDIVIDE expr
    (42) expr -> expr . MTIMES expr
    (43) expr -> expr . MMINUS expr
    (44) expr -> expr . MPLUS expr
    (45) expr -> expr . / expr
    (46) expr -> expr . * expr
    (47) expr -> expr . - expr
    (48) expr -> expr . + expr
    ;               shift and go to state 96
    '               shift and go to state 30
    NEQ             shift and go to state 31
    EQ              shift and go to state 32
    GEQ             shift and go to state 33
    >               shift and go to state 34
    LEQ             shift and go to state 35
    <               shift and go to state 36
    MDIVIDE         shift and go to state 37
    MTIMES          shift and go to state 38
    MMINUS          shift and go to state 39
    MPLUS           shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44


state 56

    (12) statement -> ID TASSIGN expr . ;
    (32) expr -> expr . '
    (34) expr -> expr . NEQ expr
    (35) expr -> expr . EQ expr
    (36) expr -> expr . GEQ expr
    (37) expr -> expr . > expr
    (38) expr -> expr . LEQ expr
    (39) expr -> expr . < expr
    (41) expr -> expr . MDIVIDE expr
    (42) expr -> expr . MTIMES expr
    (43) expr -> expr . MMINUS expr
    (44) expr -> expr . MPLUS expr
    (45) expr -> expr . / expr
    (46) expr -> expr . * expr
    (47) expr -> expr . - expr
    (48) expr -> expr . + expr
    ;               shift and go to state 97
    '               shift and go to state 30
    NEQ             shift and go to state 31
    EQ              shift and go to state 32
    GEQ             shift and go to state 33
    >               shift and go to state 34
    LEQ             shift and go to state 35
    <               shift and go to state 36
    MDIVIDE         shift and go to state 37
    MTIMES          shift and go to state 38
    MMINUS          shift and go to state 39
    MPLUS           shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44


state 57

    (13) statement -> ID MASSIGN expr . ;
    (32) expr -> expr . '
    (34) expr -> expr . NEQ expr
    (35) expr -> expr . EQ expr
    (36) expr -> expr . GEQ expr
    (37) expr -> expr . > expr
    (38) expr -> expr . LEQ expr
    (39) expr -> expr . < expr
    (41) expr -> expr . MDIVIDE expr
    (42) expr -> expr . MTIMES expr
    (43) expr -> expr . MMINUS expr
    (44) expr -> expr . MPLUS expr
    (45) expr -> expr . / expr
    (46) expr -> expr . * expr
    (47) expr -> expr . - expr
    (48) expr -> expr . + expr
    ;               shift and go to state 98
    '               shift and go to state 30
    NEQ             shift and go to state 31
    EQ              shift and go to state 32
    GEQ             shift and go to state 33
    >               shift and go to state 34
    LEQ             shift and go to state 35
    <               shift and go to state 36
    MDIVIDE         shift and go to state 37
    MTIMES          shift and go to state 38
    MMINUS          shift and go to state 39
    MPLUS           shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44


state 58

    (14) statement -> ID PASSIGN expr . ;
    (32) expr -> expr . '
    (34) expr -> expr . NEQ expr
    (35) expr -> expr . EQ expr
    (36) expr -> expr . GEQ expr
    (37) expr -> expr . > expr
    (38) expr -> expr . LEQ expr
    (39) expr -> expr . < expr
    (41) expr -> expr . MDIVIDE expr
    (42) expr -> expr . MTIMES expr
    (43) expr -> expr . MMINUS expr
    (44) expr -> expr . MPLUS expr
    (45) expr -> expr . / expr
    (46) expr -> expr . * expr
    (47) expr -> expr . - expr
    (48) expr -> expr . + expr
    ;               shift and go to state 99
    '               shift and go to state 30
    NEQ             shift and go to state 31
    EQ              shift and go to state 32
    GEQ             shift and go to state 33
    >               shift and go to state 34
    LEQ             shift and go to state 35
    <               shift and go to state 36
    MDIVIDE         shift and go to state 37
    MTIMES          shift and go to state 38
    MMINUS          shift and go to state 39
    MPLUS           shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44


state 59

    (15) statement -> ID = expr . ;
    (32) expr -> expr . '
    (34) expr -> expr . NEQ expr
    (35) expr -> expr . EQ expr
    (36) expr -> expr . GEQ expr
    (37) expr -> expr . > expr
    (38) expr -> expr . LEQ expr
    (39) expr -> expr . < expr
    (41) expr -> expr . MDIVIDE expr
    (42) expr -> expr . MTIMES expr
    (43) expr -> expr . MMINUS expr
    (44) expr -> expr . MPLUS expr
    (45) expr -> expr . / expr
    (46) expr -> expr . * expr
    (47) expr -> expr . - expr
    (48) expr -> expr . + expr
    ;               shift and go to state 100
    '               shift and go to state 30
    NEQ             shift and go to state 31
    EQ              shift and go to state 32
    GEQ             shift and go to state 33
    >               shift and go to state 34
    LEQ             shift and go to state 35
    <               shift and go to state 36
    MDIVIDE         shift and go to state 37
    MTIMES          shift and go to state 38
    MMINUS          shift and go to state 39
    MPLUS           shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44


state 60

    (5) statement -> WHILE expr loopblock .
    FOR             reduce using rule 5 (statement -> WHILE expr loopblock .)
    WHILE           reduce using rule 5 (statement -> WHILE expr loopblock .)
    IF              reduce using rule 5 (statement -> WHILE expr loopblock .)
    PRINT           reduce using rule 5 (statement -> WHILE expr loopblock .)
    RETURN          reduce using rule 5 (statement -> WHILE expr loopblock .)
    ID              reduce using rule 5 (statement -> WHILE expr loopblock .)
    EYE             reduce using rule 5 (statement -> WHILE expr loopblock .)
    ONES            reduce using rule 5 (statement -> WHILE expr loopblock .)
    ZEROS           reduce using rule 5 (statement -> WHILE expr loopblock .)
    [               reduce using rule 5 (statement -> WHILE expr loopblock .)
    STRING          reduce using rule 5 (statement -> WHILE expr loopblock .)
    FLOAT           reduce using rule 5 (statement -> WHILE expr loopblock .)
    INT             reduce using rule 5 (statement -> WHILE expr loopblock .)
    (               reduce using rule 5 (statement -> WHILE expr loopblock .)
    '               reduce using rule 5 (statement -> WHILE expr loopblock .)
    $end            reduce using rule 5 (statement -> WHILE expr loopblock .)
    }               reduce using rule 5 (statement -> WHILE expr loopblock .)
    ELSE            reduce using rule 5 (statement -> WHILE expr loopblock .)
    BREAK           reduce using rule 5 (statement -> WHILE expr loopblock .)
    CONTINUE        reduce using rule 5 (statement -> WHILE expr loopblock .)


state 61

    (32) expr -> expr ' .
    (40) expr -> ' . expr
    (24) expr -> . EYE ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ID
    (28) expr -> . [ outerlist ]
    (29) expr -> . STRING
    (30) expr -> . FLOAT
    (31) expr -> . INT
    (32) expr -> . expr '
    (33) expr -> . ( expr )
    (34) expr -> . expr NEQ expr
    (35) expr -> . expr EQ expr
    (36) expr -> . expr GEQ expr
    (37) expr -> . expr > expr
    (38) expr -> . expr LEQ expr
    (39) expr -> . expr < expr
    (40) expr -> . ' expr
    (41) expr -> . expr MDIVIDE expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MMINUS expr
    (44) expr -> . expr MPLUS expr
    (45) expr -> . expr / expr
    (46) expr -> . expr * expr
    (47) expr -> . expr - expr
    (48) expr -> . expr + expr
    NEQ             reduce using rule 32 (expr -> expr ' .)
    EQ              reduce using rule 32 (expr -> expr ' .)
    GEQ             reduce using rule 32 (expr -> expr ' .)
    >               reduce using rule 32 (expr -> expr ' .)
    LEQ             reduce using rule 32 (expr -> expr ' .)
    <               reduce using rule 32 (expr -> expr ' .)
    MDIVIDE         reduce using rule 32 (expr -> expr ' .)
    MTIMES          reduce using rule 32 (expr -> expr ' .)
    MMINUS          reduce using rule 32 (expr -> expr ' .)
    MPLUS           reduce using rule 32 (expr -> expr ' .)
    /               reduce using rule 32 (expr -> expr ' .)
    *               reduce using rule 32 (expr -> expr ' .)
    -               reduce using rule 32 (expr -> expr ' .)
    +               reduce using rule 32 (expr -> expr ' .)
    {               reduce using rule 32 (expr -> expr ' .)
    FOR             reduce using rule 32 (expr -> expr ' .)
    WHILE           reduce using rule 32 (expr -> expr ' .)
    IF              reduce using rule 32 (expr -> expr ' .)
    PRINT           reduce using rule 32 (expr -> expr ' .)
    RETURN          reduce using rule 32 (expr -> expr ' .)
    ID              reduce using rule 32 (expr -> expr ' .)
    EYE             reduce using rule 32 (expr -> expr ' .)
    ONES            reduce using rule 32 (expr -> expr ' .)
    ZEROS           reduce using rule 32 (expr -> expr ' .)
    [               reduce using rule 32 (expr -> expr ' .)
    STRING          reduce using rule 32 (expr -> expr ' .)
    FLOAT           reduce using rule 32 (expr -> expr ' .)
    INT             reduce using rule 32 (expr -> expr ' .)
    (               reduce using rule 32 (expr -> expr ' .)
    '               shift and go to state 19

    expr                           shift and go to state 53

state 62

    (18) loopblock -> { . loopstart }
    (20) loopstart -> . empty
    (21) loopstart -> . BREAK ;
    (22) loopstart -> . CONTINUE ;
    (23) loopstart -> . statement loopstart
    (1) empty -> .
    (4) statement -> . FOR ID = range loopblock
    (5) statement -> . WHILE expr loopblock
    (6) statement -> . IF expr ifblock ELSE ifblock
    (7) statement -> . IF expr ifblock
    (8) statement -> . PRINT expr ;
    (9) statement -> . expr ;
    (10) statement -> . RETURN
    (11) statement -> . ID DASSIGN expr ;
    (12) statement -> . ID TASSIGN expr ;
    (13) statement -> . ID MASSIGN expr ;
    (14) statement -> . ID PASSIGN expr ;
    (15) statement -> . ID = expr ;
    (24) expr -> . EYE ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ID
    (28) expr -> . [ outerlist ]
    (29) expr -> . STRING
    (30) expr -> . FLOAT
    (31) expr -> . INT
    (32) expr -> . expr '
    (33) expr -> . ( expr )
    (34) expr -> . expr NEQ expr
    (35) expr -> . expr EQ expr
    (36) expr -> . expr GEQ expr
    (37) expr -> . expr > expr
    (38) expr -> . expr LEQ expr
    (39) expr -> . expr < expr
    (40) expr -> . ' expr
    (41) expr -> . expr MDIVIDE expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MMINUS expr
    (44) expr -> . expr MPLUS expr
    (45) expr -> . expr / expr
    (46) expr -> . expr * expr
    (47) expr -> . expr - expr
    (48) expr -> . expr + expr
    BREAK           shift and go to state 103
    CONTINUE        shift and go to state 104
    }               reduce using rule 1 (empty -> .)
    FOR             shift and go to state 4
    WHILE           shift and go to state 6
    IF              shift and go to state 8
    PRINT           shift and go to state 9
    RETURN          shift and go to state 10
    ID              shift and go to state 5
    EYE             shift and go to state 11
    ONES            shift and go to state 13
    ZEROS           shift and go to state 14
    [               shift and go to state 15
    STRING          shift and go to state 16
    FLOAT           shift and go to state 17
    INT             shift and go to state 18
    (               shift and go to state 12
    '               shift and go to state 19

    loopstart                      shift and go to state 101
    empty                          shift and go to state 102
    statement                      shift and go to state 105
    expr                           shift and go to state 7

state 63

    (19) loopblock -> statement .
    FOR             reduce using rule 19 (loopblock -> statement .)
    WHILE           reduce using rule 19 (loopblock -> statement .)
    IF              reduce using rule 19 (loopblock -> statement .)
    PRINT           reduce using rule 19 (loopblock -> statement .)
    RETURN          reduce using rule 19 (loopblock -> statement .)
    ID              reduce using rule 19 (loopblock -> statement .)
    EYE             reduce using rule 19 (loopblock -> statement .)
    ONES            reduce using rule 19 (loopblock -> statement .)
    ZEROS           reduce using rule 19 (loopblock -> statement .)
    [               reduce using rule 19 (loopblock -> statement .)
    STRING          reduce using rule 19 (loopblock -> statement .)
    FLOAT           reduce using rule 19 (loopblock -> statement .)
    INT             reduce using rule 19 (loopblock -> statement .)
    (               reduce using rule 19 (loopblock -> statement .)
    '               reduce using rule 19 (loopblock -> statement .)
    $end            reduce using rule 19 (loopblock -> statement .)
    }               reduce using rule 19 (loopblock -> statement .)
    ELSE            reduce using rule 19 (loopblock -> statement .)
    BREAK           reduce using rule 19 (loopblock -> statement .)
    CONTINUE        reduce using rule 19 (loopblock -> statement .)


state 64

    (34) expr -> expr NEQ expr .
    (32) expr -> expr . '
    (34) expr -> expr . NEQ expr
    (35) expr -> expr . EQ expr
    (36) expr -> expr . GEQ expr
    (37) expr -> expr . > expr
    (38) expr -> expr . LEQ expr
    (39) expr -> expr . < expr
    (41) expr -> expr . MDIVIDE expr
    (42) expr -> expr . MTIMES expr
    (43) expr -> expr . MMINUS expr
    (44) expr -> expr . MPLUS expr
    (45) expr -> expr . / expr
    (46) expr -> expr . * expr
    (47) expr -> expr . - expr
    (48) expr -> expr . + expr
    ;               reduce using rule 34 (expr -> expr NEQ expr .)
    NEQ             reduce using rule 34 (expr -> expr NEQ expr .)
    EQ              reduce using rule 34 (expr -> expr NEQ expr .)
    GEQ             reduce using rule 34 (expr -> expr NEQ expr .)
    >               reduce using rule 34 (expr -> expr NEQ expr .)
    LEQ             reduce using rule 34 (expr -> expr NEQ expr .)
    <               reduce using rule 34 (expr -> expr NEQ expr .)
    {               reduce using rule 34 (expr -> expr NEQ expr .)
    FOR             reduce using rule 34 (expr -> expr NEQ expr .)
    WHILE           reduce using rule 34 (expr -> expr NEQ expr .)
    IF              reduce using rule 34 (expr -> expr NEQ expr .)
    PRINT           reduce using rule 34 (expr -> expr NEQ expr .)
    RETURN          reduce using rule 34 (expr -> expr NEQ expr .)
    ID              reduce using rule 34 (expr -> expr NEQ expr .)
    EYE             reduce using rule 34 (expr -> expr NEQ expr .)
    ONES            reduce using rule 34 (expr -> expr NEQ expr .)
    ZEROS           reduce using rule 34 (expr -> expr NEQ expr .)
    [               reduce using rule 34 (expr -> expr NEQ expr .)
    STRING          reduce using rule 34 (expr -> expr NEQ expr .)
    FLOAT           reduce using rule 34 (expr -> expr NEQ expr .)
    INT             reduce using rule 34 (expr -> expr NEQ expr .)
    (               reduce using rule 34 (expr -> expr NEQ expr .)
    )               reduce using rule 34 (expr -> expr NEQ expr .)
    '               shift and go to state 30
    MDIVIDE         shift and go to state 37
    MTIMES          shift and go to state 38
    MMINUS          shift and go to state 39
    MPLUS           shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44


state 65

    (35) expr -> expr EQ expr .
    (32) expr -> expr . '
    (34) expr -> expr . NEQ expr
    (35) expr -> expr . EQ expr
    (36) expr -> expr . GEQ expr
    (37) expr -> expr . > expr
    (38) expr -> expr . LEQ expr
    (39) expr -> expr . < expr
    (41) expr -> expr . MDIVIDE expr
    (42) expr -> expr . MTIMES expr
    (43) expr -> expr . MMINUS expr
    (44) expr -> expr . MPLUS expr
    (45) expr -> expr . / expr
    (46) expr -> expr . * expr
    (47) expr -> expr . - expr
    (48) expr -> expr . + expr
    ;               reduce using rule 35 (expr -> expr EQ expr .)
    NEQ             reduce using rule 35 (expr -> expr EQ expr .)
    EQ              reduce using rule 35 (expr -> expr EQ expr .)
    GEQ             reduce using rule 35 (expr -> expr EQ expr .)
    >               reduce using rule 35 (expr -> expr EQ expr .)
    LEQ             reduce using rule 35 (expr -> expr EQ expr .)
    <               reduce using rule 35 (expr -> expr EQ expr .)
    {               reduce using rule 35 (expr -> expr EQ expr .)
    FOR             reduce using rule 35 (expr -> expr EQ expr .)
    WHILE           reduce using rule 35 (expr -> expr EQ expr .)
    IF              reduce using rule 35 (expr -> expr EQ expr .)
    PRINT           reduce using rule 35 (expr -> expr EQ expr .)
    RETURN          reduce using rule 35 (expr -> expr EQ expr .)
    ID              reduce using rule 35 (expr -> expr EQ expr .)
    EYE             reduce using rule 35 (expr -> expr EQ expr .)
    ONES            reduce using rule 35 (expr -> expr EQ expr .)
    ZEROS           reduce using rule 35 (expr -> expr EQ expr .)
    [               reduce using rule 35 (expr -> expr EQ expr .)
    STRING          reduce using rule 35 (expr -> expr EQ expr .)
    FLOAT           reduce using rule 35 (expr -> expr EQ expr .)
    INT             reduce using rule 35 (expr -> expr EQ expr .)
    (               reduce using rule 35 (expr -> expr EQ expr .)
    )               reduce using rule 35 (expr -> expr EQ expr .)
    '               shift and go to state 30
    MDIVIDE         shift and go to state 37
    MTIMES          shift and go to state 38
    MMINUS          shift and go to state 39
    MPLUS           shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44


state 66

    (36) expr -> expr GEQ expr .
    (32) expr -> expr . '
    (34) expr -> expr . NEQ expr
    (35) expr -> expr . EQ expr
    (36) expr -> expr . GEQ expr
    (37) expr -> expr . > expr
    (38) expr -> expr . LEQ expr
    (39) expr -> expr . < expr
    (41) expr -> expr . MDIVIDE expr
    (42) expr -> expr . MTIMES expr
    (43) expr -> expr . MMINUS expr
    (44) expr -> expr . MPLUS expr
    (45) expr -> expr . / expr
    (46) expr -> expr . * expr
    (47) expr -> expr . - expr
    (48) expr -> expr . + expr
    ;               reduce using rule 36 (expr -> expr GEQ expr .)
    NEQ             reduce using rule 36 (expr -> expr GEQ expr .)
    EQ              reduce using rule 36 (expr -> expr GEQ expr .)
    GEQ             reduce using rule 36 (expr -> expr GEQ expr .)
    >               reduce using rule 36 (expr -> expr GEQ expr .)
    LEQ             reduce using rule 36 (expr -> expr GEQ expr .)
    <               reduce using rule 36 (expr -> expr GEQ expr .)
    {               reduce using rule 36 (expr -> expr GEQ expr .)
    FOR             reduce using rule 36 (expr -> expr GEQ expr .)
    WHILE           reduce using rule 36 (expr -> expr GEQ expr .)
    IF              reduce using rule 36 (expr -> expr GEQ expr .)
    PRINT           reduce using rule 36 (expr -> expr GEQ expr .)
    RETURN          reduce using rule 36 (expr -> expr GEQ expr .)
    ID              reduce using rule 36 (expr -> expr GEQ expr .)
    EYE             reduce using rule 36 (expr -> expr GEQ expr .)
    ONES            reduce using rule 36 (expr -> expr GEQ expr .)
    ZEROS           reduce using rule 36 (expr -> expr GEQ expr .)
    [               reduce using rule 36 (expr -> expr GEQ expr .)
    STRING          reduce using rule 36 (expr -> expr GEQ expr .)
    FLOAT           reduce using rule 36 (expr -> expr GEQ expr .)
    INT             reduce using rule 36 (expr -> expr GEQ expr .)
    (               reduce using rule 36 (expr -> expr GEQ expr .)
    )               reduce using rule 36 (expr -> expr GEQ expr .)
    '               shift and go to state 30
    MDIVIDE         shift and go to state 37
    MTIMES          shift and go to state 38
    MMINUS          shift and go to state 39
    MPLUS           shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44


state 67

    (37) expr -> expr > expr .
    (32) expr -> expr . '
    (34) expr -> expr . NEQ expr
    (35) expr -> expr . EQ expr
    (36) expr -> expr . GEQ expr
    (37) expr -> expr . > expr
    (38) expr -> expr . LEQ expr
    (39) expr -> expr . < expr
    (41) expr -> expr . MDIVIDE expr
    (42) expr -> expr . MTIMES expr
    (43) expr -> expr . MMINUS expr
    (44) expr -> expr . MPLUS expr
    (45) expr -> expr . / expr
    (46) expr -> expr . * expr
    (47) expr -> expr . - expr
    (48) expr -> expr . + expr
    ;               reduce using rule 37 (expr -> expr > expr .)
    NEQ             reduce using rule 37 (expr -> expr > expr .)
    EQ              reduce using rule 37 (expr -> expr > expr .)
    GEQ             reduce using rule 37 (expr -> expr > expr .)
    >               reduce using rule 37 (expr -> expr > expr .)
    LEQ             reduce using rule 37 (expr -> expr > expr .)
    <               reduce using rule 37 (expr -> expr > expr .)
    {               reduce using rule 37 (expr -> expr > expr .)
    FOR             reduce using rule 37 (expr -> expr > expr .)
    WHILE           reduce using rule 37 (expr -> expr > expr .)
    IF              reduce using rule 37 (expr -> expr > expr .)
    PRINT           reduce using rule 37 (expr -> expr > expr .)
    RETURN          reduce using rule 37 (expr -> expr > expr .)
    ID              reduce using rule 37 (expr -> expr > expr .)
    EYE             reduce using rule 37 (expr -> expr > expr .)
    ONES            reduce using rule 37 (expr -> expr > expr .)
    ZEROS           reduce using rule 37 (expr -> expr > expr .)
    [               reduce using rule 37 (expr -> expr > expr .)
    STRING          reduce using rule 37 (expr -> expr > expr .)
    FLOAT           reduce using rule 37 (expr -> expr > expr .)
    INT             reduce using rule 37 (expr -> expr > expr .)
    (               reduce using rule 37 (expr -> expr > expr .)
    )               reduce using rule 37 (expr -> expr > expr .)
    '               shift and go to state 30
    MDIVIDE         shift and go to state 37
    MTIMES          shift and go to state 38
    MMINUS          shift and go to state 39
    MPLUS           shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44


state 68

    (38) expr -> expr LEQ expr .
    (32) expr -> expr . '
    (34) expr -> expr . NEQ expr
    (35) expr -> expr . EQ expr
    (36) expr -> expr . GEQ expr
    (37) expr -> expr . > expr
    (38) expr -> expr . LEQ expr
    (39) expr -> expr . < expr
    (41) expr -> expr . MDIVIDE expr
    (42) expr -> expr . MTIMES expr
    (43) expr -> expr . MMINUS expr
    (44) expr -> expr . MPLUS expr
    (45) expr -> expr . / expr
    (46) expr -> expr . * expr
    (47) expr -> expr . - expr
    (48) expr -> expr . + expr
    ;               reduce using rule 38 (expr -> expr LEQ expr .)
    NEQ             reduce using rule 38 (expr -> expr LEQ expr .)
    EQ              reduce using rule 38 (expr -> expr LEQ expr .)
    GEQ             reduce using rule 38 (expr -> expr LEQ expr .)
    >               reduce using rule 38 (expr -> expr LEQ expr .)
    LEQ             reduce using rule 38 (expr -> expr LEQ expr .)
    <               reduce using rule 38 (expr -> expr LEQ expr .)
    {               reduce using rule 38 (expr -> expr LEQ expr .)
    FOR             reduce using rule 38 (expr -> expr LEQ expr .)
    WHILE           reduce using rule 38 (expr -> expr LEQ expr .)
    IF              reduce using rule 38 (expr -> expr LEQ expr .)
    PRINT           reduce using rule 38 (expr -> expr LEQ expr .)
    RETURN          reduce using rule 38 (expr -> expr LEQ expr .)
    ID              reduce using rule 38 (expr -> expr LEQ expr .)
    EYE             reduce using rule 38 (expr -> expr LEQ expr .)
    ONES            reduce using rule 38 (expr -> expr LEQ expr .)
    ZEROS           reduce using rule 38 (expr -> expr LEQ expr .)
    [               reduce using rule 38 (expr -> expr LEQ expr .)
    STRING          reduce using rule 38 (expr -> expr LEQ expr .)
    FLOAT           reduce using rule 38 (expr -> expr LEQ expr .)
    INT             reduce using rule 38 (expr -> expr LEQ expr .)
    (               reduce using rule 38 (expr -> expr LEQ expr .)
    )               reduce using rule 38 (expr -> expr LEQ expr .)
    '               shift and go to state 30
    MDIVIDE         shift and go to state 37
    MTIMES          shift and go to state 38
    MMINUS          shift and go to state 39
    MPLUS           shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44


state 69

    (39) expr -> expr < expr .
    (32) expr -> expr . '
    (34) expr -> expr . NEQ expr
    (35) expr -> expr . EQ expr
    (36) expr -> expr . GEQ expr
    (37) expr -> expr . > expr
    (38) expr -> expr . LEQ expr
    (39) expr -> expr . < expr
    (41) expr -> expr . MDIVIDE expr
    (42) expr -> expr . MTIMES expr
    (43) expr -> expr . MMINUS expr
    (44) expr -> expr . MPLUS expr
    (45) expr -> expr . / expr
    (46) expr -> expr . * expr
    (47) expr -> expr . - expr
    (48) expr -> expr . + expr
    ;               reduce using rule 39 (expr -> expr < expr .)
    NEQ             reduce using rule 39 (expr -> expr < expr .)
    EQ              reduce using rule 39 (expr -> expr < expr .)
    GEQ             reduce using rule 39 (expr -> expr < expr .)
    >               reduce using rule 39 (expr -> expr < expr .)
    LEQ             reduce using rule 39 (expr -> expr < expr .)
    <               reduce using rule 39 (expr -> expr < expr .)
    {               reduce using rule 39 (expr -> expr < expr .)
    FOR             reduce using rule 39 (expr -> expr < expr .)
    WHILE           reduce using rule 39 (expr -> expr < expr .)
    IF              reduce using rule 39 (expr -> expr < expr .)
    PRINT           reduce using rule 39 (expr -> expr < expr .)
    RETURN          reduce using rule 39 (expr -> expr < expr .)
    ID              reduce using rule 39 (expr -> expr < expr .)
    EYE             reduce using rule 39 (expr -> expr < expr .)
    ONES            reduce using rule 39 (expr -> expr < expr .)
    ZEROS           reduce using rule 39 (expr -> expr < expr .)
    [               reduce using rule 39 (expr -> expr < expr .)
    STRING          reduce using rule 39 (expr -> expr < expr .)
    FLOAT           reduce using rule 39 (expr -> expr < expr .)
    INT             reduce using rule 39 (expr -> expr < expr .)
    (               reduce using rule 39 (expr -> expr < expr .)
    )               reduce using rule 39 (expr -> expr < expr .)
    '               shift and go to state 30
    MDIVIDE         shift and go to state 37
    MTIMES          shift and go to state 38
    MMINUS          shift and go to state 39
    MPLUS           shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44


state 70

    (41) expr -> expr MDIVIDE expr .
    (32) expr -> expr . '
    (34) expr -> expr . NEQ expr
    (35) expr -> expr . EQ expr
    (36) expr -> expr . GEQ expr
    (37) expr -> expr . > expr
    (38) expr -> expr . LEQ expr
    (39) expr -> expr . < expr
    (41) expr -> expr . MDIVIDE expr
    (42) expr -> expr . MTIMES expr
    (43) expr -> expr . MMINUS expr
    (44) expr -> expr . MPLUS expr
    (45) expr -> expr . / expr
    (46) expr -> expr . * expr
    (47) expr -> expr . - expr
    (48) expr -> expr . + expr
    ;               reduce using rule 41 (expr -> expr MDIVIDE expr .)
    NEQ             reduce using rule 41 (expr -> expr MDIVIDE expr .)
    EQ              reduce using rule 41 (expr -> expr MDIVIDE expr .)
    GEQ             reduce using rule 41 (expr -> expr MDIVIDE expr .)
    >               reduce using rule 41 (expr -> expr MDIVIDE expr .)
    LEQ             reduce using rule 41 (expr -> expr MDIVIDE expr .)
    <               reduce using rule 41 (expr -> expr MDIVIDE expr .)
    MDIVIDE         reduce using rule 41 (expr -> expr MDIVIDE expr .)
    MTIMES          reduce using rule 41 (expr -> expr MDIVIDE expr .)
    MMINUS          reduce using rule 41 (expr -> expr MDIVIDE expr .)
    MPLUS           reduce using rule 41 (expr -> expr MDIVIDE expr .)
    /               reduce using rule 41 (expr -> expr MDIVIDE expr .)
    *               reduce using rule 41 (expr -> expr MDIVIDE expr .)
    -               reduce using rule 41 (expr -> expr MDIVIDE expr .)
    +               reduce using rule 41 (expr -> expr MDIVIDE expr .)
    {               reduce using rule 41 (expr -> expr MDIVIDE expr .)
    FOR             reduce using rule 41 (expr -> expr MDIVIDE expr .)
    WHILE           reduce using rule 41 (expr -> expr MDIVIDE expr .)
    IF              reduce using rule 41 (expr -> expr MDIVIDE expr .)
    PRINT           reduce using rule 41 (expr -> expr MDIVIDE expr .)
    RETURN          reduce using rule 41 (expr -> expr MDIVIDE expr .)
    ID              reduce using rule 41 (expr -> expr MDIVIDE expr .)
    EYE             reduce using rule 41 (expr -> expr MDIVIDE expr .)
    ONES            reduce using rule 41 (expr -> expr MDIVIDE expr .)
    ZEROS           reduce using rule 41 (expr -> expr MDIVIDE expr .)
    [               reduce using rule 41 (expr -> expr MDIVIDE expr .)
    STRING          reduce using rule 41 (expr -> expr MDIVIDE expr .)
    FLOAT           reduce using rule 41 (expr -> expr MDIVIDE expr .)
    INT             reduce using rule 41 (expr -> expr MDIVIDE expr .)
    (               reduce using rule 41 (expr -> expr MDIVIDE expr .)
    )               reduce using rule 41 (expr -> expr MDIVIDE expr .)
    '               shift and go to state 30


state 71

    (42) expr -> expr MTIMES expr .
    (32) expr -> expr . '
    (34) expr -> expr . NEQ expr
    (35) expr -> expr . EQ expr
    (36) expr -> expr . GEQ expr
    (37) expr -> expr . > expr
    (38) expr -> expr . LEQ expr
    (39) expr -> expr . < expr
    (41) expr -> expr . MDIVIDE expr
    (42) expr -> expr . MTIMES expr
    (43) expr -> expr . MMINUS expr
    (44) expr -> expr . MPLUS expr
    (45) expr -> expr . / expr
    (46) expr -> expr . * expr
    (47) expr -> expr . - expr
    (48) expr -> expr . + expr
    ;               reduce using rule 42 (expr -> expr MTIMES expr .)
    NEQ             reduce using rule 42 (expr -> expr MTIMES expr .)
    EQ              reduce using rule 42 (expr -> expr MTIMES expr .)
    GEQ             reduce using rule 42 (expr -> expr MTIMES expr .)
    >               reduce using rule 42 (expr -> expr MTIMES expr .)
    LEQ             reduce using rule 42 (expr -> expr MTIMES expr .)
    <               reduce using rule 42 (expr -> expr MTIMES expr .)
    MDIVIDE         reduce using rule 42 (expr -> expr MTIMES expr .)
    MTIMES          reduce using rule 42 (expr -> expr MTIMES expr .)
    MMINUS          reduce using rule 42 (expr -> expr MTIMES expr .)
    MPLUS           reduce using rule 42 (expr -> expr MTIMES expr .)
    /               reduce using rule 42 (expr -> expr MTIMES expr .)
    *               reduce using rule 42 (expr -> expr MTIMES expr .)
    -               reduce using rule 42 (expr -> expr MTIMES expr .)
    +               reduce using rule 42 (expr -> expr MTIMES expr .)
    {               reduce using rule 42 (expr -> expr MTIMES expr .)
    FOR             reduce using rule 42 (expr -> expr MTIMES expr .)
    WHILE           reduce using rule 42 (expr -> expr MTIMES expr .)
    IF              reduce using rule 42 (expr -> expr MTIMES expr .)
    PRINT           reduce using rule 42 (expr -> expr MTIMES expr .)
    RETURN          reduce using rule 42 (expr -> expr MTIMES expr .)
    ID              reduce using rule 42 (expr -> expr MTIMES expr .)
    EYE             reduce using rule 42 (expr -> expr MTIMES expr .)
    ONES            reduce using rule 42 (expr -> expr MTIMES expr .)
    ZEROS           reduce using rule 42 (expr -> expr MTIMES expr .)
    [               reduce using rule 42 (expr -> expr MTIMES expr .)
    STRING          reduce using rule 42 (expr -> expr MTIMES expr .)
    FLOAT           reduce using rule 42 (expr -> expr MTIMES expr .)
    INT             reduce using rule 42 (expr -> expr MTIMES expr .)
    (               reduce using rule 42 (expr -> expr MTIMES expr .)
    )               reduce using rule 42 (expr -> expr MTIMES expr .)
    '               shift and go to state 30


state 72

    (43) expr -> expr MMINUS expr .
    (32) expr -> expr . '
    (34) expr -> expr . NEQ expr
    (35) expr -> expr . EQ expr
    (36) expr -> expr . GEQ expr
    (37) expr -> expr . > expr
    (38) expr -> expr . LEQ expr
    (39) expr -> expr . < expr
    (41) expr -> expr . MDIVIDE expr
    (42) expr -> expr . MTIMES expr
    (43) expr -> expr . MMINUS expr
    (44) expr -> expr . MPLUS expr
    (45) expr -> expr . / expr
    (46) expr -> expr . * expr
    (47) expr -> expr . - expr
    (48) expr -> expr . + expr
    ;               reduce using rule 43 (expr -> expr MMINUS expr .)
    NEQ             reduce using rule 43 (expr -> expr MMINUS expr .)
    EQ              reduce using rule 43 (expr -> expr MMINUS expr .)
    GEQ             reduce using rule 43 (expr -> expr MMINUS expr .)
    >               reduce using rule 43 (expr -> expr MMINUS expr .)
    LEQ             reduce using rule 43 (expr -> expr MMINUS expr .)
    <               reduce using rule 43 (expr -> expr MMINUS expr .)
    MMINUS          reduce using rule 43 (expr -> expr MMINUS expr .)
    MPLUS           reduce using rule 43 (expr -> expr MMINUS expr .)
    -               reduce using rule 43 (expr -> expr MMINUS expr .)
    +               reduce using rule 43 (expr -> expr MMINUS expr .)
    {               reduce using rule 43 (expr -> expr MMINUS expr .)
    FOR             reduce using rule 43 (expr -> expr MMINUS expr .)
    WHILE           reduce using rule 43 (expr -> expr MMINUS expr .)
    IF              reduce using rule 43 (expr -> expr MMINUS expr .)
    PRINT           reduce using rule 43 (expr -> expr MMINUS expr .)
    RETURN          reduce using rule 43 (expr -> expr MMINUS expr .)
    ID              reduce using rule 43 (expr -> expr MMINUS expr .)
    EYE             reduce using rule 43 (expr -> expr MMINUS expr .)
    ONES            reduce using rule 43 (expr -> expr MMINUS expr .)
    ZEROS           reduce using rule 43 (expr -> expr MMINUS expr .)
    [               reduce using rule 43 (expr -> expr MMINUS expr .)
    STRING          reduce using rule 43 (expr -> expr MMINUS expr .)
    FLOAT           reduce using rule 43 (expr -> expr MMINUS expr .)
    INT             reduce using rule 43 (expr -> expr MMINUS expr .)
    (               reduce using rule 43 (expr -> expr MMINUS expr .)
    )               reduce using rule 43 (expr -> expr MMINUS expr .)
    '               shift and go to state 30
    MDIVIDE         shift and go to state 37
    MTIMES          shift and go to state 38
    /               shift and go to state 41
    *               shift and go to state 42


state 73

    (44) expr -> expr MPLUS expr .
    (32) expr -> expr . '
    (34) expr -> expr . NEQ expr
    (35) expr -> expr . EQ expr
    (36) expr -> expr . GEQ expr
    (37) expr -> expr . > expr
    (38) expr -> expr . LEQ expr
    (39) expr -> expr . < expr
    (41) expr -> expr . MDIVIDE expr
    (42) expr -> expr . MTIMES expr
    (43) expr -> expr . MMINUS expr
    (44) expr -> expr . MPLUS expr
    (45) expr -> expr . / expr
    (46) expr -> expr . * expr
    (47) expr -> expr . - expr
    (48) expr -> expr . + expr
    ;               reduce using rule 44 (expr -> expr MPLUS expr .)
    NEQ             reduce using rule 44 (expr -> expr MPLUS expr .)
    EQ              reduce using rule 44 (expr -> expr MPLUS expr .)
    GEQ             reduce using rule 44 (expr -> expr MPLUS expr .)
    >               reduce using rule 44 (expr -> expr MPLUS expr .)
    LEQ             reduce using rule 44 (expr -> expr MPLUS expr .)
    <               reduce using rule 44 (expr -> expr MPLUS expr .)
    MMINUS          reduce using rule 44 (expr -> expr MPLUS expr .)
    MPLUS           reduce using rule 44 (expr -> expr MPLUS expr .)
    -               reduce using rule 44 (expr -> expr MPLUS expr .)
    +               reduce using rule 44 (expr -> expr MPLUS expr .)
    {               reduce using rule 44 (expr -> expr MPLUS expr .)
    FOR             reduce using rule 44 (expr -> expr MPLUS expr .)
    WHILE           reduce using rule 44 (expr -> expr MPLUS expr .)
    IF              reduce using rule 44 (expr -> expr MPLUS expr .)
    PRINT           reduce using rule 44 (expr -> expr MPLUS expr .)
    RETURN          reduce using rule 44 (expr -> expr MPLUS expr .)
    ID              reduce using rule 44 (expr -> expr MPLUS expr .)
    EYE             reduce using rule 44 (expr -> expr MPLUS expr .)
    ONES            reduce using rule 44 (expr -> expr MPLUS expr .)
    ZEROS           reduce using rule 44 (expr -> expr MPLUS expr .)
    [               reduce using rule 44 (expr -> expr MPLUS expr .)
    STRING          reduce using rule 44 (expr -> expr MPLUS expr .)
    FLOAT           reduce using rule 44 (expr -> expr MPLUS expr .)
    INT             reduce using rule 44 (expr -> expr MPLUS expr .)
    (               reduce using rule 44 (expr -> expr MPLUS expr .)
    )               reduce using rule 44 (expr -> expr MPLUS expr .)
    '               shift and go to state 30
    MDIVIDE         shift and go to state 37
    MTIMES          shift and go to state 38
    /               shift and go to state 41
    *               shift and go to state 42


state 74

    (45) expr -> expr / expr .
    (32) expr -> expr . '
    (34) expr -> expr . NEQ expr
    (35) expr -> expr . EQ expr
    (36) expr -> expr . GEQ expr
    (37) expr -> expr . > expr
    (38) expr -> expr . LEQ expr
    (39) expr -> expr . < expr
    (41) expr -> expr . MDIVIDE expr
    (42) expr -> expr . MTIMES expr
    (43) expr -> expr . MMINUS expr
    (44) expr -> expr . MPLUS expr
    (45) expr -> expr . / expr
    (46) expr -> expr . * expr
    (47) expr -> expr . - expr
    (48) expr -> expr . + expr
    ;               reduce using rule 45 (expr -> expr / expr .)
    NEQ             reduce using rule 45 (expr -> expr / expr .)
    EQ              reduce using rule 45 (expr -> expr / expr .)
    GEQ             reduce using rule 45 (expr -> expr / expr .)
    >               reduce using rule 45 (expr -> expr / expr .)
    LEQ             reduce using rule 45 (expr -> expr / expr .)
    <               reduce using rule 45 (expr -> expr / expr .)
    MDIVIDE         reduce using rule 45 (expr -> expr / expr .)
    MTIMES          reduce using rule 45 (expr -> expr / expr .)
    MMINUS          reduce using rule 45 (expr -> expr / expr .)
    MPLUS           reduce using rule 45 (expr -> expr / expr .)
    /               reduce using rule 45 (expr -> expr / expr .)
    *               reduce using rule 45 (expr -> expr / expr .)
    -               reduce using rule 45 (expr -> expr / expr .)
    +               reduce using rule 45 (expr -> expr / expr .)
    {               reduce using rule 45 (expr -> expr / expr .)
    FOR             reduce using rule 45 (expr -> expr / expr .)
    WHILE           reduce using rule 45 (expr -> expr / expr .)
    IF              reduce using rule 45 (expr -> expr / expr .)
    PRINT           reduce using rule 45 (expr -> expr / expr .)
    RETURN          reduce using rule 45 (expr -> expr / expr .)
    ID              reduce using rule 45 (expr -> expr / expr .)
    EYE             reduce using rule 45 (expr -> expr / expr .)
    ONES            reduce using rule 45 (expr -> expr / expr .)
    ZEROS           reduce using rule 45 (expr -> expr / expr .)
    [               reduce using rule 45 (expr -> expr / expr .)
    STRING          reduce using rule 45 (expr -> expr / expr .)
    FLOAT           reduce using rule 45 (expr -> expr / expr .)
    INT             reduce using rule 45 (expr -> expr / expr .)
    (               reduce using rule 45 (expr -> expr / expr .)
    )               reduce using rule 45 (expr -> expr / expr .)
    '               shift and go to state 30


state 75

    (46) expr -> expr * expr .
    (32) expr -> expr . '
    (34) expr -> expr . NEQ expr
    (35) expr -> expr . EQ expr
    (36) expr -> expr . GEQ expr
    (37) expr -> expr . > expr
    (38) expr -> expr . LEQ expr
    (39) expr -> expr . < expr
    (41) expr -> expr . MDIVIDE expr
    (42) expr -> expr . MTIMES expr
    (43) expr -> expr . MMINUS expr
    (44) expr -> expr . MPLUS expr
    (45) expr -> expr . / expr
    (46) expr -> expr . * expr
    (47) expr -> expr . - expr
    (48) expr -> expr . + expr
    ;               reduce using rule 46 (expr -> expr * expr .)
    NEQ             reduce using rule 46 (expr -> expr * expr .)
    EQ              reduce using rule 46 (expr -> expr * expr .)
    GEQ             reduce using rule 46 (expr -> expr * expr .)
    >               reduce using rule 46 (expr -> expr * expr .)
    LEQ             reduce using rule 46 (expr -> expr * expr .)
    <               reduce using rule 46 (expr -> expr * expr .)
    MDIVIDE         reduce using rule 46 (expr -> expr * expr .)
    MTIMES          reduce using rule 46 (expr -> expr * expr .)
    MMINUS          reduce using rule 46 (expr -> expr * expr .)
    MPLUS           reduce using rule 46 (expr -> expr * expr .)
    /               reduce using rule 46 (expr -> expr * expr .)
    *               reduce using rule 46 (expr -> expr * expr .)
    -               reduce using rule 46 (expr -> expr * expr .)
    +               reduce using rule 46 (expr -> expr * expr .)
    {               reduce using rule 46 (expr -> expr * expr .)
    FOR             reduce using rule 46 (expr -> expr * expr .)
    WHILE           reduce using rule 46 (expr -> expr * expr .)
    IF              reduce using rule 46 (expr -> expr * expr .)
    PRINT           reduce using rule 46 (expr -> expr * expr .)
    RETURN          reduce using rule 46 (expr -> expr * expr .)
    ID              reduce using rule 46 (expr -> expr * expr .)
    EYE             reduce using rule 46 (expr -> expr * expr .)
    ONES            reduce using rule 46 (expr -> expr * expr .)
    ZEROS           reduce using rule 46 (expr -> expr * expr .)
    [               reduce using rule 46 (expr -> expr * expr .)
    STRING          reduce using rule 46 (expr -> expr * expr .)
    FLOAT           reduce using rule 46 (expr -> expr * expr .)
    INT             reduce using rule 46 (expr -> expr * expr .)
    (               reduce using rule 46 (expr -> expr * expr .)
    )               reduce using rule 46 (expr -> expr * expr .)
    '               shift and go to state 30


state 76

    (47) expr -> expr - expr .
    (32) expr -> expr . '
    (34) expr -> expr . NEQ expr
    (35) expr -> expr . EQ expr
    (36) expr -> expr . GEQ expr
    (37) expr -> expr . > expr
    (38) expr -> expr . LEQ expr
    (39) expr -> expr . < expr
    (41) expr -> expr . MDIVIDE expr
    (42) expr -> expr . MTIMES expr
    (43) expr -> expr . MMINUS expr
    (44) expr -> expr . MPLUS expr
    (45) expr -> expr . / expr
    (46) expr -> expr . * expr
    (47) expr -> expr . - expr
    (48) expr -> expr . + expr
    ;               reduce using rule 47 (expr -> expr - expr .)
    NEQ             reduce using rule 47 (expr -> expr - expr .)
    EQ              reduce using rule 47 (expr -> expr - expr .)
    GEQ             reduce using rule 47 (expr -> expr - expr .)
    >               reduce using rule 47 (expr -> expr - expr .)
    LEQ             reduce using rule 47 (expr -> expr - expr .)
    <               reduce using rule 47 (expr -> expr - expr .)
    MMINUS          reduce using rule 47 (expr -> expr - expr .)
    MPLUS           reduce using rule 47 (expr -> expr - expr .)
    -               reduce using rule 47 (expr -> expr - expr .)
    +               reduce using rule 47 (expr -> expr - expr .)
    {               reduce using rule 47 (expr -> expr - expr .)
    FOR             reduce using rule 47 (expr -> expr - expr .)
    WHILE           reduce using rule 47 (expr -> expr - expr .)
    IF              reduce using rule 47 (expr -> expr - expr .)
    PRINT           reduce using rule 47 (expr -> expr - expr .)
    RETURN          reduce using rule 47 (expr -> expr - expr .)
    ID              reduce using rule 47 (expr -> expr - expr .)
    EYE             reduce using rule 47 (expr -> expr - expr .)
    ONES            reduce using rule 47 (expr -> expr - expr .)
    ZEROS           reduce using rule 47 (expr -> expr - expr .)
    [               reduce using rule 47 (expr -> expr - expr .)
    STRING          reduce using rule 47 (expr -> expr - expr .)
    FLOAT           reduce using rule 47 (expr -> expr - expr .)
    INT             reduce using rule 47 (expr -> expr - expr .)
    (               reduce using rule 47 (expr -> expr - expr .)
    )               reduce using rule 47 (expr -> expr - expr .)
    '               shift and go to state 30
    MDIVIDE         shift and go to state 37
    MTIMES          shift and go to state 38
    /               shift and go to state 41
    *               shift and go to state 42


state 77

    (48) expr -> expr + expr .
    (32) expr -> expr . '
    (34) expr -> expr . NEQ expr
    (35) expr -> expr . EQ expr
    (36) expr -> expr . GEQ expr
    (37) expr -> expr . > expr
    (38) expr -> expr . LEQ expr
    (39) expr -> expr . < expr
    (41) expr -> expr . MDIVIDE expr
    (42) expr -> expr . MTIMES expr
    (43) expr -> expr . MMINUS expr
    (44) expr -> expr . MPLUS expr
    (45) expr -> expr . / expr
    (46) expr -> expr . * expr
    (47) expr -> expr . - expr
    (48) expr -> expr . + expr
    ;               reduce using rule 48 (expr -> expr + expr .)
    NEQ             reduce using rule 48 (expr -> expr + expr .)
    EQ              reduce using rule 48 (expr -> expr + expr .)
    GEQ             reduce using rule 48 (expr -> expr + expr .)
    >               reduce using rule 48 (expr -> expr + expr .)
    LEQ             reduce using rule 48 (expr -> expr + expr .)
    <               reduce using rule 48 (expr -> expr + expr .)
    MMINUS          reduce using rule 48 (expr -> expr + expr .)
    MPLUS           reduce using rule 48 (expr -> expr + expr .)
    -               reduce using rule 48 (expr -> expr + expr .)
    +               reduce using rule 48 (expr -> expr + expr .)
    {               reduce using rule 48 (expr -> expr + expr .)
    FOR             reduce using rule 48 (expr -> expr + expr .)
    WHILE           reduce using rule 48 (expr -> expr + expr .)
    IF              reduce using rule 48 (expr -> expr + expr .)
    PRINT           reduce using rule 48 (expr -> expr + expr .)
    RETURN          reduce using rule 48 (expr -> expr + expr .)
    ID              reduce using rule 48 (expr -> expr + expr .)
    EYE             reduce using rule 48 (expr -> expr + expr .)
    ONES            reduce using rule 48 (expr -> expr + expr .)
    ZEROS           reduce using rule 48 (expr -> expr + expr .)
    [               reduce using rule 48 (expr -> expr + expr .)
    STRING          reduce using rule 48 (expr -> expr + expr .)
    FLOAT           reduce using rule 48 (expr -> expr + expr .)
    INT             reduce using rule 48 (expr -> expr + expr .)
    (               reduce using rule 48 (expr -> expr + expr .)
    )               reduce using rule 48 (expr -> expr + expr .)
    '               shift and go to state 30
    MDIVIDE         shift and go to state 37
    MTIMES          shift and go to state 38
    /               shift and go to state 41
    *               shift and go to state 42


state 78

    (6) statement -> IF expr ifblock . ELSE ifblock
    (7) statement -> IF expr ifblock .
    ELSE            shift and go to state 106
    FOR             reduce using rule 7 (statement -> IF expr ifblock .)
    WHILE           reduce using rule 7 (statement -> IF expr ifblock .)
    IF              reduce using rule 7 (statement -> IF expr ifblock .)
    PRINT           reduce using rule 7 (statement -> IF expr ifblock .)
    RETURN          reduce using rule 7 (statement -> IF expr ifblock .)
    ID              reduce using rule 7 (statement -> IF expr ifblock .)
    EYE             reduce using rule 7 (statement -> IF expr ifblock .)
    ONES            reduce using rule 7 (statement -> IF expr ifblock .)
    ZEROS           reduce using rule 7 (statement -> IF expr ifblock .)
    [               reduce using rule 7 (statement -> IF expr ifblock .)
    STRING          reduce using rule 7 (statement -> IF expr ifblock .)
    FLOAT           reduce using rule 7 (statement -> IF expr ifblock .)
    INT             reduce using rule 7 (statement -> IF expr ifblock .)
    (               reduce using rule 7 (statement -> IF expr ifblock .)
    '               reduce using rule 7 (statement -> IF expr ifblock .)
    $end            reduce using rule 7 (statement -> IF expr ifblock .)
    }               reduce using rule 7 (statement -> IF expr ifblock .)
    BREAK           reduce using rule 7 (statement -> IF expr ifblock .)
    CONTINUE        reduce using rule 7 (statement -> IF expr ifblock .)


state 79

    (16) ifblock -> { . start }
    (2) start -> . empty
    (3) start -> . statement start
    (1) empty -> .
    (4) statement -> . FOR ID = range loopblock
    (5) statement -> . WHILE expr loopblock
    (6) statement -> . IF expr ifblock ELSE ifblock
    (7) statement -> . IF expr ifblock
    (8) statement -> . PRINT expr ;
    (9) statement -> . expr ;
    (10) statement -> . RETURN
    (11) statement -> . ID DASSIGN expr ;
    (12) statement -> . ID TASSIGN expr ;
    (13) statement -> . ID MASSIGN expr ;
    (14) statement -> . ID PASSIGN expr ;
    (15) statement -> . ID = expr ;
    (24) expr -> . EYE ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ID
    (28) expr -> . [ outerlist ]
    (29) expr -> . STRING
    (30) expr -> . FLOAT
    (31) expr -> . INT
    (32) expr -> . expr '
    (33) expr -> . ( expr )
    (34) expr -> . expr NEQ expr
    (35) expr -> . expr EQ expr
    (36) expr -> . expr GEQ expr
    (37) expr -> . expr > expr
    (38) expr -> . expr LEQ expr
    (39) expr -> . expr < expr
    (40) expr -> . ' expr
    (41) expr -> . expr MDIVIDE expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MMINUS expr
    (44) expr -> . expr MPLUS expr
    (45) expr -> . expr / expr
    (46) expr -> . expr * expr
    (47) expr -> . expr - expr
    (48) expr -> . expr + expr
    }               reduce using rule 1 (empty -> .)
    FOR             shift and go to state 4
    WHILE           shift and go to state 6
    IF              shift and go to state 8
    PRINT           shift and go to state 9
    RETURN          shift and go to state 10
    ID              shift and go to state 5
    EYE             shift and go to state 11
    ONES            shift and go to state 13
    ZEROS           shift and go to state 14
    [               shift and go to state 15
    STRING          shift and go to state 16
    FLOAT           shift and go to state 17
    INT             shift and go to state 18
    (               shift and go to state 12
    '               shift and go to state 19

    start                          shift and go to state 107
    empty                          shift and go to state 2
    statement                      shift and go to state 3
    expr                           shift and go to state 7

state 80

    (17) ifblock -> statement .
    FOR             reduce using rule 17 (ifblock -> statement .)
    WHILE           reduce using rule 17 (ifblock -> statement .)
    IF              reduce using rule 17 (ifblock -> statement .)
    PRINT           reduce using rule 17 (ifblock -> statement .)
    RETURN          reduce using rule 17 (ifblock -> statement .)
    ID              reduce using rule 17 (ifblock -> statement .)
    EYE             reduce using rule 17 (ifblock -> statement .)
    ONES            reduce using rule 17 (ifblock -> statement .)
    ZEROS           reduce using rule 17 (ifblock -> statement .)
    [               reduce using rule 17 (ifblock -> statement .)
    STRING          reduce using rule 17 (ifblock -> statement .)
    FLOAT           reduce using rule 17 (ifblock -> statement .)
    INT             reduce using rule 17 (ifblock -> statement .)
    (               reduce using rule 17 (ifblock -> statement .)
    '               reduce using rule 17 (ifblock -> statement .)
    $end            reduce using rule 17 (ifblock -> statement .)
    }               reduce using rule 17 (ifblock -> statement .)
    ELSE            reduce using rule 17 (ifblock -> statement .)
    BREAK           reduce using rule 17 (ifblock -> statement .)
    CONTINUE        reduce using rule 17 (ifblock -> statement .)


state 81

    (8) statement -> PRINT expr ; .
    FOR             reduce using rule 8 (statement -> PRINT expr ; .)
    WHILE           reduce using rule 8 (statement -> PRINT expr ; .)
    IF              reduce using rule 8 (statement -> PRINT expr ; .)
    PRINT           reduce using rule 8 (statement -> PRINT expr ; .)
    RETURN          reduce using rule 8 (statement -> PRINT expr ; .)
    ID              reduce using rule 8 (statement -> PRINT expr ; .)
    EYE             reduce using rule 8 (statement -> PRINT expr ; .)
    ONES            reduce using rule 8 (statement -> PRINT expr ; .)
    ZEROS           reduce using rule 8 (statement -> PRINT expr ; .)
    [               reduce using rule 8 (statement -> PRINT expr ; .)
    STRING          reduce using rule 8 (statement -> PRINT expr ; .)
    FLOAT           reduce using rule 8 (statement -> PRINT expr ; .)
    INT             reduce using rule 8 (statement -> PRINT expr ; .)
    (               reduce using rule 8 (statement -> PRINT expr ; .)
    '               reduce using rule 8 (statement -> PRINT expr ; .)
    $end            reduce using rule 8 (statement -> PRINT expr ; .)
    }               reduce using rule 8 (statement -> PRINT expr ; .)
    ELSE            reduce using rule 8 (statement -> PRINT expr ; .)
    BREAK           reduce using rule 8 (statement -> PRINT expr ; .)
    CONTINUE        reduce using rule 8 (statement -> PRINT expr ; .)


state 82

    (24) expr -> EYE ( expr . )
    (32) expr -> expr . '
    (34) expr -> expr . NEQ expr
    (35) expr -> expr . EQ expr
    (36) expr -> expr . GEQ expr
    (37) expr -> expr . > expr
    (38) expr -> expr . LEQ expr
    (39) expr -> expr . < expr
    (41) expr -> expr . MDIVIDE expr
    (42) expr -> expr . MTIMES expr
    (43) expr -> expr . MMINUS expr
    (44) expr -> expr . MPLUS expr
    (45) expr -> expr . / expr
    (46) expr -> expr . * expr
    (47) expr -> expr . - expr
    (48) expr -> expr . + expr
    )               shift and go to state 108
    '               shift and go to state 30
    NEQ             shift and go to state 31
    EQ              shift and go to state 32
    GEQ             shift and go to state 33
    >               shift and go to state 34
    LEQ             shift and go to state 35
    <               shift and go to state 36
    MDIVIDE         shift and go to state 37
    MTIMES          shift and go to state 38
    MMINUS          shift and go to state 39
    MPLUS           shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44


state 83

    (33) expr -> ( expr ) .
    ;               reduce using rule 33 (expr -> ( expr ) .)
    '               reduce using rule 33 (expr -> ( expr ) .)
    NEQ             reduce using rule 33 (expr -> ( expr ) .)
    EQ              reduce using rule 33 (expr -> ( expr ) .)
    GEQ             reduce using rule 33 (expr -> ( expr ) .)
    >               reduce using rule 33 (expr -> ( expr ) .)
    LEQ             reduce using rule 33 (expr -> ( expr ) .)
    <               reduce using rule 33 (expr -> ( expr ) .)
    MDIVIDE         reduce using rule 33 (expr -> ( expr ) .)
    MTIMES          reduce using rule 33 (expr -> ( expr ) .)
    MMINUS          reduce using rule 33 (expr -> ( expr ) .)
    MPLUS           reduce using rule 33 (expr -> ( expr ) .)
    /               reduce using rule 33 (expr -> ( expr ) .)
    *               reduce using rule 33 (expr -> ( expr ) .)
    -               reduce using rule 33 (expr -> ( expr ) .)
    +               reduce using rule 33 (expr -> ( expr ) .)
    {               reduce using rule 33 (expr -> ( expr ) .)
    FOR             reduce using rule 33 (expr -> ( expr ) .)
    WHILE           reduce using rule 33 (expr -> ( expr ) .)
    IF              reduce using rule 33 (expr -> ( expr ) .)
    PRINT           reduce using rule 33 (expr -> ( expr ) .)
    RETURN          reduce using rule 33 (expr -> ( expr ) .)
    ID              reduce using rule 33 (expr -> ( expr ) .)
    EYE             reduce using rule 33 (expr -> ( expr ) .)
    ONES            reduce using rule 33 (expr -> ( expr ) .)
    ZEROS           reduce using rule 33 (expr -> ( expr ) .)
    [               reduce using rule 33 (expr -> ( expr ) .)
    STRING          reduce using rule 33 (expr -> ( expr ) .)
    FLOAT           reduce using rule 33 (expr -> ( expr ) .)
    INT             reduce using rule 33 (expr -> ( expr ) .)
    (               reduce using rule 33 (expr -> ( expr ) .)
    )               reduce using rule 33 (expr -> ( expr ) .)


state 84

    (25) expr -> ONES ( expr . )
    (32) expr -> expr . '
    (34) expr -> expr . NEQ expr
    (35) expr -> expr . EQ expr
    (36) expr -> expr . GEQ expr
    (37) expr -> expr . > expr
    (38) expr -> expr . LEQ expr
    (39) expr -> expr . < expr
    (41) expr -> expr . MDIVIDE expr
    (42) expr -> expr . MTIMES expr
    (43) expr -> expr . MMINUS expr
    (44) expr -> expr . MPLUS expr
    (45) expr -> expr . / expr
    (46) expr -> expr . * expr
    (47) expr -> expr . - expr
    (48) expr -> expr . + expr
    )               shift and go to state 109
    '               shift and go to state 30
    NEQ             shift and go to state 31
    EQ              shift and go to state 32
    GEQ             shift and go to state 33
    >               shift and go to state 34
    LEQ             shift and go to state 35
    <               shift and go to state 36
    MDIVIDE         shift and go to state 37
    MTIMES          shift and go to state 38
    MMINUS          shift and go to state 39
    MPLUS           shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44


state 85

    (26) expr -> ZEROS ( expr . )
    (32) expr -> expr . '
    (34) expr -> expr . NEQ expr
    (35) expr -> expr . EQ expr
    (36) expr -> expr . GEQ expr
    (37) expr -> expr . > expr
    (38) expr -> expr . LEQ expr
    (39) expr -> expr . < expr
    (41) expr -> expr . MDIVIDE expr
    (42) expr -> expr . MTIMES expr
    (43) expr -> expr . MMINUS expr
    (44) expr -> expr . MPLUS expr
    (45) expr -> expr . / expr
    (46) expr -> expr . * expr
    (47) expr -> expr . - expr
    (48) expr -> expr . + expr
    )               shift and go to state 110
    '               shift and go to state 30
    NEQ             shift and go to state 31
    EQ              shift and go to state 32
    GEQ             shift and go to state 33
    >               shift and go to state 34
    LEQ             shift and go to state 35
    <               shift and go to state 36
    MDIVIDE         shift and go to state 37
    MTIMES          shift and go to state 38
    MMINUS          shift and go to state 39
    MPLUS           shift and go to state 40
    /               shift and go to state 41
    *               shift and go to state 42
    -               shift and go to state 43
    +               shift and go to state 44


state 86

    (53) outerlist -> [ innerlist . ]
    (56) innerlist -> innerlist . , elem
    ]               shift and go to state 111
    ,               shift and go to state 112


state 87

    (55) innerlist -> elem .
    ]               reduce using rule 55 (innerlist -> elem .)
    ,               reduce using rule 55 (innerlist -> elem .)


state 88

    (57) elem -> STRING .
    ]               reduce using rule 57 (elem -> STRING .)
    ,               reduce using rule 57 (elem -> STRING .)


state 89

    (58) elem -> FLOAT .
    ]               reduce using rule 58 (elem -> FLOAT .)
    ,               reduce using rule 58 (elem -> FLOAT .)


state 90

    (59) elem -> INT .
    ]               reduce using rule 59 (elem -> INT .)
    ,               reduce using rule 59 (elem -> INT .)


state 91

    (28) expr -> [ outerlist ] .
    ;               reduce using rule 28 (expr -> [ outerlist ] .)
    '               reduce using rule 28 (expr -> [ outerlist ] .)
    NEQ             reduce using rule 28 (expr -> [ outerlist ] .)
    EQ              reduce using rule 28 (expr -> [ outerlist ] .)
    GEQ             reduce using rule 28 (expr -> [ outerlist ] .)
    >               reduce using rule 28 (expr -> [ outerlist ] .)
    LEQ             reduce using rule 28 (expr -> [ outerlist ] .)
    <               reduce using rule 28 (expr -> [ outerlist ] .)
    MDIVIDE         reduce using rule 28 (expr -> [ outerlist ] .)
    MTIMES          reduce using rule 28 (expr -> [ outerlist ] .)
    MMINUS          reduce using rule 28 (expr -> [ outerlist ] .)
    MPLUS           reduce using rule 28 (expr -> [ outerlist ] .)
    /               reduce using rule 28 (expr -> [ outerlist ] .)
    *               reduce using rule 28 (expr -> [ outerlist ] .)
    -               reduce using rule 28 (expr -> [ outerlist ] .)
    +               reduce using rule 28 (expr -> [ outerlist ] .)
    {               reduce using rule 28 (expr -> [ outerlist ] .)
    FOR             reduce using rule 28 (expr -> [ outerlist ] .)
    WHILE           reduce using rule 28 (expr -> [ outerlist ] .)
    IF              reduce using rule 28 (expr -> [ outerlist ] .)
    PRINT           reduce using rule 28 (expr -> [ outerlist ] .)
    RETURN          reduce using rule 28 (expr -> [ outerlist ] .)
    ID              reduce using rule 28 (expr -> [ outerlist ] .)
    EYE             reduce using rule 28 (expr -> [ outerlist ] .)
    ONES            reduce using rule 28 (expr -> [ outerlist ] .)
    ZEROS           reduce using rule 28 (expr -> [ outerlist ] .)
    [               reduce using rule 28 (expr -> [ outerlist ] .)
    STRING          reduce using rule 28 (expr -> [ outerlist ] .)
    FLOAT           reduce using rule 28 (expr -> [ outerlist ] .)
    INT             reduce using rule 28 (expr -> [ outerlist ] .)
    (               reduce using rule 28 (expr -> [ outerlist ] .)
    )               reduce using rule 28 (expr -> [ outerlist ] .)


state 92

    (54) outerlist -> outerlist , . [ innerlist ]
    [               shift and go to state 113


state 93

    (50) range -> ID . : INT
    (51) range -> ID . : ID
    :               shift and go to state 114


state 94

    (4) statement -> FOR ID = range . loopblock
    (18) loopblock -> . { loopstart }
    (19) loopblock -> . statement
    (4) statement -> . FOR ID = range loopblock
    (5) statement -> . WHILE expr loopblock
    (6) statement -> . IF expr ifblock ELSE ifblock
    (7) statement -> . IF expr ifblock
    (8) statement -> . PRINT expr ;
    (9) statement -> . expr ;
    (10) statement -> . RETURN
    (11) statement -> . ID DASSIGN expr ;
    (12) statement -> . ID TASSIGN expr ;
    (13) statement -> . ID MASSIGN expr ;
    (14) statement -> . ID PASSIGN expr ;
    (15) statement -> . ID = expr ;
    (24) expr -> . EYE ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ID
    (28) expr -> . [ outerlist ]
    (29) expr -> . STRING
    (30) expr -> . FLOAT
    (31) expr -> . INT
    (32) expr -> . expr '
    (33) expr -> . ( expr )
    (34) expr -> . expr NEQ expr
    (35) expr -> . expr EQ expr
    (36) expr -> . expr GEQ expr
    (37) expr -> . expr > expr
    (38) expr -> . expr LEQ expr
    (39) expr -> . expr < expr
    (40) expr -> . ' expr
    (41) expr -> . expr MDIVIDE expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MMINUS expr
    (44) expr -> . expr MPLUS expr
    (45) expr -> . expr / expr
    (46) expr -> . expr * expr
    (47) expr -> . expr - expr
    (48) expr -> . expr + expr
    {               shift and go to state 62
    FOR             shift and go to state 4
    WHILE           shift and go to state 6
    IF              shift and go to state 8
    PRINT           shift and go to state 9
    RETURN          shift and go to state 10
    ID              shift and go to state 5
    EYE             shift and go to state 11
    ONES            shift and go to state 13
    ZEROS           shift and go to state 14
    [               shift and go to state 15
    STRING          shift and go to state 16
    FLOAT           shift and go to state 17
    INT             shift and go to state 18
    (               shift and go to state 12
    '               shift and go to state 19

    loopblock                      shift and go to state 115
    statement                      shift and go to state 63
    expr                           shift and go to state 7

state 95

    (49) range -> INT . : ID
    (52) range -> INT . : INT
    :               shift and go to state 116


state 96

    (11) statement -> ID DASSIGN expr ; .
    FOR             reduce using rule 11 (statement -> ID DASSIGN expr ; .)
    WHILE           reduce using rule 11 (statement -> ID DASSIGN expr ; .)
    IF              reduce using rule 11 (statement -> ID DASSIGN expr ; .)
    PRINT           reduce using rule 11 (statement -> ID DASSIGN expr ; .)
    RETURN          reduce using rule 11 (statement -> ID DASSIGN expr ; .)
    ID              reduce using rule 11 (statement -> ID DASSIGN expr ; .)
    EYE             reduce using rule 11 (statement -> ID DASSIGN expr ; .)
    ONES            reduce using rule 11 (statement -> ID DASSIGN expr ; .)
    ZEROS           reduce using rule 11 (statement -> ID DASSIGN expr ; .)
    [               reduce using rule 11 (statement -> ID DASSIGN expr ; .)
    STRING          reduce using rule 11 (statement -> ID DASSIGN expr ; .)
    FLOAT           reduce using rule 11 (statement -> ID DASSIGN expr ; .)
    INT             reduce using rule 11 (statement -> ID DASSIGN expr ; .)
    (               reduce using rule 11 (statement -> ID DASSIGN expr ; .)
    '               reduce using rule 11 (statement -> ID DASSIGN expr ; .)
    $end            reduce using rule 11 (statement -> ID DASSIGN expr ; .)
    }               reduce using rule 11 (statement -> ID DASSIGN expr ; .)
    ELSE            reduce using rule 11 (statement -> ID DASSIGN expr ; .)
    BREAK           reduce using rule 11 (statement -> ID DASSIGN expr ; .)
    CONTINUE        reduce using rule 11 (statement -> ID DASSIGN expr ; .)


state 97

    (12) statement -> ID TASSIGN expr ; .
    FOR             reduce using rule 12 (statement -> ID TASSIGN expr ; .)
    WHILE           reduce using rule 12 (statement -> ID TASSIGN expr ; .)
    IF              reduce using rule 12 (statement -> ID TASSIGN expr ; .)
    PRINT           reduce using rule 12 (statement -> ID TASSIGN expr ; .)
    RETURN          reduce using rule 12 (statement -> ID TASSIGN expr ; .)
    ID              reduce using rule 12 (statement -> ID TASSIGN expr ; .)
    EYE             reduce using rule 12 (statement -> ID TASSIGN expr ; .)
    ONES            reduce using rule 12 (statement -> ID TASSIGN expr ; .)
    ZEROS           reduce using rule 12 (statement -> ID TASSIGN expr ; .)
    [               reduce using rule 12 (statement -> ID TASSIGN expr ; .)
    STRING          reduce using rule 12 (statement -> ID TASSIGN expr ; .)
    FLOAT           reduce using rule 12 (statement -> ID TASSIGN expr ; .)
    INT             reduce using rule 12 (statement -> ID TASSIGN expr ; .)
    (               reduce using rule 12 (statement -> ID TASSIGN expr ; .)
    '               reduce using rule 12 (statement -> ID TASSIGN expr ; .)
    $end            reduce using rule 12 (statement -> ID TASSIGN expr ; .)
    }               reduce using rule 12 (statement -> ID TASSIGN expr ; .)
    ELSE            reduce using rule 12 (statement -> ID TASSIGN expr ; .)
    BREAK           reduce using rule 12 (statement -> ID TASSIGN expr ; .)
    CONTINUE        reduce using rule 12 (statement -> ID TASSIGN expr ; .)


state 98

    (13) statement -> ID MASSIGN expr ; .
    FOR             reduce using rule 13 (statement -> ID MASSIGN expr ; .)
    WHILE           reduce using rule 13 (statement -> ID MASSIGN expr ; .)
    IF              reduce using rule 13 (statement -> ID MASSIGN expr ; .)
    PRINT           reduce using rule 13 (statement -> ID MASSIGN expr ; .)
    RETURN          reduce using rule 13 (statement -> ID MASSIGN expr ; .)
    ID              reduce using rule 13 (statement -> ID MASSIGN expr ; .)
    EYE             reduce using rule 13 (statement -> ID MASSIGN expr ; .)
    ONES            reduce using rule 13 (statement -> ID MASSIGN expr ; .)
    ZEROS           reduce using rule 13 (statement -> ID MASSIGN expr ; .)
    [               reduce using rule 13 (statement -> ID MASSIGN expr ; .)
    STRING          reduce using rule 13 (statement -> ID MASSIGN expr ; .)
    FLOAT           reduce using rule 13 (statement -> ID MASSIGN expr ; .)
    INT             reduce using rule 13 (statement -> ID MASSIGN expr ; .)
    (               reduce using rule 13 (statement -> ID MASSIGN expr ; .)
    '               reduce using rule 13 (statement -> ID MASSIGN expr ; .)
    $end            reduce using rule 13 (statement -> ID MASSIGN expr ; .)
    }               reduce using rule 13 (statement -> ID MASSIGN expr ; .)
    ELSE            reduce using rule 13 (statement -> ID MASSIGN expr ; .)
    BREAK           reduce using rule 13 (statement -> ID MASSIGN expr ; .)
    CONTINUE        reduce using rule 13 (statement -> ID MASSIGN expr ; .)


state 99

    (14) statement -> ID PASSIGN expr ; .
    FOR             reduce using rule 14 (statement -> ID PASSIGN expr ; .)
    WHILE           reduce using rule 14 (statement -> ID PASSIGN expr ; .)
    IF              reduce using rule 14 (statement -> ID PASSIGN expr ; .)
    PRINT           reduce using rule 14 (statement -> ID PASSIGN expr ; .)
    RETURN          reduce using rule 14 (statement -> ID PASSIGN expr ; .)
    ID              reduce using rule 14 (statement -> ID PASSIGN expr ; .)
    EYE             reduce using rule 14 (statement -> ID PASSIGN expr ; .)
    ONES            reduce using rule 14 (statement -> ID PASSIGN expr ; .)
    ZEROS           reduce using rule 14 (statement -> ID PASSIGN expr ; .)
    [               reduce using rule 14 (statement -> ID PASSIGN expr ; .)
    STRING          reduce using rule 14 (statement -> ID PASSIGN expr ; .)
    FLOAT           reduce using rule 14 (statement -> ID PASSIGN expr ; .)
    INT             reduce using rule 14 (statement -> ID PASSIGN expr ; .)
    (               reduce using rule 14 (statement -> ID PASSIGN expr ; .)
    '               reduce using rule 14 (statement -> ID PASSIGN expr ; .)
    $end            reduce using rule 14 (statement -> ID PASSIGN expr ; .)
    }               reduce using rule 14 (statement -> ID PASSIGN expr ; .)
    ELSE            reduce using rule 14 (statement -> ID PASSIGN expr ; .)
    BREAK           reduce using rule 14 (statement -> ID PASSIGN expr ; .)
    CONTINUE        reduce using rule 14 (statement -> ID PASSIGN expr ; .)


state 100

    (15) statement -> ID = expr ; .
    FOR             reduce using rule 15 (statement -> ID = expr ; .)
    WHILE           reduce using rule 15 (statement -> ID = expr ; .)
    IF              reduce using rule 15 (statement -> ID = expr ; .)
    PRINT           reduce using rule 15 (statement -> ID = expr ; .)
    RETURN          reduce using rule 15 (statement -> ID = expr ; .)
    ID              reduce using rule 15 (statement -> ID = expr ; .)
    EYE             reduce using rule 15 (statement -> ID = expr ; .)
    ONES            reduce using rule 15 (statement -> ID = expr ; .)
    ZEROS           reduce using rule 15 (statement -> ID = expr ; .)
    [               reduce using rule 15 (statement -> ID = expr ; .)
    STRING          reduce using rule 15 (statement -> ID = expr ; .)
    FLOAT           reduce using rule 15 (statement -> ID = expr ; .)
    INT             reduce using rule 15 (statement -> ID = expr ; .)
    (               reduce using rule 15 (statement -> ID = expr ; .)
    '               reduce using rule 15 (statement -> ID = expr ; .)
    $end            reduce using rule 15 (statement -> ID = expr ; .)
    }               reduce using rule 15 (statement -> ID = expr ; .)
    ELSE            reduce using rule 15 (statement -> ID = expr ; .)
    BREAK           reduce using rule 15 (statement -> ID = expr ; .)
    CONTINUE        reduce using rule 15 (statement -> ID = expr ; .)


state 101

    (18) loopblock -> { loopstart . }
    }               shift and go to state 117


state 102

    (20) loopstart -> empty .
    }               reduce using rule 20 (loopstart -> empty .)


state 103

    (21) loopstart -> BREAK . ;
    ;               shift and go to state 118


state 104

    (22) loopstart -> CONTINUE . ;
    ;               shift and go to state 119


state 105

    (23) loopstart -> statement . loopstart
    (20) loopstart -> . empty
    (21) loopstart -> . BREAK ;
    (22) loopstart -> . CONTINUE ;
    (23) loopstart -> . statement loopstart
    (1) empty -> .
    (4) statement -> . FOR ID = range loopblock
    (5) statement -> . WHILE expr loopblock
    (6) statement -> . IF expr ifblock ELSE ifblock
    (7) statement -> . IF expr ifblock
    (8) statement -> . PRINT expr ;
    (9) statement -> . expr ;
    (10) statement -> . RETURN
    (11) statement -> . ID DASSIGN expr ;
    (12) statement -> . ID TASSIGN expr ;
    (13) statement -> . ID MASSIGN expr ;
    (14) statement -> . ID PASSIGN expr ;
    (15) statement -> . ID = expr ;
    (24) expr -> . EYE ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ID
    (28) expr -> . [ outerlist ]
    (29) expr -> . STRING
    (30) expr -> . FLOAT
    (31) expr -> . INT
    (32) expr -> . expr '
    (33) expr -> . ( expr )
    (34) expr -> . expr NEQ expr
    (35) expr -> . expr EQ expr
    (36) expr -> . expr GEQ expr
    (37) expr -> . expr > expr
    (38) expr -> . expr LEQ expr
    (39) expr -> . expr < expr
    (40) expr -> . ' expr
    (41) expr -> . expr MDIVIDE expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MMINUS expr
    (44) expr -> . expr MPLUS expr
    (45) expr -> . expr / expr
    (46) expr -> . expr * expr
    (47) expr -> . expr - expr
    (48) expr -> . expr + expr
    BREAK           shift and go to state 103
    CONTINUE        shift and go to state 104
    }               reduce using rule 1 (empty -> .)
    FOR             shift and go to state 4
    WHILE           shift and go to state 6
    IF              shift and go to state 8
    PRINT           shift and go to state 9
    RETURN          shift and go to state 10
    ID              shift and go to state 5
    EYE             shift and go to state 11
    ONES            shift and go to state 13
    ZEROS           shift and go to state 14
    [               shift and go to state 15
    STRING          shift and go to state 16
    FLOAT           shift and go to state 17
    INT             shift and go to state 18
    (               shift and go to state 12
    '               shift and go to state 19

    statement                      shift and go to state 105
    loopstart                      shift and go to state 120
    empty                          shift and go to state 102
    expr                           shift and go to state 7

state 106

    (6) statement -> IF expr ifblock ELSE . ifblock
    (16) ifblock -> . { start }
    (17) ifblock -> . statement
    (4) statement -> . FOR ID = range loopblock
    (5) statement -> . WHILE expr loopblock
    (6) statement -> . IF expr ifblock ELSE ifblock
    (7) statement -> . IF expr ifblock
    (8) statement -> . PRINT expr ;
    (9) statement -> . expr ;
    (10) statement -> . RETURN
    (11) statement -> . ID DASSIGN expr ;
    (12) statement -> . ID TASSIGN expr ;
    (13) statement -> . ID MASSIGN expr ;
    (14) statement -> . ID PASSIGN expr ;
    (15) statement -> . ID = expr ;
    (24) expr -> . EYE ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . ZEROS ( expr )
    (27) expr -> . ID
    (28) expr -> . [ outerlist ]
    (29) expr -> . STRING
    (30) expr -> . FLOAT
    (31) expr -> . INT
    (32) expr -> . expr '
    (33) expr -> . ( expr )
    (34) expr -> . expr NEQ expr
    (35) expr -> . expr EQ expr
    (36) expr -> . expr GEQ expr
    (37) expr -> . expr > expr
    (38) expr -> . expr LEQ expr
    (39) expr -> . expr < expr
    (40) expr -> . ' expr
    (41) expr -> . expr MDIVIDE expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MMINUS expr
    (44) expr -> . expr MPLUS expr
    (45) expr -> . expr / expr
    (46) expr -> . expr * expr
    (47) expr -> . expr - expr
    (48) expr -> . expr + expr
    {               shift and go to state 79
    FOR             shift and go to state 4
    WHILE           shift and go to state 6
    IF              shift and go to state 8
    PRINT           shift and go to state 9
    RETURN          shift and go to state 10
    ID              shift and go to state 5
    EYE             shift and go to state 11
    ONES            shift and go to state 13
    ZEROS           shift and go to state 14
    [               shift and go to state 15
    STRING          shift and go to state 16
    FLOAT           shift and go to state 17
    INT             shift and go to state 18
    (               shift and go to state 12
    '               shift and go to state 19

    expr                           shift and go to state 7
    ifblock                        shift and go to state 121
    statement                      shift and go to state 80

state 107

    (16) ifblock -> { start . }
    }               shift and go to state 122


state 108

    (24) expr -> EYE ( expr ) .
    ;               reduce using rule 24 (expr -> EYE ( expr ) .)
    '               reduce using rule 24 (expr -> EYE ( expr ) .)
    NEQ             reduce using rule 24 (expr -> EYE ( expr ) .)
    EQ              reduce using rule 24 (expr -> EYE ( expr ) .)
    GEQ             reduce using rule 24 (expr -> EYE ( expr ) .)
    >               reduce using rule 24 (expr -> EYE ( expr ) .)
    LEQ             reduce using rule 24 (expr -> EYE ( expr ) .)
    <               reduce using rule 24 (expr -> EYE ( expr ) .)
    MDIVIDE         reduce using rule 24 (expr -> EYE ( expr ) .)
    MTIMES          reduce using rule 24 (expr -> EYE ( expr ) .)
    MMINUS          reduce using rule 24 (expr -> EYE ( expr ) .)
    MPLUS           reduce using rule 24 (expr -> EYE ( expr ) .)
    /               reduce using rule 24 (expr -> EYE ( expr ) .)
    *               reduce using rule 24 (expr -> EYE ( expr ) .)
    -               reduce using rule 24 (expr -> EYE ( expr ) .)
    +               reduce using rule 24 (expr -> EYE ( expr ) .)
    {               reduce using rule 24 (expr -> EYE ( expr ) .)
    FOR             reduce using rule 24 (expr -> EYE ( expr ) .)
    WHILE           reduce using rule 24 (expr -> EYE ( expr ) .)
    IF              reduce using rule 24 (expr -> EYE ( expr ) .)
    PRINT           reduce using rule 24 (expr -> EYE ( expr ) .)
    RETURN          reduce using rule 24 (expr -> EYE ( expr ) .)
    ID              reduce using rule 24 (expr -> EYE ( expr ) .)
    EYE             reduce using rule 24 (expr -> EYE ( expr ) .)
    ONES            reduce using rule 24 (expr -> EYE ( expr ) .)
    ZEROS           reduce using rule 24 (expr -> EYE ( expr ) .)
    [               reduce using rule 24 (expr -> EYE ( expr ) .)
    STRING          reduce using rule 24 (expr -> EYE ( expr ) .)
    FLOAT           reduce using rule 24 (expr -> EYE ( expr ) .)
    INT             reduce using rule 24 (expr -> EYE ( expr ) .)
    (               reduce using rule 24 (expr -> EYE ( expr ) .)
    )               reduce using rule 24 (expr -> EYE ( expr ) .)


state 109

    (25) expr -> ONES ( expr ) .
    ;               reduce using rule 25 (expr -> ONES ( expr ) .)
    '               reduce using rule 25 (expr -> ONES ( expr ) .)
    NEQ             reduce using rule 25 (expr -> ONES ( expr ) .)
    EQ              reduce using rule 25 (expr -> ONES ( expr ) .)
    GEQ             reduce using rule 25 (expr -> ONES ( expr ) .)
    >               reduce using rule 25 (expr -> ONES ( expr ) .)
    LEQ             reduce using rule 25 (expr -> ONES ( expr ) .)
    <               reduce using rule 25 (expr -> ONES ( expr ) .)
    MDIVIDE         reduce using rule 25 (expr -> ONES ( expr ) .)
    MTIMES          reduce using rule 25 (expr -> ONES ( expr ) .)
    MMINUS          reduce using rule 25 (expr -> ONES ( expr ) .)
    MPLUS           reduce using rule 25 (expr -> ONES ( expr ) .)
    /               reduce using rule 25 (expr -> ONES ( expr ) .)
    *               reduce using rule 25 (expr -> ONES ( expr ) .)
    -               reduce using rule 25 (expr -> ONES ( expr ) .)
    +               reduce using rule 25 (expr -> ONES ( expr ) .)
    {               reduce using rule 25 (expr -> ONES ( expr ) .)
    FOR             reduce using rule 25 (expr -> ONES ( expr ) .)
    WHILE           reduce using rule 25 (expr -> ONES ( expr ) .)
    IF              reduce using rule 25 (expr -> ONES ( expr ) .)
    PRINT           reduce using rule 25 (expr -> ONES ( expr ) .)
    RETURN          reduce using rule 25 (expr -> ONES ( expr ) .)
    ID              reduce using rule 25 (expr -> ONES ( expr ) .)
    EYE             reduce using rule 25 (expr -> ONES ( expr ) .)
    ONES            reduce using rule 25 (expr -> ONES ( expr ) .)
    ZEROS           reduce using rule 25 (expr -> ONES ( expr ) .)
    [               reduce using rule 25 (expr -> ONES ( expr ) .)
    STRING          reduce using rule 25 (expr -> ONES ( expr ) .)
    FLOAT           reduce using rule 25 (expr -> ONES ( expr ) .)
    INT             reduce using rule 25 (expr -> ONES ( expr ) .)
    (               reduce using rule 25 (expr -> ONES ( expr ) .)
    )               reduce using rule 25 (expr -> ONES ( expr ) .)


state 110

    (26) expr -> ZEROS ( expr ) .
    ;               reduce using rule 26 (expr -> ZEROS ( expr ) .)
    '               reduce using rule 26 (expr -> ZEROS ( expr ) .)
    NEQ             reduce using rule 26 (expr -> ZEROS ( expr ) .)
    EQ              reduce using rule 26 (expr -> ZEROS ( expr ) .)
    GEQ             reduce using rule 26 (expr -> ZEROS ( expr ) .)
    >               reduce using rule 26 (expr -> ZEROS ( expr ) .)
    LEQ             reduce using rule 26 (expr -> ZEROS ( expr ) .)
    <               reduce using rule 26 (expr -> ZEROS ( expr ) .)
    MDIVIDE         reduce using rule 26 (expr -> ZEROS ( expr ) .)
    MTIMES          reduce using rule 26 (expr -> ZEROS ( expr ) .)
    MMINUS          reduce using rule 26 (expr -> ZEROS ( expr ) .)
    MPLUS           reduce using rule 26 (expr -> ZEROS ( expr ) .)
    /               reduce using rule 26 (expr -> ZEROS ( expr ) .)
    *               reduce using rule 26 (expr -> ZEROS ( expr ) .)
    -               reduce using rule 26 (expr -> ZEROS ( expr ) .)
    +               reduce using rule 26 (expr -> ZEROS ( expr ) .)
    {               reduce using rule 26 (expr -> ZEROS ( expr ) .)
    FOR             reduce using rule 26 (expr -> ZEROS ( expr ) .)
    WHILE           reduce using rule 26 (expr -> ZEROS ( expr ) .)
    IF              reduce using rule 26 (expr -> ZEROS ( expr ) .)
    PRINT           reduce using rule 26 (expr -> ZEROS ( expr ) .)
    RETURN          reduce using rule 26 (expr -> ZEROS ( expr ) .)
    ID              reduce using rule 26 (expr -> ZEROS ( expr ) .)
    EYE             reduce using rule 26 (expr -> ZEROS ( expr ) .)
    ONES            reduce using rule 26 (expr -> ZEROS ( expr ) .)
    ZEROS           reduce using rule 26 (expr -> ZEROS ( expr ) .)
    [               reduce using rule 26 (expr -> ZEROS ( expr ) .)
    STRING          reduce using rule 26 (expr -> ZEROS ( expr ) .)
    FLOAT           reduce using rule 26 (expr -> ZEROS ( expr ) .)
    INT             reduce using rule 26 (expr -> ZEROS ( expr ) .)
    (               reduce using rule 26 (expr -> ZEROS ( expr ) .)
    )               reduce using rule 26 (expr -> ZEROS ( expr ) .)


state 111

    (53) outerlist -> [ innerlist ] .
    ]               reduce using rule 53 (outerlist -> [ innerlist ] .)
    ,               reduce using rule 53 (outerlist -> [ innerlist ] .)


state 112

    (56) innerlist -> innerlist , . elem
    (57) elem -> . STRING
    (58) elem -> . FLOAT
    (59) elem -> . INT
    STRING          shift and go to state 88
    FLOAT           shift and go to state 89
    INT             shift and go to state 90

    elem                           shift and go to state 123

state 113

    (54) outerlist -> outerlist , [ . innerlist ]
    (55) innerlist -> . elem
    (56) innerlist -> . innerlist , elem
    (57) elem -> . STRING
    (58) elem -> . FLOAT
    (59) elem -> . INT
    STRING          shift and go to state 88
    FLOAT           shift and go to state 89
    INT             shift and go to state 90

    innerlist                      shift and go to state 124
    elem                           shift and go to state 87

state 114

    (50) range -> ID : . INT
    (51) range -> ID : . ID
    INT             shift and go to state 126
    ID              shift and go to state 125


state 115

    (4) statement -> FOR ID = range loopblock .
    FOR             reduce using rule 4 (statement -> FOR ID = range loopblock .)
    WHILE           reduce using rule 4 (statement -> FOR ID = range loopblock .)
    IF              reduce using rule 4 (statement -> FOR ID = range loopblock .)
    PRINT           reduce using rule 4 (statement -> FOR ID = range loopblock .)
    RETURN          reduce using rule 4 (statement -> FOR ID = range loopblock .)
    ID              reduce using rule 4 (statement -> FOR ID = range loopblock .)
    EYE             reduce using rule 4 (statement -> FOR ID = range loopblock .)
    ONES            reduce using rule 4 (statement -> FOR ID = range loopblock .)
    ZEROS           reduce using rule 4 (statement -> FOR ID = range loopblock .)
    [               reduce using rule 4 (statement -> FOR ID = range loopblock .)
    STRING          reduce using rule 4 (statement -> FOR ID = range loopblock .)
    FLOAT           reduce using rule 4 (statement -> FOR ID = range loopblock .)
    INT             reduce using rule 4 (statement -> FOR ID = range loopblock .)
    (               reduce using rule 4 (statement -> FOR ID = range loopblock .)
    '               reduce using rule 4 (statement -> FOR ID = range loopblock .)
    $end            reduce using rule 4 (statement -> FOR ID = range loopblock .)
    }               reduce using rule 4 (statement -> FOR ID = range loopblock .)
    ELSE            reduce using rule 4 (statement -> FOR ID = range loopblock .)
    BREAK           reduce using rule 4 (statement -> FOR ID = range loopblock .)
    CONTINUE        reduce using rule 4 (statement -> FOR ID = range loopblock .)


state 116

    (49) range -> INT : . ID
    (52) range -> INT : . INT
    ID              shift and go to state 128
    INT             shift and go to state 127


state 117

    (18) loopblock -> { loopstart } .
    FOR             reduce using rule 18 (loopblock -> { loopstart } .)
    WHILE           reduce using rule 18 (loopblock -> { loopstart } .)
    IF              reduce using rule 18 (loopblock -> { loopstart } .)
    PRINT           reduce using rule 18 (loopblock -> { loopstart } .)
    RETURN          reduce using rule 18 (loopblock -> { loopstart } .)
    ID              reduce using rule 18 (loopblock -> { loopstart } .)
    EYE             reduce using rule 18 (loopblock -> { loopstart } .)
    ONES            reduce using rule 18 (loopblock -> { loopstart } .)
    ZEROS           reduce using rule 18 (loopblock -> { loopstart } .)
    [               reduce using rule 18 (loopblock -> { loopstart } .)
    STRING          reduce using rule 18 (loopblock -> { loopstart } .)
    FLOAT           reduce using rule 18 (loopblock -> { loopstart } .)
    INT             reduce using rule 18 (loopblock -> { loopstart } .)
    (               reduce using rule 18 (loopblock -> { loopstart } .)
    '               reduce using rule 18 (loopblock -> { loopstart } .)
    $end            reduce using rule 18 (loopblock -> { loopstart } .)
    }               reduce using rule 18 (loopblock -> { loopstart } .)
    ELSE            reduce using rule 18 (loopblock -> { loopstart } .)
    BREAK           reduce using rule 18 (loopblock -> { loopstart } .)
    CONTINUE        reduce using rule 18 (loopblock -> { loopstart } .)


state 118

    (21) loopstart -> BREAK ; .
    }               reduce using rule 21 (loopstart -> BREAK ; .)


state 119

    (22) loopstart -> CONTINUE ; .
    }               reduce using rule 22 (loopstart -> CONTINUE ; .)


state 120

    (23) loopstart -> statement loopstart .
    }               reduce using rule 23 (loopstart -> statement loopstart .)


state 121

    (6) statement -> IF expr ifblock ELSE ifblock .
    FOR             reduce using rule 6 (statement -> IF expr ifblock ELSE ifblock .)
    WHILE           reduce using rule 6 (statement -> IF expr ifblock ELSE ifblock .)
    IF              reduce using rule 6 (statement -> IF expr ifblock ELSE ifblock .)
    PRINT           reduce using rule 6 (statement -> IF expr ifblock ELSE ifblock .)
    RETURN          reduce using rule 6 (statement -> IF expr ifblock ELSE ifblock .)
    ID              reduce using rule 6 (statement -> IF expr ifblock ELSE ifblock .)
    EYE             reduce using rule 6 (statement -> IF expr ifblock ELSE ifblock .)
    ONES            reduce using rule 6 (statement -> IF expr ifblock ELSE ifblock .)
    ZEROS           reduce using rule 6 (statement -> IF expr ifblock ELSE ifblock .)
    [               reduce using rule 6 (statement -> IF expr ifblock ELSE ifblock .)
    STRING          reduce using rule 6 (statement -> IF expr ifblock ELSE ifblock .)
    FLOAT           reduce using rule 6 (statement -> IF expr ifblock ELSE ifblock .)
    INT             reduce using rule 6 (statement -> IF expr ifblock ELSE ifblock .)
    (               reduce using rule 6 (statement -> IF expr ifblock ELSE ifblock .)
    '               reduce using rule 6 (statement -> IF expr ifblock ELSE ifblock .)
    $end            reduce using rule 6 (statement -> IF expr ifblock ELSE ifblock .)
    }               reduce using rule 6 (statement -> IF expr ifblock ELSE ifblock .)
    ELSE            reduce using rule 6 (statement -> IF expr ifblock ELSE ifblock .)
    BREAK           reduce using rule 6 (statement -> IF expr ifblock ELSE ifblock .)
    CONTINUE        reduce using rule 6 (statement -> IF expr ifblock ELSE ifblock .)


state 122

    (16) ifblock -> { start } .
    FOR             reduce using rule 16 (ifblock -> { start } .)
    WHILE           reduce using rule 16 (ifblock -> { start } .)
    IF              reduce using rule 16 (ifblock -> { start } .)
    PRINT           reduce using rule 16 (ifblock -> { start } .)
    RETURN          reduce using rule 16 (ifblock -> { start } .)
    ID              reduce using rule 16 (ifblock -> { start } .)
    EYE             reduce using rule 16 (ifblock -> { start } .)
    ONES            reduce using rule 16 (ifblock -> { start } .)
    ZEROS           reduce using rule 16 (ifblock -> { start } .)
    [               reduce using rule 16 (ifblock -> { start } .)
    STRING          reduce using rule 16 (ifblock -> { start } .)
    FLOAT           reduce using rule 16 (ifblock -> { start } .)
    INT             reduce using rule 16 (ifblock -> { start } .)
    (               reduce using rule 16 (ifblock -> { start } .)
    '               reduce using rule 16 (ifblock -> { start } .)
    $end            reduce using rule 16 (ifblock -> { start } .)
    }               reduce using rule 16 (ifblock -> { start } .)
    ELSE            reduce using rule 16 (ifblock -> { start } .)
    BREAK           reduce using rule 16 (ifblock -> { start } .)
    CONTINUE        reduce using rule 16 (ifblock -> { start } .)


state 123

    (56) innerlist -> innerlist , elem .
    ]               reduce using rule 56 (innerlist -> innerlist , elem .)
    ,               reduce using rule 56 (innerlist -> innerlist , elem .)


state 124

    (54) outerlist -> outerlist , [ innerlist . ]
    (56) innerlist -> innerlist . , elem
    ]               shift and go to state 129
    ,               shift and go to state 112


state 125

    (51) range -> ID : ID .
    {               reduce using rule 51 (range -> ID : ID .)
    FOR             reduce using rule 51 (range -> ID : ID .)
    WHILE           reduce using rule 51 (range -> ID : ID .)
    IF              reduce using rule 51 (range -> ID : ID .)
    PRINT           reduce using rule 51 (range -> ID : ID .)
    RETURN          reduce using rule 51 (range -> ID : ID .)
    ID              reduce using rule 51 (range -> ID : ID .)
    EYE             reduce using rule 51 (range -> ID : ID .)
    ONES            reduce using rule 51 (range -> ID : ID .)
    ZEROS           reduce using rule 51 (range -> ID : ID .)
    [               reduce using rule 51 (range -> ID : ID .)
    STRING          reduce using rule 51 (range -> ID : ID .)
    FLOAT           reduce using rule 51 (range -> ID : ID .)
    INT             reduce using rule 51 (range -> ID : ID .)
    (               reduce using rule 51 (range -> ID : ID .)
    '               reduce using rule 51 (range -> ID : ID .)


state 126

    (50) range -> ID : INT .
    {               reduce using rule 50 (range -> ID : INT .)
    FOR             reduce using rule 50 (range -> ID : INT .)
    WHILE           reduce using rule 50 (range -> ID : INT .)
    IF              reduce using rule 50 (range -> ID : INT .)
    PRINT           reduce using rule 50 (range -> ID : INT .)
    RETURN          reduce using rule 50 (range -> ID : INT .)
    ID              reduce using rule 50 (range -> ID : INT .)
    EYE             reduce using rule 50 (range -> ID : INT .)
    ONES            reduce using rule 50 (range -> ID : INT .)
    ZEROS           reduce using rule 50 (range -> ID : INT .)
    [               reduce using rule 50 (range -> ID : INT .)
    STRING          reduce using rule 50 (range -> ID : INT .)
    FLOAT           reduce using rule 50 (range -> ID : INT .)
    INT             reduce using rule 50 (range -> ID : INT .)
    (               reduce using rule 50 (range -> ID : INT .)
    '               reduce using rule 50 (range -> ID : INT .)


state 127

    (52) range -> INT : INT .
    {               reduce using rule 52 (range -> INT : INT .)
    FOR             reduce using rule 52 (range -> INT : INT .)
    WHILE           reduce using rule 52 (range -> INT : INT .)
    IF              reduce using rule 52 (range -> INT : INT .)
    PRINT           reduce using rule 52 (range -> INT : INT .)
    RETURN          reduce using rule 52 (range -> INT : INT .)
    ID              reduce using rule 52 (range -> INT : INT .)
    EYE             reduce using rule 52 (range -> INT : INT .)
    ONES            reduce using rule 52 (range -> INT : INT .)
    ZEROS           reduce using rule 52 (range -> INT : INT .)
    [               reduce using rule 52 (range -> INT : INT .)
    STRING          reduce using rule 52 (range -> INT : INT .)
    FLOAT           reduce using rule 52 (range -> INT : INT .)
    INT             reduce using rule 52 (range -> INT : INT .)
    (               reduce using rule 52 (range -> INT : INT .)
    '               reduce using rule 52 (range -> INT : INT .)


state 128

    (49) range -> INT : ID .
    {               reduce using rule 49 (range -> INT : ID .)
    FOR             reduce using rule 49 (range -> INT : ID .)
    WHILE           reduce using rule 49 (range -> INT : ID .)
    IF              reduce using rule 49 (range -> INT : ID .)
    PRINT           reduce using rule 49 (range -> INT : ID .)
    RETURN          reduce using rule 49 (range -> INT : ID .)
    ID              reduce using rule 49 (range -> INT : ID .)
    EYE             reduce using rule 49 (range -> INT : ID .)
    ONES            reduce using rule 49 (range -> INT : ID .)
    ZEROS           reduce using rule 49 (range -> INT : ID .)
    [               reduce using rule 49 (range -> INT : ID .)
    STRING          reduce using rule 49 (range -> INT : ID .)
    FLOAT           reduce using rule 49 (range -> INT : ID .)
    INT             reduce using rule 49 (range -> INT : ID .)
    (               reduce using rule 49 (range -> INT : ID .)
    '               reduce using rule 49 (range -> INT : ID .)


state 129

    (54) outerlist -> outerlist , [ innerlist ] .
    ]               reduce using rule 54 (outerlist -> outerlist , [ innerlist ] .)
    ,               reduce using rule 54 (outerlist -> outerlist , [ innerlist ] .)
