Grammar:

Rule 0     S' -> start
Rule 1     start -> block start
Rule 2     start -> block
Rule 3     block -> { next_statements }
Rule 4     block -> statement
Rule 5     next_statements -> statement next_statements
Rule 6     next_statements -> statement
Rule 7     statement -> flow_control_statement
Rule 8     statement -> action_statement ;
Rule 9     action_statement -> BREAK
Rule 10    action_statement -> CONTINUE
Rule 11    action_statement -> RETURN expr
Rule 12    action_statement -> PRINT values
Rule 13    action_statement -> id_expr DASSIGN expr
Rule 14    action_statement -> id_expr TASSIGN expr
Rule 15    action_statement -> id_expr MASSIGN expr
Rule 16    action_statement -> id_expr PASSIGN expr
Rule 17    action_statement -> id_expr = expr
Rule 18    values -> expr , values
Rule 19    values -> expr
Rule 20    expr -> EYE ( expr )
Rule 21    expr -> ONES ( expr )
Rule 22    expr -> ZEROS ( expr )
Rule 23    expr -> id_expr
Rule 24    expr -> STRING
Rule 25    expr -> FLOAT
Rule 26    expr -> INT
Rule 27    expr -> ( expr )
Rule 28    expr -> expr NEQ expr  [precedence=nonassoc, level=3]
Rule 29    expr -> expr EQ expr  [precedence=nonassoc, level=3]
Rule 30    expr -> expr GEQ expr  [precedence=nonassoc, level=3]
Rule 31    expr -> expr > expr  [precedence=nonassoc, level=3]
Rule 32    expr -> expr LEQ expr  [precedence=nonassoc, level=3]
Rule 33    expr -> expr < expr  [precedence=nonassoc, level=3]
Rule 34    expr -> expr '  [precedence=right, level=6]
Rule 35    expr -> - expr  [precedence=right, level=6]
Rule 36    expr -> expr MDIVIDE expr  [precedence=left, level=5]
Rule 37    expr -> expr MTIMES expr  [precedence=left, level=5]
Rule 38    expr -> expr MMINUS expr  [precedence=left, level=4]
Rule 39    expr -> expr MPLUS expr  [precedence=left, level=4]
Rule 40    expr -> expr / expr  [precedence=left, level=5]
Rule 41    expr -> expr * expr  [precedence=left, level=5]
Rule 42    expr -> expr - expr  [precedence=left, level=4]
Rule 43    expr -> expr + expr  [precedence=left, level=4]
Rule 44    expr -> [ matrix ]
Rule 45    expr -> [ values ]
Rule 46    matrix -> [ values ] , matrix
Rule 47    matrix -> [ values ]
Rule 48    flow_control_statement -> FOR ID = range block
Rule 49    flow_control_statement -> WHILE expr block
Rule 50    flow_control_statement -> IF expr block ELSE block  [precedence=nonassoc, level=2]
Rule 51    flow_control_statement -> IF expr block  [precedence=nonassoc, level=1]
Rule 52    range -> expr : expr
Rule 53    id_expr -> ID [ values ]
Rule 54    id_expr -> ID

Terminals, with rules where they appear:

'                    : 34
(                    : 20 21 22 27
)                    : 20 21 22 27
*                    : 41
+                    : 43
,                    : 18 46
-                    : 35 42
/                    : 40
:                    : 52
;                    : 8
<                    : 33
=                    : 17 48
>                    : 31
BREAK                : 9
CONTINUE             : 10
DASSIGN              : 13
ELSE                 : 50
EQ                   : 29
EYE                  : 20
FLOAT                : 25
FOR                  : 48
GEQ                  : 30
ID                   : 48 53 54
IF                   : 50 51
INT                  : 26
LEQ                  : 32
MASSIGN              : 15
MDIVIDE              : 36
MMINUS               : 38
MPLUS                : 39
MTIMES               : 37
NEQ                  : 28
ONES                 : 21
PASSIGN              : 16
PRINT                : 12
RETURN               : 11
STRING               : 24
TASSIGN              : 14
WHILE                : 49
ZEROS                : 22
[                    : 44 45 46 47 53
]                    : 44 45 46 47 53
error                : 
{                    : 3
}                    : 3

Nonterminals, with rules where they appear:

action_statement     : 8
block                : 1 2 48 49 50 50 51
expr                 : 11 13 14 15 16 17 18 19 20 21 22 27 28 28 29 29 30 30 31 31 32 32 33 33 34 35 36 36 37 37 38 38 39 39 40 40 41 41 42 42 43 43 49 50 51 52 52
flow_control_statement : 7
id_expr              : 13 14 15 16 17 23
matrix               : 44 46
next_statements      : 3 5
range                : 48
start                : 1 0
statement            : 4 5 6
values               : 12 18 45 46 47 53


state 0

    (0) S' -> . start
    (1) start -> . block start
    (2) start -> . block
    (3) block -> . { next_statements }
    (4) block -> . statement
    (7) statement -> . flow_control_statement
    (8) statement -> . action_statement ;
    (48) flow_control_statement -> . FOR ID = range block
    (49) flow_control_statement -> . WHILE expr block
    (50) flow_control_statement -> . IF expr block ELSE block
    (51) flow_control_statement -> . IF expr block
    (9) action_statement -> . BREAK
    (10) action_statement -> . CONTINUE
    (11) action_statement -> . RETURN expr
    (12) action_statement -> . PRINT values
    (13) action_statement -> . id_expr DASSIGN expr
    (14) action_statement -> . id_expr TASSIGN expr
    (15) action_statement -> . id_expr MASSIGN expr
    (16) action_statement -> . id_expr PASSIGN expr
    (17) action_statement -> . id_expr = expr
    (53) id_expr -> . ID [ values ]
    (54) id_expr -> . ID
    {               shift and go to state 3
    FOR             shift and go to state 7
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    BREAK           shift and go to state 11
    CONTINUE        shift and go to state 12
    RETURN          shift and go to state 13
    PRINT           shift and go to state 14
    ID              shift and go to state 8

    start                          shift and go to state 1
    block                          shift and go to state 2
    statement                      shift and go to state 4
    flow_control_statement         shift and go to state 5
    action_statement               shift and go to state 6
    id_expr                        shift and go to state 15

state 1

    (0) S' -> start .


state 2

    (1) start -> block . start
    (2) start -> block .
    (1) start -> . block start
    (2) start -> . block
    (3) block -> . { next_statements }
    (4) block -> . statement
    (7) statement -> . flow_control_statement
    (8) statement -> . action_statement ;
    (48) flow_control_statement -> . FOR ID = range block
    (49) flow_control_statement -> . WHILE expr block
    (50) flow_control_statement -> . IF expr block ELSE block
    (51) flow_control_statement -> . IF expr block
    (9) action_statement -> . BREAK
    (10) action_statement -> . CONTINUE
    (11) action_statement -> . RETURN expr
    (12) action_statement -> . PRINT values
    (13) action_statement -> . id_expr DASSIGN expr
    (14) action_statement -> . id_expr TASSIGN expr
    (15) action_statement -> . id_expr MASSIGN expr
    (16) action_statement -> . id_expr PASSIGN expr
    (17) action_statement -> . id_expr = expr
    (53) id_expr -> . ID [ values ]
    (54) id_expr -> . ID
    $end            reduce using rule 2 (start -> block .)
    {               shift and go to state 3
    FOR             shift and go to state 7
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    BREAK           shift and go to state 11
    CONTINUE        shift and go to state 12
    RETURN          shift and go to state 13
    PRINT           shift and go to state 14
    ID              shift and go to state 8

    block                          shift and go to state 2
    start                          shift and go to state 16
    statement                      shift and go to state 4
    flow_control_statement         shift and go to state 5
    action_statement               shift and go to state 6
    id_expr                        shift and go to state 15

state 3

    (3) block -> { . next_statements }
    (5) next_statements -> . statement next_statements
    (6) next_statements -> . statement
    (7) statement -> . flow_control_statement
    (8) statement -> . action_statement ;
    (48) flow_control_statement -> . FOR ID = range block
    (49) flow_control_statement -> . WHILE expr block
    (50) flow_control_statement -> . IF expr block ELSE block
    (51) flow_control_statement -> . IF expr block
    (9) action_statement -> . BREAK
    (10) action_statement -> . CONTINUE
    (11) action_statement -> . RETURN expr
    (12) action_statement -> . PRINT values
    (13) action_statement -> . id_expr DASSIGN expr
    (14) action_statement -> . id_expr TASSIGN expr
    (15) action_statement -> . id_expr MASSIGN expr
    (16) action_statement -> . id_expr PASSIGN expr
    (17) action_statement -> . id_expr = expr
    (53) id_expr -> . ID [ values ]
    (54) id_expr -> . ID
    FOR             shift and go to state 7
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    BREAK           shift and go to state 11
    CONTINUE        shift and go to state 12
    RETURN          shift and go to state 13
    PRINT           shift and go to state 14
    ID              shift and go to state 8

    next_statements                shift and go to state 17
    statement                      shift and go to state 18
    flow_control_statement         shift and go to state 5
    action_statement               shift and go to state 6
    id_expr                        shift and go to state 15

state 4

    (4) block -> statement .
    {               reduce using rule 4 (block -> statement .)
    FOR             reduce using rule 4 (block -> statement .)
    WHILE           reduce using rule 4 (block -> statement .)
    IF              reduce using rule 4 (block -> statement .)
    BREAK           reduce using rule 4 (block -> statement .)
    CONTINUE        reduce using rule 4 (block -> statement .)
    RETURN          reduce using rule 4 (block -> statement .)
    PRINT           reduce using rule 4 (block -> statement .)
    ID              reduce using rule 4 (block -> statement .)
    $end            reduce using rule 4 (block -> statement .)
    }               reduce using rule 4 (block -> statement .)
    ELSE            reduce using rule 4 (block -> statement .)


state 5

    (7) statement -> flow_control_statement .
    {               reduce using rule 7 (statement -> flow_control_statement .)
    FOR             reduce using rule 7 (statement -> flow_control_statement .)
    WHILE           reduce using rule 7 (statement -> flow_control_statement .)
    IF              reduce using rule 7 (statement -> flow_control_statement .)
    BREAK           reduce using rule 7 (statement -> flow_control_statement .)
    CONTINUE        reduce using rule 7 (statement -> flow_control_statement .)
    RETURN          reduce using rule 7 (statement -> flow_control_statement .)
    PRINT           reduce using rule 7 (statement -> flow_control_statement .)
    ID              reduce using rule 7 (statement -> flow_control_statement .)
    $end            reduce using rule 7 (statement -> flow_control_statement .)
    }               reduce using rule 7 (statement -> flow_control_statement .)
    ELSE            reduce using rule 7 (statement -> flow_control_statement .)


state 6

    (8) statement -> action_statement . ;
    ;               shift and go to state 19


state 7

    (48) flow_control_statement -> FOR . ID = range block
    ID              shift and go to state 20


state 8

    (53) id_expr -> ID . [ values ]
    (54) id_expr -> ID .
    [               shift and go to state 21
    DASSIGN         reduce using rule 54 (id_expr -> ID .)
    TASSIGN         reduce using rule 54 (id_expr -> ID .)
    MASSIGN         reduce using rule 54 (id_expr -> ID .)
    PASSIGN         reduce using rule 54 (id_expr -> ID .)
    =               reduce using rule 54 (id_expr -> ID .)
    NEQ             reduce using rule 54 (id_expr -> ID .)
    EQ              reduce using rule 54 (id_expr -> ID .)
    GEQ             reduce using rule 54 (id_expr -> ID .)
    >               reduce using rule 54 (id_expr -> ID .)
    LEQ             reduce using rule 54 (id_expr -> ID .)
    <               reduce using rule 54 (id_expr -> ID .)
    '               reduce using rule 54 (id_expr -> ID .)
    MDIVIDE         reduce using rule 54 (id_expr -> ID .)
    MTIMES          reduce using rule 54 (id_expr -> ID .)
    MMINUS          reduce using rule 54 (id_expr -> ID .)
    MPLUS           reduce using rule 54 (id_expr -> ID .)
    /               reduce using rule 54 (id_expr -> ID .)
    *               reduce using rule 54 (id_expr -> ID .)
    -               reduce using rule 54 (id_expr -> ID .)
    +               reduce using rule 54 (id_expr -> ID .)
    {               reduce using rule 54 (id_expr -> ID .)
    FOR             reduce using rule 54 (id_expr -> ID .)
    WHILE           reduce using rule 54 (id_expr -> ID .)
    IF              reduce using rule 54 (id_expr -> ID .)
    BREAK           reduce using rule 54 (id_expr -> ID .)
    CONTINUE        reduce using rule 54 (id_expr -> ID .)
    RETURN          reduce using rule 54 (id_expr -> ID .)
    PRINT           reduce using rule 54 (id_expr -> ID .)
    ID              reduce using rule 54 (id_expr -> ID .)
    ;               reduce using rule 54 (id_expr -> ID .)
    ,               reduce using rule 54 (id_expr -> ID .)
    ]               reduce using rule 54 (id_expr -> ID .)
    )               reduce using rule 54 (id_expr -> ID .)
    :               reduce using rule 54 (id_expr -> ID .)


state 9

    (49) flow_control_statement -> WHILE . expr block
    (20) expr -> . EYE ( expr )
    (21) expr -> . ONES ( expr )
    (22) expr -> . ZEROS ( expr )
    (23) expr -> . id_expr
    (24) expr -> . STRING
    (25) expr -> . FLOAT
    (26) expr -> . INT
    (27) expr -> . ( expr )
    (28) expr -> . expr NEQ expr
    (29) expr -> . expr EQ expr
    (30) expr -> . expr GEQ expr
    (31) expr -> . expr > expr
    (32) expr -> . expr LEQ expr
    (33) expr -> . expr < expr
    (34) expr -> . expr '
    (35) expr -> . - expr
    (36) expr -> . expr MDIVIDE expr
    (37) expr -> . expr MTIMES expr
    (38) expr -> . expr MMINUS expr
    (39) expr -> . expr MPLUS expr
    (40) expr -> . expr / expr
    (41) expr -> . expr * expr
    (42) expr -> . expr - expr
    (43) expr -> . expr + expr
    (44) expr -> . [ matrix ]
    (45) expr -> . [ values ]
    (53) id_expr -> . ID [ values ]
    (54) id_expr -> . ID
    EYE             shift and go to state 23
    ONES            shift and go to state 25
    ZEROS           shift and go to state 26
    STRING          shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    (               shift and go to state 24
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 8

    expr                           shift and go to state 22
    id_expr                        shift and go to state 27

state 10

    (50) flow_control_statement -> IF . expr block ELSE block
    (51) flow_control_statement -> IF . expr block
    (20) expr -> . EYE ( expr )
    (21) expr -> . ONES ( expr )
    (22) expr -> . ZEROS ( expr )
    (23) expr -> . id_expr
    (24) expr -> . STRING
    (25) expr -> . FLOAT
    (26) expr -> . INT
    (27) expr -> . ( expr )
    (28) expr -> . expr NEQ expr
    (29) expr -> . expr EQ expr
    (30) expr -> . expr GEQ expr
    (31) expr -> . expr > expr
    (32) expr -> . expr LEQ expr
    (33) expr -> . expr < expr
    (34) expr -> . expr '
    (35) expr -> . - expr
    (36) expr -> . expr MDIVIDE expr
    (37) expr -> . expr MTIMES expr
    (38) expr -> . expr MMINUS expr
    (39) expr -> . expr MPLUS expr
    (40) expr -> . expr / expr
    (41) expr -> . expr * expr
    (42) expr -> . expr - expr
    (43) expr -> . expr + expr
    (44) expr -> . [ matrix ]
    (45) expr -> . [ values ]
    (53) id_expr -> . ID [ values ]
    (54) id_expr -> . ID
    EYE             shift and go to state 23
    ONES            shift and go to state 25
    ZEROS           shift and go to state 26
    STRING          shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    (               shift and go to state 24
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 8

    expr                           shift and go to state 33
    id_expr                        shift and go to state 27

state 11

    (9) action_statement -> BREAK .
    ;               reduce using rule 9 (action_statement -> BREAK .)


state 12

    (10) action_statement -> CONTINUE .
    ;               reduce using rule 10 (action_statement -> CONTINUE .)


state 13

    (11) action_statement -> RETURN . expr
    (20) expr -> . EYE ( expr )
    (21) expr -> . ONES ( expr )
    (22) expr -> . ZEROS ( expr )
    (23) expr -> . id_expr
    (24) expr -> . STRING
    (25) expr -> . FLOAT
    (26) expr -> . INT
    (27) expr -> . ( expr )
    (28) expr -> . expr NEQ expr
    (29) expr -> . expr EQ expr
    (30) expr -> . expr GEQ expr
    (31) expr -> . expr > expr
    (32) expr -> . expr LEQ expr
    (33) expr -> . expr < expr
    (34) expr -> . expr '
    (35) expr -> . - expr
    (36) expr -> . expr MDIVIDE expr
    (37) expr -> . expr MTIMES expr
    (38) expr -> . expr MMINUS expr
    (39) expr -> . expr MPLUS expr
    (40) expr -> . expr / expr
    (41) expr -> . expr * expr
    (42) expr -> . expr - expr
    (43) expr -> . expr + expr
    (44) expr -> . [ matrix ]
    (45) expr -> . [ values ]
    (53) id_expr -> . ID [ values ]
    (54) id_expr -> . ID
    EYE             shift and go to state 23
    ONES            shift and go to state 25
    ZEROS           shift and go to state 26
    STRING          shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    (               shift and go to state 24
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 8

    expr                           shift and go to state 34
    id_expr                        shift and go to state 27

state 14

    (12) action_statement -> PRINT . values
    (18) values -> . expr , values
    (19) values -> . expr
    (20) expr -> . EYE ( expr )
    (21) expr -> . ONES ( expr )
    (22) expr -> . ZEROS ( expr )
    (23) expr -> . id_expr
    (24) expr -> . STRING
    (25) expr -> . FLOAT
    (26) expr -> . INT
    (27) expr -> . ( expr )
    (28) expr -> . expr NEQ expr
    (29) expr -> . expr EQ expr
    (30) expr -> . expr GEQ expr
    (31) expr -> . expr > expr
    (32) expr -> . expr LEQ expr
    (33) expr -> . expr < expr
    (34) expr -> . expr '
    (35) expr -> . - expr
    (36) expr -> . expr MDIVIDE expr
    (37) expr -> . expr MTIMES expr
    (38) expr -> . expr MMINUS expr
    (39) expr -> . expr MPLUS expr
    (40) expr -> . expr / expr
    (41) expr -> . expr * expr
    (42) expr -> . expr - expr
    (43) expr -> . expr + expr
    (44) expr -> . [ matrix ]
    (45) expr -> . [ values ]
    (53) id_expr -> . ID [ values ]
    (54) id_expr -> . ID
    EYE             shift and go to state 23
    ONES            shift and go to state 25
    ZEROS           shift and go to state 26
    STRING          shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    (               shift and go to state 24
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 8

    values                         shift and go to state 35
    expr                           shift and go to state 36
    id_expr                        shift and go to state 27

state 15

    (13) action_statement -> id_expr . DASSIGN expr
    (14) action_statement -> id_expr . TASSIGN expr
    (15) action_statement -> id_expr . MASSIGN expr
    (16) action_statement -> id_expr . PASSIGN expr
    (17) action_statement -> id_expr . = expr
    DASSIGN         shift and go to state 37
    TASSIGN         shift and go to state 38
    MASSIGN         shift and go to state 39
    PASSIGN         shift and go to state 40
    =               shift and go to state 41


state 16

    (1) start -> block start .
    $end            reduce using rule 1 (start -> block start .)


state 17

    (3) block -> { next_statements . }
    }               shift and go to state 42


state 18

    (5) next_statements -> statement . next_statements
    (6) next_statements -> statement .
    (5) next_statements -> . statement next_statements
    (6) next_statements -> . statement
    (7) statement -> . flow_control_statement
    (8) statement -> . action_statement ;
    (48) flow_control_statement -> . FOR ID = range block
    (49) flow_control_statement -> . WHILE expr block
    (50) flow_control_statement -> . IF expr block ELSE block
    (51) flow_control_statement -> . IF expr block
    (9) action_statement -> . BREAK
    (10) action_statement -> . CONTINUE
    (11) action_statement -> . RETURN expr
    (12) action_statement -> . PRINT values
    (13) action_statement -> . id_expr DASSIGN expr
    (14) action_statement -> . id_expr TASSIGN expr
    (15) action_statement -> . id_expr MASSIGN expr
    (16) action_statement -> . id_expr PASSIGN expr
    (17) action_statement -> . id_expr = expr
    (53) id_expr -> . ID [ values ]
    (54) id_expr -> . ID
    }               reduce using rule 6 (next_statements -> statement .)
    FOR             shift and go to state 7
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    BREAK           shift and go to state 11
    CONTINUE        shift and go to state 12
    RETURN          shift and go to state 13
    PRINT           shift and go to state 14
    ID              shift and go to state 8

    statement                      shift and go to state 18
    next_statements                shift and go to state 43
    flow_control_statement         shift and go to state 5
    action_statement               shift and go to state 6
    id_expr                        shift and go to state 15

state 19

    (8) statement -> action_statement ; .
    {               reduce using rule 8 (statement -> action_statement ; .)
    FOR             reduce using rule 8 (statement -> action_statement ; .)
    WHILE           reduce using rule 8 (statement -> action_statement ; .)
    IF              reduce using rule 8 (statement -> action_statement ; .)
    BREAK           reduce using rule 8 (statement -> action_statement ; .)
    CONTINUE        reduce using rule 8 (statement -> action_statement ; .)
    RETURN          reduce using rule 8 (statement -> action_statement ; .)
    PRINT           reduce using rule 8 (statement -> action_statement ; .)
    ID              reduce using rule 8 (statement -> action_statement ; .)
    $end            reduce using rule 8 (statement -> action_statement ; .)
    }               reduce using rule 8 (statement -> action_statement ; .)
    ELSE            reduce using rule 8 (statement -> action_statement ; .)


state 20

    (48) flow_control_statement -> FOR ID . = range block
    =               shift and go to state 44


state 21

    (53) id_expr -> ID [ . values ]
    (18) values -> . expr , values
    (19) values -> . expr
    (20) expr -> . EYE ( expr )
    (21) expr -> . ONES ( expr )
    (22) expr -> . ZEROS ( expr )
    (23) expr -> . id_expr
    (24) expr -> . STRING
    (25) expr -> . FLOAT
    (26) expr -> . INT
    (27) expr -> . ( expr )
    (28) expr -> . expr NEQ expr
    (29) expr -> . expr EQ expr
    (30) expr -> . expr GEQ expr
    (31) expr -> . expr > expr
    (32) expr -> . expr LEQ expr
    (33) expr -> . expr < expr
    (34) expr -> . expr '
    (35) expr -> . - expr
    (36) expr -> . expr MDIVIDE expr
    (37) expr -> . expr MTIMES expr
    (38) expr -> . expr MMINUS expr
    (39) expr -> . expr MPLUS expr
    (40) expr -> . expr / expr
    (41) expr -> . expr * expr
    (42) expr -> . expr - expr
    (43) expr -> . expr + expr
    (44) expr -> . [ matrix ]
    (45) expr -> . [ values ]
    (53) id_expr -> . ID [ values ]
    (54) id_expr -> . ID
    EYE             shift and go to state 23
    ONES            shift and go to state 25
    ZEROS           shift and go to state 26
    STRING          shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    (               shift and go to state 24
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 8

    values                         shift and go to state 45
    expr                           shift and go to state 36
    id_expr                        shift and go to state 27

state 22

    (49) flow_control_statement -> WHILE expr . block
    (28) expr -> expr . NEQ expr
    (29) expr -> expr . EQ expr
    (30) expr -> expr . GEQ expr
    (31) expr -> expr . > expr
    (32) expr -> expr . LEQ expr
    (33) expr -> expr . < expr
    (34) expr -> expr . '
    (36) expr -> expr . MDIVIDE expr
    (37) expr -> expr . MTIMES expr
    (38) expr -> expr . MMINUS expr
    (39) expr -> expr . MPLUS expr
    (40) expr -> expr . / expr
    (41) expr -> expr . * expr
    (42) expr -> expr . - expr
    (43) expr -> expr . + expr
    (3) block -> . { next_statements }
    (4) block -> . statement
    (7) statement -> . flow_control_statement
    (8) statement -> . action_statement ;
    (48) flow_control_statement -> . FOR ID = range block
    (49) flow_control_statement -> . WHILE expr block
    (50) flow_control_statement -> . IF expr block ELSE block
    (51) flow_control_statement -> . IF expr block
    (9) action_statement -> . BREAK
    (10) action_statement -> . CONTINUE
    (11) action_statement -> . RETURN expr
    (12) action_statement -> . PRINT values
    (13) action_statement -> . id_expr DASSIGN expr
    (14) action_statement -> . id_expr TASSIGN expr
    (15) action_statement -> . id_expr MASSIGN expr
    (16) action_statement -> . id_expr PASSIGN expr
    (17) action_statement -> . id_expr = expr
    (53) id_expr -> . ID [ values ]
    (54) id_expr -> . ID
    NEQ             shift and go to state 47
    EQ              shift and go to state 48
    GEQ             shift and go to state 49
    >               shift and go to state 50
    LEQ             shift and go to state 51
    <               shift and go to state 52
    '               shift and go to state 53
    MDIVIDE         shift and go to state 54
    MTIMES          shift and go to state 55
    MMINUS          shift and go to state 56
    MPLUS           shift and go to state 57
    /               shift and go to state 58
    *               shift and go to state 59
    -               shift and go to state 60
    +               shift and go to state 61
    {               shift and go to state 3
    FOR             shift and go to state 7
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    BREAK           shift and go to state 11
    CONTINUE        shift and go to state 12
    RETURN          shift and go to state 13
    PRINT           shift and go to state 14
    ID              shift and go to state 8

    block                          shift and go to state 46
    statement                      shift and go to state 4
    flow_control_statement         shift and go to state 5
    action_statement               shift and go to state 6
    id_expr                        shift and go to state 15

state 23

    (20) expr -> EYE . ( expr )
    (               shift and go to state 62


state 24

    (27) expr -> ( . expr )
    (20) expr -> . EYE ( expr )
    (21) expr -> . ONES ( expr )
    (22) expr -> . ZEROS ( expr )
    (23) expr -> . id_expr
    (24) expr -> . STRING
    (25) expr -> . FLOAT
    (26) expr -> . INT
    (27) expr -> . ( expr )
    (28) expr -> . expr NEQ expr
    (29) expr -> . expr EQ expr
    (30) expr -> . expr GEQ expr
    (31) expr -> . expr > expr
    (32) expr -> . expr LEQ expr
    (33) expr -> . expr < expr
    (34) expr -> . expr '
    (35) expr -> . - expr
    (36) expr -> . expr MDIVIDE expr
    (37) expr -> . expr MTIMES expr
    (38) expr -> . expr MMINUS expr
    (39) expr -> . expr MPLUS expr
    (40) expr -> . expr / expr
    (41) expr -> . expr * expr
    (42) expr -> . expr - expr
    (43) expr -> . expr + expr
    (44) expr -> . [ matrix ]
    (45) expr -> . [ values ]
    (53) id_expr -> . ID [ values ]
    (54) id_expr -> . ID
    EYE             shift and go to state 23
    ONES            shift and go to state 25
    ZEROS           shift and go to state 26
    STRING          shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    (               shift and go to state 24
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 8

    expr                           shift and go to state 63
    id_expr                        shift and go to state 27

state 25

    (21) expr -> ONES . ( expr )
    (               shift and go to state 64


state 26

    (22) expr -> ZEROS . ( expr )
    (               shift and go to state 65


state 27

    (23) expr -> id_expr .
    NEQ             reduce using rule 23 (expr -> id_expr .)
    EQ              reduce using rule 23 (expr -> id_expr .)
    GEQ             reduce using rule 23 (expr -> id_expr .)
    >               reduce using rule 23 (expr -> id_expr .)
    LEQ             reduce using rule 23 (expr -> id_expr .)
    <               reduce using rule 23 (expr -> id_expr .)
    '               reduce using rule 23 (expr -> id_expr .)
    MDIVIDE         reduce using rule 23 (expr -> id_expr .)
    MTIMES          reduce using rule 23 (expr -> id_expr .)
    MMINUS          reduce using rule 23 (expr -> id_expr .)
    MPLUS           reduce using rule 23 (expr -> id_expr .)
    /               reduce using rule 23 (expr -> id_expr .)
    *               reduce using rule 23 (expr -> id_expr .)
    -               reduce using rule 23 (expr -> id_expr .)
    +               reduce using rule 23 (expr -> id_expr .)
    {               reduce using rule 23 (expr -> id_expr .)
    FOR             reduce using rule 23 (expr -> id_expr .)
    WHILE           reduce using rule 23 (expr -> id_expr .)
    IF              reduce using rule 23 (expr -> id_expr .)
    BREAK           reduce using rule 23 (expr -> id_expr .)
    CONTINUE        reduce using rule 23 (expr -> id_expr .)
    RETURN          reduce using rule 23 (expr -> id_expr .)
    PRINT           reduce using rule 23 (expr -> id_expr .)
    ID              reduce using rule 23 (expr -> id_expr .)
    ;               reduce using rule 23 (expr -> id_expr .)
    ,               reduce using rule 23 (expr -> id_expr .)
    ]               reduce using rule 23 (expr -> id_expr .)
    )               reduce using rule 23 (expr -> id_expr .)
    :               reduce using rule 23 (expr -> id_expr .)


state 28

    (24) expr -> STRING .
    NEQ             reduce using rule 24 (expr -> STRING .)
    EQ              reduce using rule 24 (expr -> STRING .)
    GEQ             reduce using rule 24 (expr -> STRING .)
    >               reduce using rule 24 (expr -> STRING .)
    LEQ             reduce using rule 24 (expr -> STRING .)
    <               reduce using rule 24 (expr -> STRING .)
    '               reduce using rule 24 (expr -> STRING .)
    MDIVIDE         reduce using rule 24 (expr -> STRING .)
    MTIMES          reduce using rule 24 (expr -> STRING .)
    MMINUS          reduce using rule 24 (expr -> STRING .)
    MPLUS           reduce using rule 24 (expr -> STRING .)
    /               reduce using rule 24 (expr -> STRING .)
    *               reduce using rule 24 (expr -> STRING .)
    -               reduce using rule 24 (expr -> STRING .)
    +               reduce using rule 24 (expr -> STRING .)
    {               reduce using rule 24 (expr -> STRING .)
    FOR             reduce using rule 24 (expr -> STRING .)
    WHILE           reduce using rule 24 (expr -> STRING .)
    IF              reduce using rule 24 (expr -> STRING .)
    BREAK           reduce using rule 24 (expr -> STRING .)
    CONTINUE        reduce using rule 24 (expr -> STRING .)
    RETURN          reduce using rule 24 (expr -> STRING .)
    PRINT           reduce using rule 24 (expr -> STRING .)
    ID              reduce using rule 24 (expr -> STRING .)
    ;               reduce using rule 24 (expr -> STRING .)
    ,               reduce using rule 24 (expr -> STRING .)
    ]               reduce using rule 24 (expr -> STRING .)
    )               reduce using rule 24 (expr -> STRING .)
    :               reduce using rule 24 (expr -> STRING .)


state 29

    (25) expr -> FLOAT .
    NEQ             reduce using rule 25 (expr -> FLOAT .)
    EQ              reduce using rule 25 (expr -> FLOAT .)
    GEQ             reduce using rule 25 (expr -> FLOAT .)
    >               reduce using rule 25 (expr -> FLOAT .)
    LEQ             reduce using rule 25 (expr -> FLOAT .)
    <               reduce using rule 25 (expr -> FLOAT .)
    '               reduce using rule 25 (expr -> FLOAT .)
    MDIVIDE         reduce using rule 25 (expr -> FLOAT .)
    MTIMES          reduce using rule 25 (expr -> FLOAT .)
    MMINUS          reduce using rule 25 (expr -> FLOAT .)
    MPLUS           reduce using rule 25 (expr -> FLOAT .)
    /               reduce using rule 25 (expr -> FLOAT .)
    *               reduce using rule 25 (expr -> FLOAT .)
    -               reduce using rule 25 (expr -> FLOAT .)
    +               reduce using rule 25 (expr -> FLOAT .)
    {               reduce using rule 25 (expr -> FLOAT .)
    FOR             reduce using rule 25 (expr -> FLOAT .)
    WHILE           reduce using rule 25 (expr -> FLOAT .)
    IF              reduce using rule 25 (expr -> FLOAT .)
    BREAK           reduce using rule 25 (expr -> FLOAT .)
    CONTINUE        reduce using rule 25 (expr -> FLOAT .)
    RETURN          reduce using rule 25 (expr -> FLOAT .)
    PRINT           reduce using rule 25 (expr -> FLOAT .)
    ID              reduce using rule 25 (expr -> FLOAT .)
    ;               reduce using rule 25 (expr -> FLOAT .)
    ,               reduce using rule 25 (expr -> FLOAT .)
    ]               reduce using rule 25 (expr -> FLOAT .)
    )               reduce using rule 25 (expr -> FLOAT .)
    :               reduce using rule 25 (expr -> FLOAT .)


state 30

    (26) expr -> INT .
    NEQ             reduce using rule 26 (expr -> INT .)
    EQ              reduce using rule 26 (expr -> INT .)
    GEQ             reduce using rule 26 (expr -> INT .)
    >               reduce using rule 26 (expr -> INT .)
    LEQ             reduce using rule 26 (expr -> INT .)
    <               reduce using rule 26 (expr -> INT .)
    '               reduce using rule 26 (expr -> INT .)
    MDIVIDE         reduce using rule 26 (expr -> INT .)
    MTIMES          reduce using rule 26 (expr -> INT .)
    MMINUS          reduce using rule 26 (expr -> INT .)
    MPLUS           reduce using rule 26 (expr -> INT .)
    /               reduce using rule 26 (expr -> INT .)
    *               reduce using rule 26 (expr -> INT .)
    -               reduce using rule 26 (expr -> INT .)
    +               reduce using rule 26 (expr -> INT .)
    {               reduce using rule 26 (expr -> INT .)
    FOR             reduce using rule 26 (expr -> INT .)
    WHILE           reduce using rule 26 (expr -> INT .)
    IF              reduce using rule 26 (expr -> INT .)
    BREAK           reduce using rule 26 (expr -> INT .)
    CONTINUE        reduce using rule 26 (expr -> INT .)
    RETURN          reduce using rule 26 (expr -> INT .)
    PRINT           reduce using rule 26 (expr -> INT .)
    ID              reduce using rule 26 (expr -> INT .)
    ;               reduce using rule 26 (expr -> INT .)
    ,               reduce using rule 26 (expr -> INT .)
    ]               reduce using rule 26 (expr -> INT .)
    )               reduce using rule 26 (expr -> INT .)
    :               reduce using rule 26 (expr -> INT .)


state 31

    (35) expr -> - . expr
    (20) expr -> . EYE ( expr )
    (21) expr -> . ONES ( expr )
    (22) expr -> . ZEROS ( expr )
    (23) expr -> . id_expr
    (24) expr -> . STRING
    (25) expr -> . FLOAT
    (26) expr -> . INT
    (27) expr -> . ( expr )
    (28) expr -> . expr NEQ expr
    (29) expr -> . expr EQ expr
    (30) expr -> . expr GEQ expr
    (31) expr -> . expr > expr
    (32) expr -> . expr LEQ expr
    (33) expr -> . expr < expr
    (34) expr -> . expr '
    (35) expr -> . - expr
    (36) expr -> . expr MDIVIDE expr
    (37) expr -> . expr MTIMES expr
    (38) expr -> . expr MMINUS expr
    (39) expr -> . expr MPLUS expr
    (40) expr -> . expr / expr
    (41) expr -> . expr * expr
    (42) expr -> . expr - expr
    (43) expr -> . expr + expr
    (44) expr -> . [ matrix ]
    (45) expr -> . [ values ]
    (53) id_expr -> . ID [ values ]
    (54) id_expr -> . ID
    EYE             shift and go to state 23
    ONES            shift and go to state 25
    ZEROS           shift and go to state 26
    STRING          shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    (               shift and go to state 24
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 8

    expr                           shift and go to state 66
    id_expr                        shift and go to state 27

state 32

    (44) expr -> [ . matrix ]
    (45) expr -> [ . values ]
    (46) matrix -> . [ values ] , matrix
    (47) matrix -> . [ values ]
    (18) values -> . expr , values
    (19) values -> . expr
    (20) expr -> . EYE ( expr )
    (21) expr -> . ONES ( expr )
    (22) expr -> . ZEROS ( expr )
    (23) expr -> . id_expr
    (24) expr -> . STRING
    (25) expr -> . FLOAT
    (26) expr -> . INT
    (27) expr -> . ( expr )
    (28) expr -> . expr NEQ expr
    (29) expr -> . expr EQ expr
    (30) expr -> . expr GEQ expr
    (31) expr -> . expr > expr
    (32) expr -> . expr LEQ expr
    (33) expr -> . expr < expr
    (34) expr -> . expr '
    (35) expr -> . - expr
    (36) expr -> . expr MDIVIDE expr
    (37) expr -> . expr MTIMES expr
    (38) expr -> . expr MMINUS expr
    (39) expr -> . expr MPLUS expr
    (40) expr -> . expr / expr
    (41) expr -> . expr * expr
    (42) expr -> . expr - expr
    (43) expr -> . expr + expr
    (44) expr -> . [ matrix ]
    (45) expr -> . [ values ]
    (53) id_expr -> . ID [ values ]
    (54) id_expr -> . ID
    [               shift and go to state 67
    EYE             shift and go to state 23
    ONES            shift and go to state 25
    ZEROS           shift and go to state 26
    STRING          shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    (               shift and go to state 24
    -               shift and go to state 31
    ID              shift and go to state 8

    matrix                         shift and go to state 68
    values                         shift and go to state 69
    expr                           shift and go to state 36
    id_expr                        shift and go to state 27

state 33

    (50) flow_control_statement -> IF expr . block ELSE block
    (51) flow_control_statement -> IF expr . block
    (28) expr -> expr . NEQ expr
    (29) expr -> expr . EQ expr
    (30) expr -> expr . GEQ expr
    (31) expr -> expr . > expr
    (32) expr -> expr . LEQ expr
    (33) expr -> expr . < expr
    (34) expr -> expr . '
    (36) expr -> expr . MDIVIDE expr
    (37) expr -> expr . MTIMES expr
    (38) expr -> expr . MMINUS expr
    (39) expr -> expr . MPLUS expr
    (40) expr -> expr . / expr
    (41) expr -> expr . * expr
    (42) expr -> expr . - expr
    (43) expr -> expr . + expr
    (3) block -> . { next_statements }
    (4) block -> . statement
    (7) statement -> . flow_control_statement
    (8) statement -> . action_statement ;
    (48) flow_control_statement -> . FOR ID = range block
    (49) flow_control_statement -> . WHILE expr block
    (50) flow_control_statement -> . IF expr block ELSE block
    (51) flow_control_statement -> . IF expr block
    (9) action_statement -> . BREAK
    (10) action_statement -> . CONTINUE
    (11) action_statement -> . RETURN expr
    (12) action_statement -> . PRINT values
    (13) action_statement -> . id_expr DASSIGN expr
    (14) action_statement -> . id_expr TASSIGN expr
    (15) action_statement -> . id_expr MASSIGN expr
    (16) action_statement -> . id_expr PASSIGN expr
    (17) action_statement -> . id_expr = expr
    (53) id_expr -> . ID [ values ]
    (54) id_expr -> . ID
    NEQ             shift and go to state 47
    EQ              shift and go to state 48
    GEQ             shift and go to state 49
    >               shift and go to state 50
    LEQ             shift and go to state 51
    <               shift and go to state 52
    '               shift and go to state 53
    MDIVIDE         shift and go to state 54
    MTIMES          shift and go to state 55
    MMINUS          shift and go to state 56
    MPLUS           shift and go to state 57
    /               shift and go to state 58
    *               shift and go to state 59
    -               shift and go to state 60
    +               shift and go to state 61
    {               shift and go to state 3
    FOR             shift and go to state 7
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    BREAK           shift and go to state 11
    CONTINUE        shift and go to state 12
    RETURN          shift and go to state 13
    PRINT           shift and go to state 14
    ID              shift and go to state 8

    block                          shift and go to state 70
    statement                      shift and go to state 4
    flow_control_statement         shift and go to state 5
    action_statement               shift and go to state 6
    id_expr                        shift and go to state 15

state 34

    (11) action_statement -> RETURN expr .
    (28) expr -> expr . NEQ expr
    (29) expr -> expr . EQ expr
    (30) expr -> expr . GEQ expr
    (31) expr -> expr . > expr
    (32) expr -> expr . LEQ expr
    (33) expr -> expr . < expr
    (34) expr -> expr . '
    (36) expr -> expr . MDIVIDE expr
    (37) expr -> expr . MTIMES expr
    (38) expr -> expr . MMINUS expr
    (39) expr -> expr . MPLUS expr
    (40) expr -> expr . / expr
    (41) expr -> expr . * expr
    (42) expr -> expr . - expr
    (43) expr -> expr . + expr
    ;               reduce using rule 11 (action_statement -> RETURN expr .)
    NEQ             shift and go to state 47
    EQ              shift and go to state 48
    GEQ             shift and go to state 49
    >               shift and go to state 50
    LEQ             shift and go to state 51
    <               shift and go to state 52
    '               shift and go to state 53
    MDIVIDE         shift and go to state 54
    MTIMES          shift and go to state 55
    MMINUS          shift and go to state 56
    MPLUS           shift and go to state 57
    /               shift and go to state 58
    *               shift and go to state 59
    -               shift and go to state 60
    +               shift and go to state 61


state 35

    (12) action_statement -> PRINT values .
    ;               reduce using rule 12 (action_statement -> PRINT values .)


state 36

    (18) values -> expr . , values
    (19) values -> expr .
    (28) expr -> expr . NEQ expr
    (29) expr -> expr . EQ expr
    (30) expr -> expr . GEQ expr
    (31) expr -> expr . > expr
    (32) expr -> expr . LEQ expr
    (33) expr -> expr . < expr
    (34) expr -> expr . '
    (36) expr -> expr . MDIVIDE expr
    (37) expr -> expr . MTIMES expr
    (38) expr -> expr . MMINUS expr
    (39) expr -> expr . MPLUS expr
    (40) expr -> expr . / expr
    (41) expr -> expr . * expr
    (42) expr -> expr . - expr
    (43) expr -> expr . + expr
    ,               shift and go to state 71
    ;               reduce using rule 19 (values -> expr .)
    ]               reduce using rule 19 (values -> expr .)
    NEQ             shift and go to state 47
    EQ              shift and go to state 48
    GEQ             shift and go to state 49
    >               shift and go to state 50
    LEQ             shift and go to state 51
    <               shift and go to state 52
    '               shift and go to state 53
    MDIVIDE         shift and go to state 54
    MTIMES          shift and go to state 55
    MMINUS          shift and go to state 56
    MPLUS           shift and go to state 57
    /               shift and go to state 58
    *               shift and go to state 59
    -               shift and go to state 60
    +               shift and go to state 61


state 37

    (13) action_statement -> id_expr DASSIGN . expr
    (20) expr -> . EYE ( expr )
    (21) expr -> . ONES ( expr )
    (22) expr -> . ZEROS ( expr )
    (23) expr -> . id_expr
    (24) expr -> . STRING
    (25) expr -> . FLOAT
    (26) expr -> . INT
    (27) expr -> . ( expr )
    (28) expr -> . expr NEQ expr
    (29) expr -> . expr EQ expr
    (30) expr -> . expr GEQ expr
    (31) expr -> . expr > expr
    (32) expr -> . expr LEQ expr
    (33) expr -> . expr < expr
    (34) expr -> . expr '
    (35) expr -> . - expr
    (36) expr -> . expr MDIVIDE expr
    (37) expr -> . expr MTIMES expr
    (38) expr -> . expr MMINUS expr
    (39) expr -> . expr MPLUS expr
    (40) expr -> . expr / expr
    (41) expr -> . expr * expr
    (42) expr -> . expr - expr
    (43) expr -> . expr + expr
    (44) expr -> . [ matrix ]
    (45) expr -> . [ values ]
    (53) id_expr -> . ID [ values ]
    (54) id_expr -> . ID
    EYE             shift and go to state 23
    ONES            shift and go to state 25
    ZEROS           shift and go to state 26
    STRING          shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    (               shift and go to state 24
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 8

    id_expr                        shift and go to state 27
    expr                           shift and go to state 72

state 38

    (14) action_statement -> id_expr TASSIGN . expr
    (20) expr -> . EYE ( expr )
    (21) expr -> . ONES ( expr )
    (22) expr -> . ZEROS ( expr )
    (23) expr -> . id_expr
    (24) expr -> . STRING
    (25) expr -> . FLOAT
    (26) expr -> . INT
    (27) expr -> . ( expr )
    (28) expr -> . expr NEQ expr
    (29) expr -> . expr EQ expr
    (30) expr -> . expr GEQ expr
    (31) expr -> . expr > expr
    (32) expr -> . expr LEQ expr
    (33) expr -> . expr < expr
    (34) expr -> . expr '
    (35) expr -> . - expr
    (36) expr -> . expr MDIVIDE expr
    (37) expr -> . expr MTIMES expr
    (38) expr -> . expr MMINUS expr
    (39) expr -> . expr MPLUS expr
    (40) expr -> . expr / expr
    (41) expr -> . expr * expr
    (42) expr -> . expr - expr
    (43) expr -> . expr + expr
    (44) expr -> . [ matrix ]
    (45) expr -> . [ values ]
    (53) id_expr -> . ID [ values ]
    (54) id_expr -> . ID
    EYE             shift and go to state 23
    ONES            shift and go to state 25
    ZEROS           shift and go to state 26
    STRING          shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    (               shift and go to state 24
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 8

    id_expr                        shift and go to state 27
    expr                           shift and go to state 73

state 39

    (15) action_statement -> id_expr MASSIGN . expr
    (20) expr -> . EYE ( expr )
    (21) expr -> . ONES ( expr )
    (22) expr -> . ZEROS ( expr )
    (23) expr -> . id_expr
    (24) expr -> . STRING
    (25) expr -> . FLOAT
    (26) expr -> . INT
    (27) expr -> . ( expr )
    (28) expr -> . expr NEQ expr
    (29) expr -> . expr EQ expr
    (30) expr -> . expr GEQ expr
    (31) expr -> . expr > expr
    (32) expr -> . expr LEQ expr
    (33) expr -> . expr < expr
    (34) expr -> . expr '
    (35) expr -> . - expr
    (36) expr -> . expr MDIVIDE expr
    (37) expr -> . expr MTIMES expr
    (38) expr -> . expr MMINUS expr
    (39) expr -> . expr MPLUS expr
    (40) expr -> . expr / expr
    (41) expr -> . expr * expr
    (42) expr -> . expr - expr
    (43) expr -> . expr + expr
    (44) expr -> . [ matrix ]
    (45) expr -> . [ values ]
    (53) id_expr -> . ID [ values ]
    (54) id_expr -> . ID
    EYE             shift and go to state 23
    ONES            shift and go to state 25
    ZEROS           shift and go to state 26
    STRING          shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    (               shift and go to state 24
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 8

    id_expr                        shift and go to state 27
    expr                           shift and go to state 74

state 40

    (16) action_statement -> id_expr PASSIGN . expr
    (20) expr -> . EYE ( expr )
    (21) expr -> . ONES ( expr )
    (22) expr -> . ZEROS ( expr )
    (23) expr -> . id_expr
    (24) expr -> . STRING
    (25) expr -> . FLOAT
    (26) expr -> . INT
    (27) expr -> . ( expr )
    (28) expr -> . expr NEQ expr
    (29) expr -> . expr EQ expr
    (30) expr -> . expr GEQ expr
    (31) expr -> . expr > expr
    (32) expr -> . expr LEQ expr
    (33) expr -> . expr < expr
    (34) expr -> . expr '
    (35) expr -> . - expr
    (36) expr -> . expr MDIVIDE expr
    (37) expr -> . expr MTIMES expr
    (38) expr -> . expr MMINUS expr
    (39) expr -> . expr MPLUS expr
    (40) expr -> . expr / expr
    (41) expr -> . expr * expr
    (42) expr -> . expr - expr
    (43) expr -> . expr + expr
    (44) expr -> . [ matrix ]
    (45) expr -> . [ values ]
    (53) id_expr -> . ID [ values ]
    (54) id_expr -> . ID
    EYE             shift and go to state 23
    ONES            shift and go to state 25
    ZEROS           shift and go to state 26
    STRING          shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    (               shift and go to state 24
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 8

    id_expr                        shift and go to state 27
    expr                           shift and go to state 75

state 41

    (17) action_statement -> id_expr = . expr
    (20) expr -> . EYE ( expr )
    (21) expr -> . ONES ( expr )
    (22) expr -> . ZEROS ( expr )
    (23) expr -> . id_expr
    (24) expr -> . STRING
    (25) expr -> . FLOAT
    (26) expr -> . INT
    (27) expr -> . ( expr )
    (28) expr -> . expr NEQ expr
    (29) expr -> . expr EQ expr
    (30) expr -> . expr GEQ expr
    (31) expr -> . expr > expr
    (32) expr -> . expr LEQ expr
    (33) expr -> . expr < expr
    (34) expr -> . expr '
    (35) expr -> . - expr
    (36) expr -> . expr MDIVIDE expr
    (37) expr -> . expr MTIMES expr
    (38) expr -> . expr MMINUS expr
    (39) expr -> . expr MPLUS expr
    (40) expr -> . expr / expr
    (41) expr -> . expr * expr
    (42) expr -> . expr - expr
    (43) expr -> . expr + expr
    (44) expr -> . [ matrix ]
    (45) expr -> . [ values ]
    (53) id_expr -> . ID [ values ]
    (54) id_expr -> . ID
    EYE             shift and go to state 23
    ONES            shift and go to state 25
    ZEROS           shift and go to state 26
    STRING          shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    (               shift and go to state 24
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 8

    id_expr                        shift and go to state 27
    expr                           shift and go to state 76

state 42

    (3) block -> { next_statements } .
    {               reduce using rule 3 (block -> { next_statements } .)
    FOR             reduce using rule 3 (block -> { next_statements } .)
    WHILE           reduce using rule 3 (block -> { next_statements } .)
    IF              reduce using rule 3 (block -> { next_statements } .)
    BREAK           reduce using rule 3 (block -> { next_statements } .)
    CONTINUE        reduce using rule 3 (block -> { next_statements } .)
    RETURN          reduce using rule 3 (block -> { next_statements } .)
    PRINT           reduce using rule 3 (block -> { next_statements } .)
    ID              reduce using rule 3 (block -> { next_statements } .)
    $end            reduce using rule 3 (block -> { next_statements } .)
    }               reduce using rule 3 (block -> { next_statements } .)
    ELSE            reduce using rule 3 (block -> { next_statements } .)


state 43

    (5) next_statements -> statement next_statements .
    }               reduce using rule 5 (next_statements -> statement next_statements .)


state 44

    (48) flow_control_statement -> FOR ID = . range block
    (52) range -> . expr : expr
    (20) expr -> . EYE ( expr )
    (21) expr -> . ONES ( expr )
    (22) expr -> . ZEROS ( expr )
    (23) expr -> . id_expr
    (24) expr -> . STRING
    (25) expr -> . FLOAT
    (26) expr -> . INT
    (27) expr -> . ( expr )
    (28) expr -> . expr NEQ expr
    (29) expr -> . expr EQ expr
    (30) expr -> . expr GEQ expr
    (31) expr -> . expr > expr
    (32) expr -> . expr LEQ expr
    (33) expr -> . expr < expr
    (34) expr -> . expr '
    (35) expr -> . - expr
    (36) expr -> . expr MDIVIDE expr
    (37) expr -> . expr MTIMES expr
    (38) expr -> . expr MMINUS expr
    (39) expr -> . expr MPLUS expr
    (40) expr -> . expr / expr
    (41) expr -> . expr * expr
    (42) expr -> . expr - expr
    (43) expr -> . expr + expr
    (44) expr -> . [ matrix ]
    (45) expr -> . [ values ]
    (53) id_expr -> . ID [ values ]
    (54) id_expr -> . ID
    EYE             shift and go to state 23
    ONES            shift and go to state 25
    ZEROS           shift and go to state 26
    STRING          shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    (               shift and go to state 24
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 8

    range                          shift and go to state 77
    expr                           shift and go to state 78
    id_expr                        shift and go to state 27

state 45

    (53) id_expr -> ID [ values . ]
    ]               shift and go to state 79


state 46

    (49) flow_control_statement -> WHILE expr block .
    {               reduce using rule 49 (flow_control_statement -> WHILE expr block .)
    FOR             reduce using rule 49 (flow_control_statement -> WHILE expr block .)
    WHILE           reduce using rule 49 (flow_control_statement -> WHILE expr block .)
    IF              reduce using rule 49 (flow_control_statement -> WHILE expr block .)
    BREAK           reduce using rule 49 (flow_control_statement -> WHILE expr block .)
    CONTINUE        reduce using rule 49 (flow_control_statement -> WHILE expr block .)
    RETURN          reduce using rule 49 (flow_control_statement -> WHILE expr block .)
    PRINT           reduce using rule 49 (flow_control_statement -> WHILE expr block .)
    ID              reduce using rule 49 (flow_control_statement -> WHILE expr block .)
    $end            reduce using rule 49 (flow_control_statement -> WHILE expr block .)
    }               reduce using rule 49 (flow_control_statement -> WHILE expr block .)
    ELSE            reduce using rule 49 (flow_control_statement -> WHILE expr block .)


state 47

    (28) expr -> expr NEQ . expr
    (20) expr -> . EYE ( expr )
    (21) expr -> . ONES ( expr )
    (22) expr -> . ZEROS ( expr )
    (23) expr -> . id_expr
    (24) expr -> . STRING
    (25) expr -> . FLOAT
    (26) expr -> . INT
    (27) expr -> . ( expr )
    (28) expr -> . expr NEQ expr
    (29) expr -> . expr EQ expr
    (30) expr -> . expr GEQ expr
    (31) expr -> . expr > expr
    (32) expr -> . expr LEQ expr
    (33) expr -> . expr < expr
    (34) expr -> . expr '
    (35) expr -> . - expr
    (36) expr -> . expr MDIVIDE expr
    (37) expr -> . expr MTIMES expr
    (38) expr -> . expr MMINUS expr
    (39) expr -> . expr MPLUS expr
    (40) expr -> . expr / expr
    (41) expr -> . expr * expr
    (42) expr -> . expr - expr
    (43) expr -> . expr + expr
    (44) expr -> . [ matrix ]
    (45) expr -> . [ values ]
    (53) id_expr -> . ID [ values ]
    (54) id_expr -> . ID
    EYE             shift and go to state 23
    ONES            shift and go to state 25
    ZEROS           shift and go to state 26
    STRING          shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    (               shift and go to state 24
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 8

    expr                           shift and go to state 80
    id_expr                        shift and go to state 27

state 48

    (29) expr -> expr EQ . expr
    (20) expr -> . EYE ( expr )
    (21) expr -> . ONES ( expr )
    (22) expr -> . ZEROS ( expr )
    (23) expr -> . id_expr
    (24) expr -> . STRING
    (25) expr -> . FLOAT
    (26) expr -> . INT
    (27) expr -> . ( expr )
    (28) expr -> . expr NEQ expr
    (29) expr -> . expr EQ expr
    (30) expr -> . expr GEQ expr
    (31) expr -> . expr > expr
    (32) expr -> . expr LEQ expr
    (33) expr -> . expr < expr
    (34) expr -> . expr '
    (35) expr -> . - expr
    (36) expr -> . expr MDIVIDE expr
    (37) expr -> . expr MTIMES expr
    (38) expr -> . expr MMINUS expr
    (39) expr -> . expr MPLUS expr
    (40) expr -> . expr / expr
    (41) expr -> . expr * expr
    (42) expr -> . expr - expr
    (43) expr -> . expr + expr
    (44) expr -> . [ matrix ]
    (45) expr -> . [ values ]
    (53) id_expr -> . ID [ values ]
    (54) id_expr -> . ID
    EYE             shift and go to state 23
    ONES            shift and go to state 25
    ZEROS           shift and go to state 26
    STRING          shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    (               shift and go to state 24
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 8

    expr                           shift and go to state 81
    id_expr                        shift and go to state 27

state 49

    (30) expr -> expr GEQ . expr
    (20) expr -> . EYE ( expr )
    (21) expr -> . ONES ( expr )
    (22) expr -> . ZEROS ( expr )
    (23) expr -> . id_expr
    (24) expr -> . STRING
    (25) expr -> . FLOAT
    (26) expr -> . INT
    (27) expr -> . ( expr )
    (28) expr -> . expr NEQ expr
    (29) expr -> . expr EQ expr
    (30) expr -> . expr GEQ expr
    (31) expr -> . expr > expr
    (32) expr -> . expr LEQ expr
    (33) expr -> . expr < expr
    (34) expr -> . expr '
    (35) expr -> . - expr
    (36) expr -> . expr MDIVIDE expr
    (37) expr -> . expr MTIMES expr
    (38) expr -> . expr MMINUS expr
    (39) expr -> . expr MPLUS expr
    (40) expr -> . expr / expr
    (41) expr -> . expr * expr
    (42) expr -> . expr - expr
    (43) expr -> . expr + expr
    (44) expr -> . [ matrix ]
    (45) expr -> . [ values ]
    (53) id_expr -> . ID [ values ]
    (54) id_expr -> . ID
    EYE             shift and go to state 23
    ONES            shift and go to state 25
    ZEROS           shift and go to state 26
    STRING          shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    (               shift and go to state 24
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 8

    expr                           shift and go to state 82
    id_expr                        shift and go to state 27

state 50

    (31) expr -> expr > . expr
    (20) expr -> . EYE ( expr )
    (21) expr -> . ONES ( expr )
    (22) expr -> . ZEROS ( expr )
    (23) expr -> . id_expr
    (24) expr -> . STRING
    (25) expr -> . FLOAT
    (26) expr -> . INT
    (27) expr -> . ( expr )
    (28) expr -> . expr NEQ expr
    (29) expr -> . expr EQ expr
    (30) expr -> . expr GEQ expr
    (31) expr -> . expr > expr
    (32) expr -> . expr LEQ expr
    (33) expr -> . expr < expr
    (34) expr -> . expr '
    (35) expr -> . - expr
    (36) expr -> . expr MDIVIDE expr
    (37) expr -> . expr MTIMES expr
    (38) expr -> . expr MMINUS expr
    (39) expr -> . expr MPLUS expr
    (40) expr -> . expr / expr
    (41) expr -> . expr * expr
    (42) expr -> . expr - expr
    (43) expr -> . expr + expr
    (44) expr -> . [ matrix ]
    (45) expr -> . [ values ]
    (53) id_expr -> . ID [ values ]
    (54) id_expr -> . ID
    EYE             shift and go to state 23
    ONES            shift and go to state 25
    ZEROS           shift and go to state 26
    STRING          shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    (               shift and go to state 24
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 8

    expr                           shift and go to state 83
    id_expr                        shift and go to state 27

state 51

    (32) expr -> expr LEQ . expr
    (20) expr -> . EYE ( expr )
    (21) expr -> . ONES ( expr )
    (22) expr -> . ZEROS ( expr )
    (23) expr -> . id_expr
    (24) expr -> . STRING
    (25) expr -> . FLOAT
    (26) expr -> . INT
    (27) expr -> . ( expr )
    (28) expr -> . expr NEQ expr
    (29) expr -> . expr EQ expr
    (30) expr -> . expr GEQ expr
    (31) expr -> . expr > expr
    (32) expr -> . expr LEQ expr
    (33) expr -> . expr < expr
    (34) expr -> . expr '
    (35) expr -> . - expr
    (36) expr -> . expr MDIVIDE expr
    (37) expr -> . expr MTIMES expr
    (38) expr -> . expr MMINUS expr
    (39) expr -> . expr MPLUS expr
    (40) expr -> . expr / expr
    (41) expr -> . expr * expr
    (42) expr -> . expr - expr
    (43) expr -> . expr + expr
    (44) expr -> . [ matrix ]
    (45) expr -> . [ values ]
    (53) id_expr -> . ID [ values ]
    (54) id_expr -> . ID
    EYE             shift and go to state 23
    ONES            shift and go to state 25
    ZEROS           shift and go to state 26
    STRING          shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    (               shift and go to state 24
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 8

    expr                           shift and go to state 84
    id_expr                        shift and go to state 27

state 52

    (33) expr -> expr < . expr
    (20) expr -> . EYE ( expr )
    (21) expr -> . ONES ( expr )
    (22) expr -> . ZEROS ( expr )
    (23) expr -> . id_expr
    (24) expr -> . STRING
    (25) expr -> . FLOAT
    (26) expr -> . INT
    (27) expr -> . ( expr )
    (28) expr -> . expr NEQ expr
    (29) expr -> . expr EQ expr
    (30) expr -> . expr GEQ expr
    (31) expr -> . expr > expr
    (32) expr -> . expr LEQ expr
    (33) expr -> . expr < expr
    (34) expr -> . expr '
    (35) expr -> . - expr
    (36) expr -> . expr MDIVIDE expr
    (37) expr -> . expr MTIMES expr
    (38) expr -> . expr MMINUS expr
    (39) expr -> . expr MPLUS expr
    (40) expr -> . expr / expr
    (41) expr -> . expr * expr
    (42) expr -> . expr - expr
    (43) expr -> . expr + expr
    (44) expr -> . [ matrix ]
    (45) expr -> . [ values ]
    (53) id_expr -> . ID [ values ]
    (54) id_expr -> . ID
    EYE             shift and go to state 23
    ONES            shift and go to state 25
    ZEROS           shift and go to state 26
    STRING          shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    (               shift and go to state 24
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 8

    expr                           shift and go to state 85
    id_expr                        shift and go to state 27

state 53

    (34) expr -> expr ' .
    NEQ             reduce using rule 34 (expr -> expr ' .)
    EQ              reduce using rule 34 (expr -> expr ' .)
    GEQ             reduce using rule 34 (expr -> expr ' .)
    >               reduce using rule 34 (expr -> expr ' .)
    LEQ             reduce using rule 34 (expr -> expr ' .)
    <               reduce using rule 34 (expr -> expr ' .)
    '               reduce using rule 34 (expr -> expr ' .)
    MDIVIDE         reduce using rule 34 (expr -> expr ' .)
    MTIMES          reduce using rule 34 (expr -> expr ' .)
    MMINUS          reduce using rule 34 (expr -> expr ' .)
    MPLUS           reduce using rule 34 (expr -> expr ' .)
    /               reduce using rule 34 (expr -> expr ' .)
    *               reduce using rule 34 (expr -> expr ' .)
    -               reduce using rule 34 (expr -> expr ' .)
    +               reduce using rule 34 (expr -> expr ' .)
    {               reduce using rule 34 (expr -> expr ' .)
    FOR             reduce using rule 34 (expr -> expr ' .)
    WHILE           reduce using rule 34 (expr -> expr ' .)
    IF              reduce using rule 34 (expr -> expr ' .)
    BREAK           reduce using rule 34 (expr -> expr ' .)
    CONTINUE        reduce using rule 34 (expr -> expr ' .)
    RETURN          reduce using rule 34 (expr -> expr ' .)
    PRINT           reduce using rule 34 (expr -> expr ' .)
    ID              reduce using rule 34 (expr -> expr ' .)
    ;               reduce using rule 34 (expr -> expr ' .)
    ,               reduce using rule 34 (expr -> expr ' .)
    ]               reduce using rule 34 (expr -> expr ' .)
    )               reduce using rule 34 (expr -> expr ' .)
    :               reduce using rule 34 (expr -> expr ' .)


state 54

    (36) expr -> expr MDIVIDE . expr
    (20) expr -> . EYE ( expr )
    (21) expr -> . ONES ( expr )
    (22) expr -> . ZEROS ( expr )
    (23) expr -> . id_expr
    (24) expr -> . STRING
    (25) expr -> . FLOAT
    (26) expr -> . INT
    (27) expr -> . ( expr )
    (28) expr -> . expr NEQ expr
    (29) expr -> . expr EQ expr
    (30) expr -> . expr GEQ expr
    (31) expr -> . expr > expr
    (32) expr -> . expr LEQ expr
    (33) expr -> . expr < expr
    (34) expr -> . expr '
    (35) expr -> . - expr
    (36) expr -> . expr MDIVIDE expr
    (37) expr -> . expr MTIMES expr
    (38) expr -> . expr MMINUS expr
    (39) expr -> . expr MPLUS expr
    (40) expr -> . expr / expr
    (41) expr -> . expr * expr
    (42) expr -> . expr - expr
    (43) expr -> . expr + expr
    (44) expr -> . [ matrix ]
    (45) expr -> . [ values ]
    (53) id_expr -> . ID [ values ]
    (54) id_expr -> . ID
    EYE             shift and go to state 23
    ONES            shift and go to state 25
    ZEROS           shift and go to state 26
    STRING          shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    (               shift and go to state 24
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 8

    expr                           shift and go to state 86
    id_expr                        shift and go to state 27

state 55

    (37) expr -> expr MTIMES . expr
    (20) expr -> . EYE ( expr )
    (21) expr -> . ONES ( expr )
    (22) expr -> . ZEROS ( expr )
    (23) expr -> . id_expr
    (24) expr -> . STRING
    (25) expr -> . FLOAT
    (26) expr -> . INT
    (27) expr -> . ( expr )
    (28) expr -> . expr NEQ expr
    (29) expr -> . expr EQ expr
    (30) expr -> . expr GEQ expr
    (31) expr -> . expr > expr
    (32) expr -> . expr LEQ expr
    (33) expr -> . expr < expr
    (34) expr -> . expr '
    (35) expr -> . - expr
    (36) expr -> . expr MDIVIDE expr
    (37) expr -> . expr MTIMES expr
    (38) expr -> . expr MMINUS expr
    (39) expr -> . expr MPLUS expr
    (40) expr -> . expr / expr
    (41) expr -> . expr * expr
    (42) expr -> . expr - expr
    (43) expr -> . expr + expr
    (44) expr -> . [ matrix ]
    (45) expr -> . [ values ]
    (53) id_expr -> . ID [ values ]
    (54) id_expr -> . ID
    EYE             shift and go to state 23
    ONES            shift and go to state 25
    ZEROS           shift and go to state 26
    STRING          shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    (               shift and go to state 24
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 8

    expr                           shift and go to state 87
    id_expr                        shift and go to state 27

state 56

    (38) expr -> expr MMINUS . expr
    (20) expr -> . EYE ( expr )
    (21) expr -> . ONES ( expr )
    (22) expr -> . ZEROS ( expr )
    (23) expr -> . id_expr
    (24) expr -> . STRING
    (25) expr -> . FLOAT
    (26) expr -> . INT
    (27) expr -> . ( expr )
    (28) expr -> . expr NEQ expr
    (29) expr -> . expr EQ expr
    (30) expr -> . expr GEQ expr
    (31) expr -> . expr > expr
    (32) expr -> . expr LEQ expr
    (33) expr -> . expr < expr
    (34) expr -> . expr '
    (35) expr -> . - expr
    (36) expr -> . expr MDIVIDE expr
    (37) expr -> . expr MTIMES expr
    (38) expr -> . expr MMINUS expr
    (39) expr -> . expr MPLUS expr
    (40) expr -> . expr / expr
    (41) expr -> . expr * expr
    (42) expr -> . expr - expr
    (43) expr -> . expr + expr
    (44) expr -> . [ matrix ]
    (45) expr -> . [ values ]
    (53) id_expr -> . ID [ values ]
    (54) id_expr -> . ID
    EYE             shift and go to state 23
    ONES            shift and go to state 25
    ZEROS           shift and go to state 26
    STRING          shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    (               shift and go to state 24
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 8

    expr                           shift and go to state 88
    id_expr                        shift and go to state 27

state 57

    (39) expr -> expr MPLUS . expr
    (20) expr -> . EYE ( expr )
    (21) expr -> . ONES ( expr )
    (22) expr -> . ZEROS ( expr )
    (23) expr -> . id_expr
    (24) expr -> . STRING
    (25) expr -> . FLOAT
    (26) expr -> . INT
    (27) expr -> . ( expr )
    (28) expr -> . expr NEQ expr
    (29) expr -> . expr EQ expr
    (30) expr -> . expr GEQ expr
    (31) expr -> . expr > expr
    (32) expr -> . expr LEQ expr
    (33) expr -> . expr < expr
    (34) expr -> . expr '
    (35) expr -> . - expr
    (36) expr -> . expr MDIVIDE expr
    (37) expr -> . expr MTIMES expr
    (38) expr -> . expr MMINUS expr
    (39) expr -> . expr MPLUS expr
    (40) expr -> . expr / expr
    (41) expr -> . expr * expr
    (42) expr -> . expr - expr
    (43) expr -> . expr + expr
    (44) expr -> . [ matrix ]
    (45) expr -> . [ values ]
    (53) id_expr -> . ID [ values ]
    (54) id_expr -> . ID
    EYE             shift and go to state 23
    ONES            shift and go to state 25
    ZEROS           shift and go to state 26
    STRING          shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    (               shift and go to state 24
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 8

    expr                           shift and go to state 89
    id_expr                        shift and go to state 27

state 58

    (40) expr -> expr / . expr
    (20) expr -> . EYE ( expr )
    (21) expr -> . ONES ( expr )
    (22) expr -> . ZEROS ( expr )
    (23) expr -> . id_expr
    (24) expr -> . STRING
    (25) expr -> . FLOAT
    (26) expr -> . INT
    (27) expr -> . ( expr )
    (28) expr -> . expr NEQ expr
    (29) expr -> . expr EQ expr
    (30) expr -> . expr GEQ expr
    (31) expr -> . expr > expr
    (32) expr -> . expr LEQ expr
    (33) expr -> . expr < expr
    (34) expr -> . expr '
    (35) expr -> . - expr
    (36) expr -> . expr MDIVIDE expr
    (37) expr -> . expr MTIMES expr
    (38) expr -> . expr MMINUS expr
    (39) expr -> . expr MPLUS expr
    (40) expr -> . expr / expr
    (41) expr -> . expr * expr
    (42) expr -> . expr - expr
    (43) expr -> . expr + expr
    (44) expr -> . [ matrix ]
    (45) expr -> . [ values ]
    (53) id_expr -> . ID [ values ]
    (54) id_expr -> . ID
    EYE             shift and go to state 23
    ONES            shift and go to state 25
    ZEROS           shift and go to state 26
    STRING          shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    (               shift and go to state 24
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 8

    expr                           shift and go to state 90
    id_expr                        shift and go to state 27

state 59

    (41) expr -> expr * . expr
    (20) expr -> . EYE ( expr )
    (21) expr -> . ONES ( expr )
    (22) expr -> . ZEROS ( expr )
    (23) expr -> . id_expr
    (24) expr -> . STRING
    (25) expr -> . FLOAT
    (26) expr -> . INT
    (27) expr -> . ( expr )
    (28) expr -> . expr NEQ expr
    (29) expr -> . expr EQ expr
    (30) expr -> . expr GEQ expr
    (31) expr -> . expr > expr
    (32) expr -> . expr LEQ expr
    (33) expr -> . expr < expr
    (34) expr -> . expr '
    (35) expr -> . - expr
    (36) expr -> . expr MDIVIDE expr
    (37) expr -> . expr MTIMES expr
    (38) expr -> . expr MMINUS expr
    (39) expr -> . expr MPLUS expr
    (40) expr -> . expr / expr
    (41) expr -> . expr * expr
    (42) expr -> . expr - expr
    (43) expr -> . expr + expr
    (44) expr -> . [ matrix ]
    (45) expr -> . [ values ]
    (53) id_expr -> . ID [ values ]
    (54) id_expr -> . ID
    EYE             shift and go to state 23
    ONES            shift and go to state 25
    ZEROS           shift and go to state 26
    STRING          shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    (               shift and go to state 24
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 8

    expr                           shift and go to state 91
    id_expr                        shift and go to state 27

state 60

    (42) expr -> expr - . expr
    (20) expr -> . EYE ( expr )
    (21) expr -> . ONES ( expr )
    (22) expr -> . ZEROS ( expr )
    (23) expr -> . id_expr
    (24) expr -> . STRING
    (25) expr -> . FLOAT
    (26) expr -> . INT
    (27) expr -> . ( expr )
    (28) expr -> . expr NEQ expr
    (29) expr -> . expr EQ expr
    (30) expr -> . expr GEQ expr
    (31) expr -> . expr > expr
    (32) expr -> . expr LEQ expr
    (33) expr -> . expr < expr
    (34) expr -> . expr '
    (35) expr -> . - expr
    (36) expr -> . expr MDIVIDE expr
    (37) expr -> . expr MTIMES expr
    (38) expr -> . expr MMINUS expr
    (39) expr -> . expr MPLUS expr
    (40) expr -> . expr / expr
    (41) expr -> . expr * expr
    (42) expr -> . expr - expr
    (43) expr -> . expr + expr
    (44) expr -> . [ matrix ]
    (45) expr -> . [ values ]
    (53) id_expr -> . ID [ values ]
    (54) id_expr -> . ID
    EYE             shift and go to state 23
    ONES            shift and go to state 25
    ZEROS           shift and go to state 26
    STRING          shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    (               shift and go to state 24
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 8

    expr                           shift and go to state 92
    id_expr                        shift and go to state 27

state 61

    (43) expr -> expr + . expr
    (20) expr -> . EYE ( expr )
    (21) expr -> . ONES ( expr )
    (22) expr -> . ZEROS ( expr )
    (23) expr -> . id_expr
    (24) expr -> . STRING
    (25) expr -> . FLOAT
    (26) expr -> . INT
    (27) expr -> . ( expr )
    (28) expr -> . expr NEQ expr
    (29) expr -> . expr EQ expr
    (30) expr -> . expr GEQ expr
    (31) expr -> . expr > expr
    (32) expr -> . expr LEQ expr
    (33) expr -> . expr < expr
    (34) expr -> . expr '
    (35) expr -> . - expr
    (36) expr -> . expr MDIVIDE expr
    (37) expr -> . expr MTIMES expr
    (38) expr -> . expr MMINUS expr
    (39) expr -> . expr MPLUS expr
    (40) expr -> . expr / expr
    (41) expr -> . expr * expr
    (42) expr -> . expr - expr
    (43) expr -> . expr + expr
    (44) expr -> . [ matrix ]
    (45) expr -> . [ values ]
    (53) id_expr -> . ID [ values ]
    (54) id_expr -> . ID
    EYE             shift and go to state 23
    ONES            shift and go to state 25
    ZEROS           shift and go to state 26
    STRING          shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    (               shift and go to state 24
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 8

    expr                           shift and go to state 93
    id_expr                        shift and go to state 27

state 62

    (20) expr -> EYE ( . expr )
    (20) expr -> . EYE ( expr )
    (21) expr -> . ONES ( expr )
    (22) expr -> . ZEROS ( expr )
    (23) expr -> . id_expr
    (24) expr -> . STRING
    (25) expr -> . FLOAT
    (26) expr -> . INT
    (27) expr -> . ( expr )
    (28) expr -> . expr NEQ expr
    (29) expr -> . expr EQ expr
    (30) expr -> . expr GEQ expr
    (31) expr -> . expr > expr
    (32) expr -> . expr LEQ expr
    (33) expr -> . expr < expr
    (34) expr -> . expr '
    (35) expr -> . - expr
    (36) expr -> . expr MDIVIDE expr
    (37) expr -> . expr MTIMES expr
    (38) expr -> . expr MMINUS expr
    (39) expr -> . expr MPLUS expr
    (40) expr -> . expr / expr
    (41) expr -> . expr * expr
    (42) expr -> . expr - expr
    (43) expr -> . expr + expr
    (44) expr -> . [ matrix ]
    (45) expr -> . [ values ]
    (53) id_expr -> . ID [ values ]
    (54) id_expr -> . ID
    EYE             shift and go to state 23
    ONES            shift and go to state 25
    ZEROS           shift and go to state 26
    STRING          shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    (               shift and go to state 24
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 8

    expr                           shift and go to state 94
    id_expr                        shift and go to state 27

state 63

    (27) expr -> ( expr . )
    (28) expr -> expr . NEQ expr
    (29) expr -> expr . EQ expr
    (30) expr -> expr . GEQ expr
    (31) expr -> expr . > expr
    (32) expr -> expr . LEQ expr
    (33) expr -> expr . < expr
    (34) expr -> expr . '
    (36) expr -> expr . MDIVIDE expr
    (37) expr -> expr . MTIMES expr
    (38) expr -> expr . MMINUS expr
    (39) expr -> expr . MPLUS expr
    (40) expr -> expr . / expr
    (41) expr -> expr . * expr
    (42) expr -> expr . - expr
    (43) expr -> expr . + expr
    )               shift and go to state 95
    NEQ             shift and go to state 47
    EQ              shift and go to state 48
    GEQ             shift and go to state 49
    >               shift and go to state 50
    LEQ             shift and go to state 51
    <               shift and go to state 52
    '               shift and go to state 53
    MDIVIDE         shift and go to state 54
    MTIMES          shift and go to state 55
    MMINUS          shift and go to state 56
    MPLUS           shift and go to state 57
    /               shift and go to state 58
    *               shift and go to state 59
    -               shift and go to state 60
    +               shift and go to state 61


state 64

    (21) expr -> ONES ( . expr )
    (20) expr -> . EYE ( expr )
    (21) expr -> . ONES ( expr )
    (22) expr -> . ZEROS ( expr )
    (23) expr -> . id_expr
    (24) expr -> . STRING
    (25) expr -> . FLOAT
    (26) expr -> . INT
    (27) expr -> . ( expr )
    (28) expr -> . expr NEQ expr
    (29) expr -> . expr EQ expr
    (30) expr -> . expr GEQ expr
    (31) expr -> . expr > expr
    (32) expr -> . expr LEQ expr
    (33) expr -> . expr < expr
    (34) expr -> . expr '
    (35) expr -> . - expr
    (36) expr -> . expr MDIVIDE expr
    (37) expr -> . expr MTIMES expr
    (38) expr -> . expr MMINUS expr
    (39) expr -> . expr MPLUS expr
    (40) expr -> . expr / expr
    (41) expr -> . expr * expr
    (42) expr -> . expr - expr
    (43) expr -> . expr + expr
    (44) expr -> . [ matrix ]
    (45) expr -> . [ values ]
    (53) id_expr -> . ID [ values ]
    (54) id_expr -> . ID
    EYE             shift and go to state 23
    ONES            shift and go to state 25
    ZEROS           shift and go to state 26
    STRING          shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    (               shift and go to state 24
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 8

    expr                           shift and go to state 96
    id_expr                        shift and go to state 27

state 65

    (22) expr -> ZEROS ( . expr )
    (20) expr -> . EYE ( expr )
    (21) expr -> . ONES ( expr )
    (22) expr -> . ZEROS ( expr )
    (23) expr -> . id_expr
    (24) expr -> . STRING
    (25) expr -> . FLOAT
    (26) expr -> . INT
    (27) expr -> . ( expr )
    (28) expr -> . expr NEQ expr
    (29) expr -> . expr EQ expr
    (30) expr -> . expr GEQ expr
    (31) expr -> . expr > expr
    (32) expr -> . expr LEQ expr
    (33) expr -> . expr < expr
    (34) expr -> . expr '
    (35) expr -> . - expr
    (36) expr -> . expr MDIVIDE expr
    (37) expr -> . expr MTIMES expr
    (38) expr -> . expr MMINUS expr
    (39) expr -> . expr MPLUS expr
    (40) expr -> . expr / expr
    (41) expr -> . expr * expr
    (42) expr -> . expr - expr
    (43) expr -> . expr + expr
    (44) expr -> . [ matrix ]
    (45) expr -> . [ values ]
    (53) id_expr -> . ID [ values ]
    (54) id_expr -> . ID
    EYE             shift and go to state 23
    ONES            shift and go to state 25
    ZEROS           shift and go to state 26
    STRING          shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    (               shift and go to state 24
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 8

    expr                           shift and go to state 97
    id_expr                        shift and go to state 27

state 66

    (35) expr -> - expr .
    (28) expr -> expr . NEQ expr
    (29) expr -> expr . EQ expr
    (30) expr -> expr . GEQ expr
    (31) expr -> expr . > expr
    (32) expr -> expr . LEQ expr
    (33) expr -> expr . < expr
    (34) expr -> expr . '
    (36) expr -> expr . MDIVIDE expr
    (37) expr -> expr . MTIMES expr
    (38) expr -> expr . MMINUS expr
    (39) expr -> expr . MPLUS expr
    (40) expr -> expr . / expr
    (41) expr -> expr . * expr
    (42) expr -> expr . - expr
    (43) expr -> expr . + expr
    NEQ             reduce using rule 35 (expr -> - expr .)
    EQ              reduce using rule 35 (expr -> - expr .)
    GEQ             reduce using rule 35 (expr -> - expr .)
    >               reduce using rule 35 (expr -> - expr .)
    LEQ             reduce using rule 35 (expr -> - expr .)
    <               reduce using rule 35 (expr -> - expr .)
    MDIVIDE         reduce using rule 35 (expr -> - expr .)
    MTIMES          reduce using rule 35 (expr -> - expr .)
    MMINUS          reduce using rule 35 (expr -> - expr .)
    MPLUS           reduce using rule 35 (expr -> - expr .)
    /               reduce using rule 35 (expr -> - expr .)
    *               reduce using rule 35 (expr -> - expr .)
    -               reduce using rule 35 (expr -> - expr .)
    +               reduce using rule 35 (expr -> - expr .)
    {               reduce using rule 35 (expr -> - expr .)
    FOR             reduce using rule 35 (expr -> - expr .)
    WHILE           reduce using rule 35 (expr -> - expr .)
    IF              reduce using rule 35 (expr -> - expr .)
    BREAK           reduce using rule 35 (expr -> - expr .)
    CONTINUE        reduce using rule 35 (expr -> - expr .)
    RETURN          reduce using rule 35 (expr -> - expr .)
    PRINT           reduce using rule 35 (expr -> - expr .)
    ID              reduce using rule 35 (expr -> - expr .)
    ;               reduce using rule 35 (expr -> - expr .)
    ,               reduce using rule 35 (expr -> - expr .)
    ]               reduce using rule 35 (expr -> - expr .)
    )               reduce using rule 35 (expr -> - expr .)
    :               reduce using rule 35 (expr -> - expr .)
    '               shift and go to state 53


state 67

    (46) matrix -> [ . values ] , matrix
    (47) matrix -> [ . values ]
    (44) expr -> [ . matrix ]
    (45) expr -> [ . values ]
    (18) values -> . expr , values
    (19) values -> . expr
    (46) matrix -> . [ values ] , matrix
    (47) matrix -> . [ values ]
    (20) expr -> . EYE ( expr )
    (21) expr -> . ONES ( expr )
    (22) expr -> . ZEROS ( expr )
    (23) expr -> . id_expr
    (24) expr -> . STRING
    (25) expr -> . FLOAT
    (26) expr -> . INT
    (27) expr -> . ( expr )
    (28) expr -> . expr NEQ expr
    (29) expr -> . expr EQ expr
    (30) expr -> . expr GEQ expr
    (31) expr -> . expr > expr
    (32) expr -> . expr LEQ expr
    (33) expr -> . expr < expr
    (34) expr -> . expr '
    (35) expr -> . - expr
    (36) expr -> . expr MDIVIDE expr
    (37) expr -> . expr MTIMES expr
    (38) expr -> . expr MMINUS expr
    (39) expr -> . expr MPLUS expr
    (40) expr -> . expr / expr
    (41) expr -> . expr * expr
    (42) expr -> . expr - expr
    (43) expr -> . expr + expr
    (44) expr -> . [ matrix ]
    (45) expr -> . [ values ]
    (53) id_expr -> . ID [ values ]
    (54) id_expr -> . ID
    [               shift and go to state 67
    EYE             shift and go to state 23
    ONES            shift and go to state 25
    ZEROS           shift and go to state 26
    STRING          shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    (               shift and go to state 24
    -               shift and go to state 31
    ID              shift and go to state 8

    values                         shift and go to state 98
    matrix                         shift and go to state 68
    expr                           shift and go to state 36
    id_expr                        shift and go to state 27

state 68

    (44) expr -> [ matrix . ]
    ]               shift and go to state 99


state 69

    (45) expr -> [ values . ]
    ]               shift and go to state 100


state 70

    (50) flow_control_statement -> IF expr block . ELSE block
    (51) flow_control_statement -> IF expr block .
    ELSE            shift and go to state 101
    {               reduce using rule 51 (flow_control_statement -> IF expr block .)
    FOR             reduce using rule 51 (flow_control_statement -> IF expr block .)
    WHILE           reduce using rule 51 (flow_control_statement -> IF expr block .)
    IF              reduce using rule 51 (flow_control_statement -> IF expr block .)
    BREAK           reduce using rule 51 (flow_control_statement -> IF expr block .)
    CONTINUE        reduce using rule 51 (flow_control_statement -> IF expr block .)
    RETURN          reduce using rule 51 (flow_control_statement -> IF expr block .)
    PRINT           reduce using rule 51 (flow_control_statement -> IF expr block .)
    ID              reduce using rule 51 (flow_control_statement -> IF expr block .)
    $end            reduce using rule 51 (flow_control_statement -> IF expr block .)
    }               reduce using rule 51 (flow_control_statement -> IF expr block .)


state 71

    (18) values -> expr , . values
    (18) values -> . expr , values
    (19) values -> . expr
    (20) expr -> . EYE ( expr )
    (21) expr -> . ONES ( expr )
    (22) expr -> . ZEROS ( expr )
    (23) expr -> . id_expr
    (24) expr -> . STRING
    (25) expr -> . FLOAT
    (26) expr -> . INT
    (27) expr -> . ( expr )
    (28) expr -> . expr NEQ expr
    (29) expr -> . expr EQ expr
    (30) expr -> . expr GEQ expr
    (31) expr -> . expr > expr
    (32) expr -> . expr LEQ expr
    (33) expr -> . expr < expr
    (34) expr -> . expr '
    (35) expr -> . - expr
    (36) expr -> . expr MDIVIDE expr
    (37) expr -> . expr MTIMES expr
    (38) expr -> . expr MMINUS expr
    (39) expr -> . expr MPLUS expr
    (40) expr -> . expr / expr
    (41) expr -> . expr * expr
    (42) expr -> . expr - expr
    (43) expr -> . expr + expr
    (44) expr -> . [ matrix ]
    (45) expr -> . [ values ]
    (53) id_expr -> . ID [ values ]
    (54) id_expr -> . ID
    EYE             shift and go to state 23
    ONES            shift and go to state 25
    ZEROS           shift and go to state 26
    STRING          shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    (               shift and go to state 24
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 8

    expr                           shift and go to state 36
    values                         shift and go to state 102
    id_expr                        shift and go to state 27

state 72

    (13) action_statement -> id_expr DASSIGN expr .
    (28) expr -> expr . NEQ expr
    (29) expr -> expr . EQ expr
    (30) expr -> expr . GEQ expr
    (31) expr -> expr . > expr
    (32) expr -> expr . LEQ expr
    (33) expr -> expr . < expr
    (34) expr -> expr . '
    (36) expr -> expr . MDIVIDE expr
    (37) expr -> expr . MTIMES expr
    (38) expr -> expr . MMINUS expr
    (39) expr -> expr . MPLUS expr
    (40) expr -> expr . / expr
    (41) expr -> expr . * expr
    (42) expr -> expr . - expr
    (43) expr -> expr . + expr
    ;               reduce using rule 13 (action_statement -> id_expr DASSIGN expr .)
    NEQ             shift and go to state 47
    EQ              shift and go to state 48
    GEQ             shift and go to state 49
    >               shift and go to state 50
    LEQ             shift and go to state 51
    <               shift and go to state 52
    '               shift and go to state 53
    MDIVIDE         shift and go to state 54
    MTIMES          shift and go to state 55
    MMINUS          shift and go to state 56
    MPLUS           shift and go to state 57
    /               shift and go to state 58
    *               shift and go to state 59
    -               shift and go to state 60
    +               shift and go to state 61


state 73

    (14) action_statement -> id_expr TASSIGN expr .
    (28) expr -> expr . NEQ expr
    (29) expr -> expr . EQ expr
    (30) expr -> expr . GEQ expr
    (31) expr -> expr . > expr
    (32) expr -> expr . LEQ expr
    (33) expr -> expr . < expr
    (34) expr -> expr . '
    (36) expr -> expr . MDIVIDE expr
    (37) expr -> expr . MTIMES expr
    (38) expr -> expr . MMINUS expr
    (39) expr -> expr . MPLUS expr
    (40) expr -> expr . / expr
    (41) expr -> expr . * expr
    (42) expr -> expr . - expr
    (43) expr -> expr . + expr
    ;               reduce using rule 14 (action_statement -> id_expr TASSIGN expr .)
    NEQ             shift and go to state 47
    EQ              shift and go to state 48
    GEQ             shift and go to state 49
    >               shift and go to state 50
    LEQ             shift and go to state 51
    <               shift and go to state 52
    '               shift and go to state 53
    MDIVIDE         shift and go to state 54
    MTIMES          shift and go to state 55
    MMINUS          shift and go to state 56
    MPLUS           shift and go to state 57
    /               shift and go to state 58
    *               shift and go to state 59
    -               shift and go to state 60
    +               shift and go to state 61


state 74

    (15) action_statement -> id_expr MASSIGN expr .
    (28) expr -> expr . NEQ expr
    (29) expr -> expr . EQ expr
    (30) expr -> expr . GEQ expr
    (31) expr -> expr . > expr
    (32) expr -> expr . LEQ expr
    (33) expr -> expr . < expr
    (34) expr -> expr . '
    (36) expr -> expr . MDIVIDE expr
    (37) expr -> expr . MTIMES expr
    (38) expr -> expr . MMINUS expr
    (39) expr -> expr . MPLUS expr
    (40) expr -> expr . / expr
    (41) expr -> expr . * expr
    (42) expr -> expr . - expr
    (43) expr -> expr . + expr
    ;               reduce using rule 15 (action_statement -> id_expr MASSIGN expr .)
    NEQ             shift and go to state 47
    EQ              shift and go to state 48
    GEQ             shift and go to state 49
    >               shift and go to state 50
    LEQ             shift and go to state 51
    <               shift and go to state 52
    '               shift and go to state 53
    MDIVIDE         shift and go to state 54
    MTIMES          shift and go to state 55
    MMINUS          shift and go to state 56
    MPLUS           shift and go to state 57
    /               shift and go to state 58
    *               shift and go to state 59
    -               shift and go to state 60
    +               shift and go to state 61


state 75

    (16) action_statement -> id_expr PASSIGN expr .
    (28) expr -> expr . NEQ expr
    (29) expr -> expr . EQ expr
    (30) expr -> expr . GEQ expr
    (31) expr -> expr . > expr
    (32) expr -> expr . LEQ expr
    (33) expr -> expr . < expr
    (34) expr -> expr . '
    (36) expr -> expr . MDIVIDE expr
    (37) expr -> expr . MTIMES expr
    (38) expr -> expr . MMINUS expr
    (39) expr -> expr . MPLUS expr
    (40) expr -> expr . / expr
    (41) expr -> expr . * expr
    (42) expr -> expr . - expr
    (43) expr -> expr . + expr
    ;               reduce using rule 16 (action_statement -> id_expr PASSIGN expr .)
    NEQ             shift and go to state 47
    EQ              shift and go to state 48
    GEQ             shift and go to state 49
    >               shift and go to state 50
    LEQ             shift and go to state 51
    <               shift and go to state 52
    '               shift and go to state 53
    MDIVIDE         shift and go to state 54
    MTIMES          shift and go to state 55
    MMINUS          shift and go to state 56
    MPLUS           shift and go to state 57
    /               shift and go to state 58
    *               shift and go to state 59
    -               shift and go to state 60
    +               shift and go to state 61


state 76

    (17) action_statement -> id_expr = expr .
    (28) expr -> expr . NEQ expr
    (29) expr -> expr . EQ expr
    (30) expr -> expr . GEQ expr
    (31) expr -> expr . > expr
    (32) expr -> expr . LEQ expr
    (33) expr -> expr . < expr
    (34) expr -> expr . '
    (36) expr -> expr . MDIVIDE expr
    (37) expr -> expr . MTIMES expr
    (38) expr -> expr . MMINUS expr
    (39) expr -> expr . MPLUS expr
    (40) expr -> expr . / expr
    (41) expr -> expr . * expr
    (42) expr -> expr . - expr
    (43) expr -> expr . + expr
    ;               reduce using rule 17 (action_statement -> id_expr = expr .)
    NEQ             shift and go to state 47
    EQ              shift and go to state 48
    GEQ             shift and go to state 49
    >               shift and go to state 50
    LEQ             shift and go to state 51
    <               shift and go to state 52
    '               shift and go to state 53
    MDIVIDE         shift and go to state 54
    MTIMES          shift and go to state 55
    MMINUS          shift and go to state 56
    MPLUS           shift and go to state 57
    /               shift and go to state 58
    *               shift and go to state 59
    -               shift and go to state 60
    +               shift and go to state 61


state 77

    (48) flow_control_statement -> FOR ID = range . block
    (3) block -> . { next_statements }
    (4) block -> . statement
    (7) statement -> . flow_control_statement
    (8) statement -> . action_statement ;
    (48) flow_control_statement -> . FOR ID = range block
    (49) flow_control_statement -> . WHILE expr block
    (50) flow_control_statement -> . IF expr block ELSE block
    (51) flow_control_statement -> . IF expr block
    (9) action_statement -> . BREAK
    (10) action_statement -> . CONTINUE
    (11) action_statement -> . RETURN expr
    (12) action_statement -> . PRINT values
    (13) action_statement -> . id_expr DASSIGN expr
    (14) action_statement -> . id_expr TASSIGN expr
    (15) action_statement -> . id_expr MASSIGN expr
    (16) action_statement -> . id_expr PASSIGN expr
    (17) action_statement -> . id_expr = expr
    (53) id_expr -> . ID [ values ]
    (54) id_expr -> . ID
    {               shift and go to state 3
    FOR             shift and go to state 7
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    BREAK           shift and go to state 11
    CONTINUE        shift and go to state 12
    RETURN          shift and go to state 13
    PRINT           shift and go to state 14
    ID              shift and go to state 8

    block                          shift and go to state 103
    statement                      shift and go to state 4
    flow_control_statement         shift and go to state 5
    action_statement               shift and go to state 6
    id_expr                        shift and go to state 15

state 78

    (52) range -> expr . : expr
    (28) expr -> expr . NEQ expr
    (29) expr -> expr . EQ expr
    (30) expr -> expr . GEQ expr
    (31) expr -> expr . > expr
    (32) expr -> expr . LEQ expr
    (33) expr -> expr . < expr
    (34) expr -> expr . '
    (36) expr -> expr . MDIVIDE expr
    (37) expr -> expr . MTIMES expr
    (38) expr -> expr . MMINUS expr
    (39) expr -> expr . MPLUS expr
    (40) expr -> expr . / expr
    (41) expr -> expr . * expr
    (42) expr -> expr . - expr
    (43) expr -> expr . + expr
    :               shift and go to state 104
    NEQ             shift and go to state 47
    EQ              shift and go to state 48
    GEQ             shift and go to state 49
    >               shift and go to state 50
    LEQ             shift and go to state 51
    <               shift and go to state 52
    '               shift and go to state 53
    MDIVIDE         shift and go to state 54
    MTIMES          shift and go to state 55
    MMINUS          shift and go to state 56
    MPLUS           shift and go to state 57
    /               shift and go to state 58
    *               shift and go to state 59
    -               shift and go to state 60
    +               shift and go to state 61


state 79

    (53) id_expr -> ID [ values ] .
    DASSIGN         reduce using rule 53 (id_expr -> ID [ values ] .)
    TASSIGN         reduce using rule 53 (id_expr -> ID [ values ] .)
    MASSIGN         reduce using rule 53 (id_expr -> ID [ values ] .)
    PASSIGN         reduce using rule 53 (id_expr -> ID [ values ] .)
    =               reduce using rule 53 (id_expr -> ID [ values ] .)
    NEQ             reduce using rule 53 (id_expr -> ID [ values ] .)
    EQ              reduce using rule 53 (id_expr -> ID [ values ] .)
    GEQ             reduce using rule 53 (id_expr -> ID [ values ] .)
    >               reduce using rule 53 (id_expr -> ID [ values ] .)
    LEQ             reduce using rule 53 (id_expr -> ID [ values ] .)
    <               reduce using rule 53 (id_expr -> ID [ values ] .)
    '               reduce using rule 53 (id_expr -> ID [ values ] .)
    MDIVIDE         reduce using rule 53 (id_expr -> ID [ values ] .)
    MTIMES          reduce using rule 53 (id_expr -> ID [ values ] .)
    MMINUS          reduce using rule 53 (id_expr -> ID [ values ] .)
    MPLUS           reduce using rule 53 (id_expr -> ID [ values ] .)
    /               reduce using rule 53 (id_expr -> ID [ values ] .)
    *               reduce using rule 53 (id_expr -> ID [ values ] .)
    -               reduce using rule 53 (id_expr -> ID [ values ] .)
    +               reduce using rule 53 (id_expr -> ID [ values ] .)
    {               reduce using rule 53 (id_expr -> ID [ values ] .)
    FOR             reduce using rule 53 (id_expr -> ID [ values ] .)
    WHILE           reduce using rule 53 (id_expr -> ID [ values ] .)
    IF              reduce using rule 53 (id_expr -> ID [ values ] .)
    BREAK           reduce using rule 53 (id_expr -> ID [ values ] .)
    CONTINUE        reduce using rule 53 (id_expr -> ID [ values ] .)
    RETURN          reduce using rule 53 (id_expr -> ID [ values ] .)
    PRINT           reduce using rule 53 (id_expr -> ID [ values ] .)
    ID              reduce using rule 53 (id_expr -> ID [ values ] .)
    ;               reduce using rule 53 (id_expr -> ID [ values ] .)
    ,               reduce using rule 53 (id_expr -> ID [ values ] .)
    ]               reduce using rule 53 (id_expr -> ID [ values ] .)
    )               reduce using rule 53 (id_expr -> ID [ values ] .)
    :               reduce using rule 53 (id_expr -> ID [ values ] .)


state 80

    (28) expr -> expr NEQ expr .
    (28) expr -> expr . NEQ expr
    (29) expr -> expr . EQ expr
    (30) expr -> expr . GEQ expr
    (31) expr -> expr . > expr
    (32) expr -> expr . LEQ expr
    (33) expr -> expr . < expr
    (34) expr -> expr . '
    (36) expr -> expr . MDIVIDE expr
    (37) expr -> expr . MTIMES expr
    (38) expr -> expr . MMINUS expr
    (39) expr -> expr . MPLUS expr
    (40) expr -> expr . / expr
    (41) expr -> expr . * expr
    (42) expr -> expr . - expr
    (43) expr -> expr . + expr
    NEQ             reduce using rule 28 (expr -> expr NEQ expr .)
    EQ              reduce using rule 28 (expr -> expr NEQ expr .)
    GEQ             reduce using rule 28 (expr -> expr NEQ expr .)
    >               reduce using rule 28 (expr -> expr NEQ expr .)
    LEQ             reduce using rule 28 (expr -> expr NEQ expr .)
    <               reduce using rule 28 (expr -> expr NEQ expr .)
    {               reduce using rule 28 (expr -> expr NEQ expr .)
    FOR             reduce using rule 28 (expr -> expr NEQ expr .)
    WHILE           reduce using rule 28 (expr -> expr NEQ expr .)
    IF              reduce using rule 28 (expr -> expr NEQ expr .)
    BREAK           reduce using rule 28 (expr -> expr NEQ expr .)
    CONTINUE        reduce using rule 28 (expr -> expr NEQ expr .)
    RETURN          reduce using rule 28 (expr -> expr NEQ expr .)
    PRINT           reduce using rule 28 (expr -> expr NEQ expr .)
    ID              reduce using rule 28 (expr -> expr NEQ expr .)
    ;               reduce using rule 28 (expr -> expr NEQ expr .)
    ,               reduce using rule 28 (expr -> expr NEQ expr .)
    ]               reduce using rule 28 (expr -> expr NEQ expr .)
    )               reduce using rule 28 (expr -> expr NEQ expr .)
    :               reduce using rule 28 (expr -> expr NEQ expr .)
    '               shift and go to state 53
    MDIVIDE         shift and go to state 54
    MTIMES          shift and go to state 55
    MMINUS          shift and go to state 56
    MPLUS           shift and go to state 57
    /               shift and go to state 58
    *               shift and go to state 59
    -               shift and go to state 60
    +               shift and go to state 61


state 81

    (29) expr -> expr EQ expr .
    (28) expr -> expr . NEQ expr
    (29) expr -> expr . EQ expr
    (30) expr -> expr . GEQ expr
    (31) expr -> expr . > expr
    (32) expr -> expr . LEQ expr
    (33) expr -> expr . < expr
    (34) expr -> expr . '
    (36) expr -> expr . MDIVIDE expr
    (37) expr -> expr . MTIMES expr
    (38) expr -> expr . MMINUS expr
    (39) expr -> expr . MPLUS expr
    (40) expr -> expr . / expr
    (41) expr -> expr . * expr
    (42) expr -> expr . - expr
    (43) expr -> expr . + expr
    NEQ             reduce using rule 29 (expr -> expr EQ expr .)
    EQ              reduce using rule 29 (expr -> expr EQ expr .)
    GEQ             reduce using rule 29 (expr -> expr EQ expr .)
    >               reduce using rule 29 (expr -> expr EQ expr .)
    LEQ             reduce using rule 29 (expr -> expr EQ expr .)
    <               reduce using rule 29 (expr -> expr EQ expr .)
    {               reduce using rule 29 (expr -> expr EQ expr .)
    FOR             reduce using rule 29 (expr -> expr EQ expr .)
    WHILE           reduce using rule 29 (expr -> expr EQ expr .)
    IF              reduce using rule 29 (expr -> expr EQ expr .)
    BREAK           reduce using rule 29 (expr -> expr EQ expr .)
    CONTINUE        reduce using rule 29 (expr -> expr EQ expr .)
    RETURN          reduce using rule 29 (expr -> expr EQ expr .)
    PRINT           reduce using rule 29 (expr -> expr EQ expr .)
    ID              reduce using rule 29 (expr -> expr EQ expr .)
    ;               reduce using rule 29 (expr -> expr EQ expr .)
    ,               reduce using rule 29 (expr -> expr EQ expr .)
    ]               reduce using rule 29 (expr -> expr EQ expr .)
    )               reduce using rule 29 (expr -> expr EQ expr .)
    :               reduce using rule 29 (expr -> expr EQ expr .)
    '               shift and go to state 53
    MDIVIDE         shift and go to state 54
    MTIMES          shift and go to state 55
    MMINUS          shift and go to state 56
    MPLUS           shift and go to state 57
    /               shift and go to state 58
    *               shift and go to state 59
    -               shift and go to state 60
    +               shift and go to state 61


state 82

    (30) expr -> expr GEQ expr .
    (28) expr -> expr . NEQ expr
    (29) expr -> expr . EQ expr
    (30) expr -> expr . GEQ expr
    (31) expr -> expr . > expr
    (32) expr -> expr . LEQ expr
    (33) expr -> expr . < expr
    (34) expr -> expr . '
    (36) expr -> expr . MDIVIDE expr
    (37) expr -> expr . MTIMES expr
    (38) expr -> expr . MMINUS expr
    (39) expr -> expr . MPLUS expr
    (40) expr -> expr . / expr
    (41) expr -> expr . * expr
    (42) expr -> expr . - expr
    (43) expr -> expr . + expr
    NEQ             reduce using rule 30 (expr -> expr GEQ expr .)
    EQ              reduce using rule 30 (expr -> expr GEQ expr .)
    GEQ             reduce using rule 30 (expr -> expr GEQ expr .)
    >               reduce using rule 30 (expr -> expr GEQ expr .)
    LEQ             reduce using rule 30 (expr -> expr GEQ expr .)
    <               reduce using rule 30 (expr -> expr GEQ expr .)
    {               reduce using rule 30 (expr -> expr GEQ expr .)
    FOR             reduce using rule 30 (expr -> expr GEQ expr .)
    WHILE           reduce using rule 30 (expr -> expr GEQ expr .)
    IF              reduce using rule 30 (expr -> expr GEQ expr .)
    BREAK           reduce using rule 30 (expr -> expr GEQ expr .)
    CONTINUE        reduce using rule 30 (expr -> expr GEQ expr .)
    RETURN          reduce using rule 30 (expr -> expr GEQ expr .)
    PRINT           reduce using rule 30 (expr -> expr GEQ expr .)
    ID              reduce using rule 30 (expr -> expr GEQ expr .)
    ;               reduce using rule 30 (expr -> expr GEQ expr .)
    ,               reduce using rule 30 (expr -> expr GEQ expr .)
    ]               reduce using rule 30 (expr -> expr GEQ expr .)
    )               reduce using rule 30 (expr -> expr GEQ expr .)
    :               reduce using rule 30 (expr -> expr GEQ expr .)
    '               shift and go to state 53
    MDIVIDE         shift and go to state 54
    MTIMES          shift and go to state 55
    MMINUS          shift and go to state 56
    MPLUS           shift and go to state 57
    /               shift and go to state 58
    *               shift and go to state 59
    -               shift and go to state 60
    +               shift and go to state 61


state 83

    (31) expr -> expr > expr .
    (28) expr -> expr . NEQ expr
    (29) expr -> expr . EQ expr
    (30) expr -> expr . GEQ expr
    (31) expr -> expr . > expr
    (32) expr -> expr . LEQ expr
    (33) expr -> expr . < expr
    (34) expr -> expr . '
    (36) expr -> expr . MDIVIDE expr
    (37) expr -> expr . MTIMES expr
    (38) expr -> expr . MMINUS expr
    (39) expr -> expr . MPLUS expr
    (40) expr -> expr . / expr
    (41) expr -> expr . * expr
    (42) expr -> expr . - expr
    (43) expr -> expr . + expr
    NEQ             reduce using rule 31 (expr -> expr > expr .)
    EQ              reduce using rule 31 (expr -> expr > expr .)
    GEQ             reduce using rule 31 (expr -> expr > expr .)
    >               reduce using rule 31 (expr -> expr > expr .)
    LEQ             reduce using rule 31 (expr -> expr > expr .)
    <               reduce using rule 31 (expr -> expr > expr .)
    {               reduce using rule 31 (expr -> expr > expr .)
    FOR             reduce using rule 31 (expr -> expr > expr .)
    WHILE           reduce using rule 31 (expr -> expr > expr .)
    IF              reduce using rule 31 (expr -> expr > expr .)
    BREAK           reduce using rule 31 (expr -> expr > expr .)
    CONTINUE        reduce using rule 31 (expr -> expr > expr .)
    RETURN          reduce using rule 31 (expr -> expr > expr .)
    PRINT           reduce using rule 31 (expr -> expr > expr .)
    ID              reduce using rule 31 (expr -> expr > expr .)
    ;               reduce using rule 31 (expr -> expr > expr .)
    ,               reduce using rule 31 (expr -> expr > expr .)
    ]               reduce using rule 31 (expr -> expr > expr .)
    )               reduce using rule 31 (expr -> expr > expr .)
    :               reduce using rule 31 (expr -> expr > expr .)
    '               shift and go to state 53
    MDIVIDE         shift and go to state 54
    MTIMES          shift and go to state 55
    MMINUS          shift and go to state 56
    MPLUS           shift and go to state 57
    /               shift and go to state 58
    *               shift and go to state 59
    -               shift and go to state 60
    +               shift and go to state 61


state 84

    (32) expr -> expr LEQ expr .
    (28) expr -> expr . NEQ expr
    (29) expr -> expr . EQ expr
    (30) expr -> expr . GEQ expr
    (31) expr -> expr . > expr
    (32) expr -> expr . LEQ expr
    (33) expr -> expr . < expr
    (34) expr -> expr . '
    (36) expr -> expr . MDIVIDE expr
    (37) expr -> expr . MTIMES expr
    (38) expr -> expr . MMINUS expr
    (39) expr -> expr . MPLUS expr
    (40) expr -> expr . / expr
    (41) expr -> expr . * expr
    (42) expr -> expr . - expr
    (43) expr -> expr . + expr
    NEQ             reduce using rule 32 (expr -> expr LEQ expr .)
    EQ              reduce using rule 32 (expr -> expr LEQ expr .)
    GEQ             reduce using rule 32 (expr -> expr LEQ expr .)
    >               reduce using rule 32 (expr -> expr LEQ expr .)
    LEQ             reduce using rule 32 (expr -> expr LEQ expr .)
    <               reduce using rule 32 (expr -> expr LEQ expr .)
    {               reduce using rule 32 (expr -> expr LEQ expr .)
    FOR             reduce using rule 32 (expr -> expr LEQ expr .)
    WHILE           reduce using rule 32 (expr -> expr LEQ expr .)
    IF              reduce using rule 32 (expr -> expr LEQ expr .)
    BREAK           reduce using rule 32 (expr -> expr LEQ expr .)
    CONTINUE        reduce using rule 32 (expr -> expr LEQ expr .)
    RETURN          reduce using rule 32 (expr -> expr LEQ expr .)
    PRINT           reduce using rule 32 (expr -> expr LEQ expr .)
    ID              reduce using rule 32 (expr -> expr LEQ expr .)
    ;               reduce using rule 32 (expr -> expr LEQ expr .)
    ,               reduce using rule 32 (expr -> expr LEQ expr .)
    ]               reduce using rule 32 (expr -> expr LEQ expr .)
    )               reduce using rule 32 (expr -> expr LEQ expr .)
    :               reduce using rule 32 (expr -> expr LEQ expr .)
    '               shift and go to state 53
    MDIVIDE         shift and go to state 54
    MTIMES          shift and go to state 55
    MMINUS          shift and go to state 56
    MPLUS           shift and go to state 57
    /               shift and go to state 58
    *               shift and go to state 59
    -               shift and go to state 60
    +               shift and go to state 61


state 85

    (33) expr -> expr < expr .
    (28) expr -> expr . NEQ expr
    (29) expr -> expr . EQ expr
    (30) expr -> expr . GEQ expr
    (31) expr -> expr . > expr
    (32) expr -> expr . LEQ expr
    (33) expr -> expr . < expr
    (34) expr -> expr . '
    (36) expr -> expr . MDIVIDE expr
    (37) expr -> expr . MTIMES expr
    (38) expr -> expr . MMINUS expr
    (39) expr -> expr . MPLUS expr
    (40) expr -> expr . / expr
    (41) expr -> expr . * expr
    (42) expr -> expr . - expr
    (43) expr -> expr . + expr
    NEQ             reduce using rule 33 (expr -> expr < expr .)
    EQ              reduce using rule 33 (expr -> expr < expr .)
    GEQ             reduce using rule 33 (expr -> expr < expr .)
    >               reduce using rule 33 (expr -> expr < expr .)
    LEQ             reduce using rule 33 (expr -> expr < expr .)
    <               reduce using rule 33 (expr -> expr < expr .)
    {               reduce using rule 33 (expr -> expr < expr .)
    FOR             reduce using rule 33 (expr -> expr < expr .)
    WHILE           reduce using rule 33 (expr -> expr < expr .)
    IF              reduce using rule 33 (expr -> expr < expr .)
    BREAK           reduce using rule 33 (expr -> expr < expr .)
    CONTINUE        reduce using rule 33 (expr -> expr < expr .)
    RETURN          reduce using rule 33 (expr -> expr < expr .)
    PRINT           reduce using rule 33 (expr -> expr < expr .)
    ID              reduce using rule 33 (expr -> expr < expr .)
    ;               reduce using rule 33 (expr -> expr < expr .)
    ,               reduce using rule 33 (expr -> expr < expr .)
    ]               reduce using rule 33 (expr -> expr < expr .)
    )               reduce using rule 33 (expr -> expr < expr .)
    :               reduce using rule 33 (expr -> expr < expr .)
    '               shift and go to state 53
    MDIVIDE         shift and go to state 54
    MTIMES          shift and go to state 55
    MMINUS          shift and go to state 56
    MPLUS           shift and go to state 57
    /               shift and go to state 58
    *               shift and go to state 59
    -               shift and go to state 60
    +               shift and go to state 61


state 86

    (36) expr -> expr MDIVIDE expr .
    (28) expr -> expr . NEQ expr
    (29) expr -> expr . EQ expr
    (30) expr -> expr . GEQ expr
    (31) expr -> expr . > expr
    (32) expr -> expr . LEQ expr
    (33) expr -> expr . < expr
    (34) expr -> expr . '
    (36) expr -> expr . MDIVIDE expr
    (37) expr -> expr . MTIMES expr
    (38) expr -> expr . MMINUS expr
    (39) expr -> expr . MPLUS expr
    (40) expr -> expr . / expr
    (41) expr -> expr . * expr
    (42) expr -> expr . - expr
    (43) expr -> expr . + expr
    NEQ             reduce using rule 36 (expr -> expr MDIVIDE expr .)
    EQ              reduce using rule 36 (expr -> expr MDIVIDE expr .)
    GEQ             reduce using rule 36 (expr -> expr MDIVIDE expr .)
    >               reduce using rule 36 (expr -> expr MDIVIDE expr .)
    LEQ             reduce using rule 36 (expr -> expr MDIVIDE expr .)
    <               reduce using rule 36 (expr -> expr MDIVIDE expr .)
    MDIVIDE         reduce using rule 36 (expr -> expr MDIVIDE expr .)
    MTIMES          reduce using rule 36 (expr -> expr MDIVIDE expr .)
    MMINUS          reduce using rule 36 (expr -> expr MDIVIDE expr .)
    MPLUS           reduce using rule 36 (expr -> expr MDIVIDE expr .)
    /               reduce using rule 36 (expr -> expr MDIVIDE expr .)
    *               reduce using rule 36 (expr -> expr MDIVIDE expr .)
    -               reduce using rule 36 (expr -> expr MDIVIDE expr .)
    +               reduce using rule 36 (expr -> expr MDIVIDE expr .)
    {               reduce using rule 36 (expr -> expr MDIVIDE expr .)
    FOR             reduce using rule 36 (expr -> expr MDIVIDE expr .)
    WHILE           reduce using rule 36 (expr -> expr MDIVIDE expr .)
    IF              reduce using rule 36 (expr -> expr MDIVIDE expr .)
    BREAK           reduce using rule 36 (expr -> expr MDIVIDE expr .)
    CONTINUE        reduce using rule 36 (expr -> expr MDIVIDE expr .)
    RETURN          reduce using rule 36 (expr -> expr MDIVIDE expr .)
    PRINT           reduce using rule 36 (expr -> expr MDIVIDE expr .)
    ID              reduce using rule 36 (expr -> expr MDIVIDE expr .)
    ;               reduce using rule 36 (expr -> expr MDIVIDE expr .)
    ,               reduce using rule 36 (expr -> expr MDIVIDE expr .)
    ]               reduce using rule 36 (expr -> expr MDIVIDE expr .)
    )               reduce using rule 36 (expr -> expr MDIVIDE expr .)
    :               reduce using rule 36 (expr -> expr MDIVIDE expr .)
    '               shift and go to state 53


state 87

    (37) expr -> expr MTIMES expr .
    (28) expr -> expr . NEQ expr
    (29) expr -> expr . EQ expr
    (30) expr -> expr . GEQ expr
    (31) expr -> expr . > expr
    (32) expr -> expr . LEQ expr
    (33) expr -> expr . < expr
    (34) expr -> expr . '
    (36) expr -> expr . MDIVIDE expr
    (37) expr -> expr . MTIMES expr
    (38) expr -> expr . MMINUS expr
    (39) expr -> expr . MPLUS expr
    (40) expr -> expr . / expr
    (41) expr -> expr . * expr
    (42) expr -> expr . - expr
    (43) expr -> expr . + expr
    NEQ             reduce using rule 37 (expr -> expr MTIMES expr .)
    EQ              reduce using rule 37 (expr -> expr MTIMES expr .)
    GEQ             reduce using rule 37 (expr -> expr MTIMES expr .)
    >               reduce using rule 37 (expr -> expr MTIMES expr .)
    LEQ             reduce using rule 37 (expr -> expr MTIMES expr .)
    <               reduce using rule 37 (expr -> expr MTIMES expr .)
    MDIVIDE         reduce using rule 37 (expr -> expr MTIMES expr .)
    MTIMES          reduce using rule 37 (expr -> expr MTIMES expr .)
    MMINUS          reduce using rule 37 (expr -> expr MTIMES expr .)
    MPLUS           reduce using rule 37 (expr -> expr MTIMES expr .)
    /               reduce using rule 37 (expr -> expr MTIMES expr .)
    *               reduce using rule 37 (expr -> expr MTIMES expr .)
    -               reduce using rule 37 (expr -> expr MTIMES expr .)
    +               reduce using rule 37 (expr -> expr MTIMES expr .)
    {               reduce using rule 37 (expr -> expr MTIMES expr .)
    FOR             reduce using rule 37 (expr -> expr MTIMES expr .)
    WHILE           reduce using rule 37 (expr -> expr MTIMES expr .)
    IF              reduce using rule 37 (expr -> expr MTIMES expr .)
    BREAK           reduce using rule 37 (expr -> expr MTIMES expr .)
    CONTINUE        reduce using rule 37 (expr -> expr MTIMES expr .)
    RETURN          reduce using rule 37 (expr -> expr MTIMES expr .)
    PRINT           reduce using rule 37 (expr -> expr MTIMES expr .)
    ID              reduce using rule 37 (expr -> expr MTIMES expr .)
    ;               reduce using rule 37 (expr -> expr MTIMES expr .)
    ,               reduce using rule 37 (expr -> expr MTIMES expr .)
    ]               reduce using rule 37 (expr -> expr MTIMES expr .)
    )               reduce using rule 37 (expr -> expr MTIMES expr .)
    :               reduce using rule 37 (expr -> expr MTIMES expr .)
    '               shift and go to state 53


state 88

    (38) expr -> expr MMINUS expr .
    (28) expr -> expr . NEQ expr
    (29) expr -> expr . EQ expr
    (30) expr -> expr . GEQ expr
    (31) expr -> expr . > expr
    (32) expr -> expr . LEQ expr
    (33) expr -> expr . < expr
    (34) expr -> expr . '
    (36) expr -> expr . MDIVIDE expr
    (37) expr -> expr . MTIMES expr
    (38) expr -> expr . MMINUS expr
    (39) expr -> expr . MPLUS expr
    (40) expr -> expr . / expr
    (41) expr -> expr . * expr
    (42) expr -> expr . - expr
    (43) expr -> expr . + expr
    NEQ             reduce using rule 38 (expr -> expr MMINUS expr .)
    EQ              reduce using rule 38 (expr -> expr MMINUS expr .)
    GEQ             reduce using rule 38 (expr -> expr MMINUS expr .)
    >               reduce using rule 38 (expr -> expr MMINUS expr .)
    LEQ             reduce using rule 38 (expr -> expr MMINUS expr .)
    <               reduce using rule 38 (expr -> expr MMINUS expr .)
    MMINUS          reduce using rule 38 (expr -> expr MMINUS expr .)
    MPLUS           reduce using rule 38 (expr -> expr MMINUS expr .)
    -               reduce using rule 38 (expr -> expr MMINUS expr .)
    +               reduce using rule 38 (expr -> expr MMINUS expr .)
    {               reduce using rule 38 (expr -> expr MMINUS expr .)
    FOR             reduce using rule 38 (expr -> expr MMINUS expr .)
    WHILE           reduce using rule 38 (expr -> expr MMINUS expr .)
    IF              reduce using rule 38 (expr -> expr MMINUS expr .)
    BREAK           reduce using rule 38 (expr -> expr MMINUS expr .)
    CONTINUE        reduce using rule 38 (expr -> expr MMINUS expr .)
    RETURN          reduce using rule 38 (expr -> expr MMINUS expr .)
    PRINT           reduce using rule 38 (expr -> expr MMINUS expr .)
    ID              reduce using rule 38 (expr -> expr MMINUS expr .)
    ;               reduce using rule 38 (expr -> expr MMINUS expr .)
    ,               reduce using rule 38 (expr -> expr MMINUS expr .)
    ]               reduce using rule 38 (expr -> expr MMINUS expr .)
    )               reduce using rule 38 (expr -> expr MMINUS expr .)
    :               reduce using rule 38 (expr -> expr MMINUS expr .)
    '               shift and go to state 53
    MDIVIDE         shift and go to state 54
    MTIMES          shift and go to state 55
    /               shift and go to state 58
    *               shift and go to state 59


state 89

    (39) expr -> expr MPLUS expr .
    (28) expr -> expr . NEQ expr
    (29) expr -> expr . EQ expr
    (30) expr -> expr . GEQ expr
    (31) expr -> expr . > expr
    (32) expr -> expr . LEQ expr
    (33) expr -> expr . < expr
    (34) expr -> expr . '
    (36) expr -> expr . MDIVIDE expr
    (37) expr -> expr . MTIMES expr
    (38) expr -> expr . MMINUS expr
    (39) expr -> expr . MPLUS expr
    (40) expr -> expr . / expr
    (41) expr -> expr . * expr
    (42) expr -> expr . - expr
    (43) expr -> expr . + expr
    NEQ             reduce using rule 39 (expr -> expr MPLUS expr .)
    EQ              reduce using rule 39 (expr -> expr MPLUS expr .)
    GEQ             reduce using rule 39 (expr -> expr MPLUS expr .)
    >               reduce using rule 39 (expr -> expr MPLUS expr .)
    LEQ             reduce using rule 39 (expr -> expr MPLUS expr .)
    <               reduce using rule 39 (expr -> expr MPLUS expr .)
    MMINUS          reduce using rule 39 (expr -> expr MPLUS expr .)
    MPLUS           reduce using rule 39 (expr -> expr MPLUS expr .)
    -               reduce using rule 39 (expr -> expr MPLUS expr .)
    +               reduce using rule 39 (expr -> expr MPLUS expr .)
    {               reduce using rule 39 (expr -> expr MPLUS expr .)
    FOR             reduce using rule 39 (expr -> expr MPLUS expr .)
    WHILE           reduce using rule 39 (expr -> expr MPLUS expr .)
    IF              reduce using rule 39 (expr -> expr MPLUS expr .)
    BREAK           reduce using rule 39 (expr -> expr MPLUS expr .)
    CONTINUE        reduce using rule 39 (expr -> expr MPLUS expr .)
    RETURN          reduce using rule 39 (expr -> expr MPLUS expr .)
    PRINT           reduce using rule 39 (expr -> expr MPLUS expr .)
    ID              reduce using rule 39 (expr -> expr MPLUS expr .)
    ;               reduce using rule 39 (expr -> expr MPLUS expr .)
    ,               reduce using rule 39 (expr -> expr MPLUS expr .)
    ]               reduce using rule 39 (expr -> expr MPLUS expr .)
    )               reduce using rule 39 (expr -> expr MPLUS expr .)
    :               reduce using rule 39 (expr -> expr MPLUS expr .)
    '               shift and go to state 53
    MDIVIDE         shift and go to state 54
    MTIMES          shift and go to state 55
    /               shift and go to state 58
    *               shift and go to state 59


state 90

    (40) expr -> expr / expr .
    (28) expr -> expr . NEQ expr
    (29) expr -> expr . EQ expr
    (30) expr -> expr . GEQ expr
    (31) expr -> expr . > expr
    (32) expr -> expr . LEQ expr
    (33) expr -> expr . < expr
    (34) expr -> expr . '
    (36) expr -> expr . MDIVIDE expr
    (37) expr -> expr . MTIMES expr
    (38) expr -> expr . MMINUS expr
    (39) expr -> expr . MPLUS expr
    (40) expr -> expr . / expr
    (41) expr -> expr . * expr
    (42) expr -> expr . - expr
    (43) expr -> expr . + expr
    NEQ             reduce using rule 40 (expr -> expr / expr .)
    EQ              reduce using rule 40 (expr -> expr / expr .)
    GEQ             reduce using rule 40 (expr -> expr / expr .)
    >               reduce using rule 40 (expr -> expr / expr .)
    LEQ             reduce using rule 40 (expr -> expr / expr .)
    <               reduce using rule 40 (expr -> expr / expr .)
    MDIVIDE         reduce using rule 40 (expr -> expr / expr .)
    MTIMES          reduce using rule 40 (expr -> expr / expr .)
    MMINUS          reduce using rule 40 (expr -> expr / expr .)
    MPLUS           reduce using rule 40 (expr -> expr / expr .)
    /               reduce using rule 40 (expr -> expr / expr .)
    *               reduce using rule 40 (expr -> expr / expr .)
    -               reduce using rule 40 (expr -> expr / expr .)
    +               reduce using rule 40 (expr -> expr / expr .)
    {               reduce using rule 40 (expr -> expr / expr .)
    FOR             reduce using rule 40 (expr -> expr / expr .)
    WHILE           reduce using rule 40 (expr -> expr / expr .)
    IF              reduce using rule 40 (expr -> expr / expr .)
    BREAK           reduce using rule 40 (expr -> expr / expr .)
    CONTINUE        reduce using rule 40 (expr -> expr / expr .)
    RETURN          reduce using rule 40 (expr -> expr / expr .)
    PRINT           reduce using rule 40 (expr -> expr / expr .)
    ID              reduce using rule 40 (expr -> expr / expr .)
    ;               reduce using rule 40 (expr -> expr / expr .)
    ,               reduce using rule 40 (expr -> expr / expr .)
    ]               reduce using rule 40 (expr -> expr / expr .)
    )               reduce using rule 40 (expr -> expr / expr .)
    :               reduce using rule 40 (expr -> expr / expr .)
    '               shift and go to state 53


state 91

    (41) expr -> expr * expr .
    (28) expr -> expr . NEQ expr
    (29) expr -> expr . EQ expr
    (30) expr -> expr . GEQ expr
    (31) expr -> expr . > expr
    (32) expr -> expr . LEQ expr
    (33) expr -> expr . < expr
    (34) expr -> expr . '
    (36) expr -> expr . MDIVIDE expr
    (37) expr -> expr . MTIMES expr
    (38) expr -> expr . MMINUS expr
    (39) expr -> expr . MPLUS expr
    (40) expr -> expr . / expr
    (41) expr -> expr . * expr
    (42) expr -> expr . - expr
    (43) expr -> expr . + expr
    NEQ             reduce using rule 41 (expr -> expr * expr .)
    EQ              reduce using rule 41 (expr -> expr * expr .)
    GEQ             reduce using rule 41 (expr -> expr * expr .)
    >               reduce using rule 41 (expr -> expr * expr .)
    LEQ             reduce using rule 41 (expr -> expr * expr .)
    <               reduce using rule 41 (expr -> expr * expr .)
    MDIVIDE         reduce using rule 41 (expr -> expr * expr .)
    MTIMES          reduce using rule 41 (expr -> expr * expr .)
    MMINUS          reduce using rule 41 (expr -> expr * expr .)
    MPLUS           reduce using rule 41 (expr -> expr * expr .)
    /               reduce using rule 41 (expr -> expr * expr .)
    *               reduce using rule 41 (expr -> expr * expr .)
    -               reduce using rule 41 (expr -> expr * expr .)
    +               reduce using rule 41 (expr -> expr * expr .)
    {               reduce using rule 41 (expr -> expr * expr .)
    FOR             reduce using rule 41 (expr -> expr * expr .)
    WHILE           reduce using rule 41 (expr -> expr * expr .)
    IF              reduce using rule 41 (expr -> expr * expr .)
    BREAK           reduce using rule 41 (expr -> expr * expr .)
    CONTINUE        reduce using rule 41 (expr -> expr * expr .)
    RETURN          reduce using rule 41 (expr -> expr * expr .)
    PRINT           reduce using rule 41 (expr -> expr * expr .)
    ID              reduce using rule 41 (expr -> expr * expr .)
    ;               reduce using rule 41 (expr -> expr * expr .)
    ,               reduce using rule 41 (expr -> expr * expr .)
    ]               reduce using rule 41 (expr -> expr * expr .)
    )               reduce using rule 41 (expr -> expr * expr .)
    :               reduce using rule 41 (expr -> expr * expr .)
    '               shift and go to state 53


state 92

    (42) expr -> expr - expr .
    (28) expr -> expr . NEQ expr
    (29) expr -> expr . EQ expr
    (30) expr -> expr . GEQ expr
    (31) expr -> expr . > expr
    (32) expr -> expr . LEQ expr
    (33) expr -> expr . < expr
    (34) expr -> expr . '
    (36) expr -> expr . MDIVIDE expr
    (37) expr -> expr . MTIMES expr
    (38) expr -> expr . MMINUS expr
    (39) expr -> expr . MPLUS expr
    (40) expr -> expr . / expr
    (41) expr -> expr . * expr
    (42) expr -> expr . - expr
    (43) expr -> expr . + expr
    NEQ             reduce using rule 42 (expr -> expr - expr .)
    EQ              reduce using rule 42 (expr -> expr - expr .)
    GEQ             reduce using rule 42 (expr -> expr - expr .)
    >               reduce using rule 42 (expr -> expr - expr .)
    LEQ             reduce using rule 42 (expr -> expr - expr .)
    <               reduce using rule 42 (expr -> expr - expr .)
    MMINUS          reduce using rule 42 (expr -> expr - expr .)
    MPLUS           reduce using rule 42 (expr -> expr - expr .)
    -               reduce using rule 42 (expr -> expr - expr .)
    +               reduce using rule 42 (expr -> expr - expr .)
    {               reduce using rule 42 (expr -> expr - expr .)
    FOR             reduce using rule 42 (expr -> expr - expr .)
    WHILE           reduce using rule 42 (expr -> expr - expr .)
    IF              reduce using rule 42 (expr -> expr - expr .)
    BREAK           reduce using rule 42 (expr -> expr - expr .)
    CONTINUE        reduce using rule 42 (expr -> expr - expr .)
    RETURN          reduce using rule 42 (expr -> expr - expr .)
    PRINT           reduce using rule 42 (expr -> expr - expr .)
    ID              reduce using rule 42 (expr -> expr - expr .)
    ;               reduce using rule 42 (expr -> expr - expr .)
    ,               reduce using rule 42 (expr -> expr - expr .)
    ]               reduce using rule 42 (expr -> expr - expr .)
    )               reduce using rule 42 (expr -> expr - expr .)
    :               reduce using rule 42 (expr -> expr - expr .)
    '               shift and go to state 53
    MDIVIDE         shift and go to state 54
    MTIMES          shift and go to state 55
    /               shift and go to state 58
    *               shift and go to state 59


state 93

    (43) expr -> expr + expr .
    (28) expr -> expr . NEQ expr
    (29) expr -> expr . EQ expr
    (30) expr -> expr . GEQ expr
    (31) expr -> expr . > expr
    (32) expr -> expr . LEQ expr
    (33) expr -> expr . < expr
    (34) expr -> expr . '
    (36) expr -> expr . MDIVIDE expr
    (37) expr -> expr . MTIMES expr
    (38) expr -> expr . MMINUS expr
    (39) expr -> expr . MPLUS expr
    (40) expr -> expr . / expr
    (41) expr -> expr . * expr
    (42) expr -> expr . - expr
    (43) expr -> expr . + expr
    NEQ             reduce using rule 43 (expr -> expr + expr .)
    EQ              reduce using rule 43 (expr -> expr + expr .)
    GEQ             reduce using rule 43 (expr -> expr + expr .)
    >               reduce using rule 43 (expr -> expr + expr .)
    LEQ             reduce using rule 43 (expr -> expr + expr .)
    <               reduce using rule 43 (expr -> expr + expr .)
    MMINUS          reduce using rule 43 (expr -> expr + expr .)
    MPLUS           reduce using rule 43 (expr -> expr + expr .)
    -               reduce using rule 43 (expr -> expr + expr .)
    +               reduce using rule 43 (expr -> expr + expr .)
    {               reduce using rule 43 (expr -> expr + expr .)
    FOR             reduce using rule 43 (expr -> expr + expr .)
    WHILE           reduce using rule 43 (expr -> expr + expr .)
    IF              reduce using rule 43 (expr -> expr + expr .)
    BREAK           reduce using rule 43 (expr -> expr + expr .)
    CONTINUE        reduce using rule 43 (expr -> expr + expr .)
    RETURN          reduce using rule 43 (expr -> expr + expr .)
    PRINT           reduce using rule 43 (expr -> expr + expr .)
    ID              reduce using rule 43 (expr -> expr + expr .)
    ;               reduce using rule 43 (expr -> expr + expr .)
    ,               reduce using rule 43 (expr -> expr + expr .)
    ]               reduce using rule 43 (expr -> expr + expr .)
    )               reduce using rule 43 (expr -> expr + expr .)
    :               reduce using rule 43 (expr -> expr + expr .)
    '               shift and go to state 53
    MDIVIDE         shift and go to state 54
    MTIMES          shift and go to state 55
    /               shift and go to state 58
    *               shift and go to state 59


state 94

    (20) expr -> EYE ( expr . )
    (28) expr -> expr . NEQ expr
    (29) expr -> expr . EQ expr
    (30) expr -> expr . GEQ expr
    (31) expr -> expr . > expr
    (32) expr -> expr . LEQ expr
    (33) expr -> expr . < expr
    (34) expr -> expr . '
    (36) expr -> expr . MDIVIDE expr
    (37) expr -> expr . MTIMES expr
    (38) expr -> expr . MMINUS expr
    (39) expr -> expr . MPLUS expr
    (40) expr -> expr . / expr
    (41) expr -> expr . * expr
    (42) expr -> expr . - expr
    (43) expr -> expr . + expr
    )               shift and go to state 105
    NEQ             shift and go to state 47
    EQ              shift and go to state 48
    GEQ             shift and go to state 49
    >               shift and go to state 50
    LEQ             shift and go to state 51
    <               shift and go to state 52
    '               shift and go to state 53
    MDIVIDE         shift and go to state 54
    MTIMES          shift and go to state 55
    MMINUS          shift and go to state 56
    MPLUS           shift and go to state 57
    /               shift and go to state 58
    *               shift and go to state 59
    -               shift and go to state 60
    +               shift and go to state 61


state 95

    (27) expr -> ( expr ) .
    NEQ             reduce using rule 27 (expr -> ( expr ) .)
    EQ              reduce using rule 27 (expr -> ( expr ) .)
    GEQ             reduce using rule 27 (expr -> ( expr ) .)
    >               reduce using rule 27 (expr -> ( expr ) .)
    LEQ             reduce using rule 27 (expr -> ( expr ) .)
    <               reduce using rule 27 (expr -> ( expr ) .)
    '               reduce using rule 27 (expr -> ( expr ) .)
    MDIVIDE         reduce using rule 27 (expr -> ( expr ) .)
    MTIMES          reduce using rule 27 (expr -> ( expr ) .)
    MMINUS          reduce using rule 27 (expr -> ( expr ) .)
    MPLUS           reduce using rule 27 (expr -> ( expr ) .)
    /               reduce using rule 27 (expr -> ( expr ) .)
    *               reduce using rule 27 (expr -> ( expr ) .)
    -               reduce using rule 27 (expr -> ( expr ) .)
    +               reduce using rule 27 (expr -> ( expr ) .)
    {               reduce using rule 27 (expr -> ( expr ) .)
    FOR             reduce using rule 27 (expr -> ( expr ) .)
    WHILE           reduce using rule 27 (expr -> ( expr ) .)
    IF              reduce using rule 27 (expr -> ( expr ) .)
    BREAK           reduce using rule 27 (expr -> ( expr ) .)
    CONTINUE        reduce using rule 27 (expr -> ( expr ) .)
    RETURN          reduce using rule 27 (expr -> ( expr ) .)
    PRINT           reduce using rule 27 (expr -> ( expr ) .)
    ID              reduce using rule 27 (expr -> ( expr ) .)
    ;               reduce using rule 27 (expr -> ( expr ) .)
    ,               reduce using rule 27 (expr -> ( expr ) .)
    ]               reduce using rule 27 (expr -> ( expr ) .)
    )               reduce using rule 27 (expr -> ( expr ) .)
    :               reduce using rule 27 (expr -> ( expr ) .)


state 96

    (21) expr -> ONES ( expr . )
    (28) expr -> expr . NEQ expr
    (29) expr -> expr . EQ expr
    (30) expr -> expr . GEQ expr
    (31) expr -> expr . > expr
    (32) expr -> expr . LEQ expr
    (33) expr -> expr . < expr
    (34) expr -> expr . '
    (36) expr -> expr . MDIVIDE expr
    (37) expr -> expr . MTIMES expr
    (38) expr -> expr . MMINUS expr
    (39) expr -> expr . MPLUS expr
    (40) expr -> expr . / expr
    (41) expr -> expr . * expr
    (42) expr -> expr . - expr
    (43) expr -> expr . + expr
    )               shift and go to state 106
    NEQ             shift and go to state 47
    EQ              shift and go to state 48
    GEQ             shift and go to state 49
    >               shift and go to state 50
    LEQ             shift and go to state 51
    <               shift and go to state 52
    '               shift and go to state 53
    MDIVIDE         shift and go to state 54
    MTIMES          shift and go to state 55
    MMINUS          shift and go to state 56
    MPLUS           shift and go to state 57
    /               shift and go to state 58
    *               shift and go to state 59
    -               shift and go to state 60
    +               shift and go to state 61


state 97

    (22) expr -> ZEROS ( expr . )
    (28) expr -> expr . NEQ expr
    (29) expr -> expr . EQ expr
    (30) expr -> expr . GEQ expr
    (31) expr -> expr . > expr
    (32) expr -> expr . LEQ expr
    (33) expr -> expr . < expr
    (34) expr -> expr . '
    (36) expr -> expr . MDIVIDE expr
    (37) expr -> expr . MTIMES expr
    (38) expr -> expr . MMINUS expr
    (39) expr -> expr . MPLUS expr
    (40) expr -> expr . / expr
    (41) expr -> expr . * expr
    (42) expr -> expr . - expr
    (43) expr -> expr . + expr
    )               shift and go to state 107
    NEQ             shift and go to state 47
    EQ              shift and go to state 48
    GEQ             shift and go to state 49
    >               shift and go to state 50
    LEQ             shift and go to state 51
    <               shift and go to state 52
    '               shift and go to state 53
    MDIVIDE         shift and go to state 54
    MTIMES          shift and go to state 55
    MMINUS          shift and go to state 56
    MPLUS           shift and go to state 57
    /               shift and go to state 58
    *               shift and go to state 59
    -               shift and go to state 60
    +               shift and go to state 61


state 98

    (46) matrix -> [ values . ] , matrix
    (47) matrix -> [ values . ]
    (45) expr -> [ values . ]
    ]               shift and go to state 108


state 99

    (44) expr -> [ matrix ] .
    NEQ             reduce using rule 44 (expr -> [ matrix ] .)
    EQ              reduce using rule 44 (expr -> [ matrix ] .)
    GEQ             reduce using rule 44 (expr -> [ matrix ] .)
    >               reduce using rule 44 (expr -> [ matrix ] .)
    LEQ             reduce using rule 44 (expr -> [ matrix ] .)
    <               reduce using rule 44 (expr -> [ matrix ] .)
    '               reduce using rule 44 (expr -> [ matrix ] .)
    MDIVIDE         reduce using rule 44 (expr -> [ matrix ] .)
    MTIMES          reduce using rule 44 (expr -> [ matrix ] .)
    MMINUS          reduce using rule 44 (expr -> [ matrix ] .)
    MPLUS           reduce using rule 44 (expr -> [ matrix ] .)
    /               reduce using rule 44 (expr -> [ matrix ] .)
    *               reduce using rule 44 (expr -> [ matrix ] .)
    -               reduce using rule 44 (expr -> [ matrix ] .)
    +               reduce using rule 44 (expr -> [ matrix ] .)
    {               reduce using rule 44 (expr -> [ matrix ] .)
    FOR             reduce using rule 44 (expr -> [ matrix ] .)
    WHILE           reduce using rule 44 (expr -> [ matrix ] .)
    IF              reduce using rule 44 (expr -> [ matrix ] .)
    BREAK           reduce using rule 44 (expr -> [ matrix ] .)
    CONTINUE        reduce using rule 44 (expr -> [ matrix ] .)
    RETURN          reduce using rule 44 (expr -> [ matrix ] .)
    PRINT           reduce using rule 44 (expr -> [ matrix ] .)
    ID              reduce using rule 44 (expr -> [ matrix ] .)
    ;               reduce using rule 44 (expr -> [ matrix ] .)
    ,               reduce using rule 44 (expr -> [ matrix ] .)
    ]               reduce using rule 44 (expr -> [ matrix ] .)
    )               reduce using rule 44 (expr -> [ matrix ] .)
    :               reduce using rule 44 (expr -> [ matrix ] .)


state 100

    (45) expr -> [ values ] .
    NEQ             reduce using rule 45 (expr -> [ values ] .)
    EQ              reduce using rule 45 (expr -> [ values ] .)
    GEQ             reduce using rule 45 (expr -> [ values ] .)
    >               reduce using rule 45 (expr -> [ values ] .)
    LEQ             reduce using rule 45 (expr -> [ values ] .)
    <               reduce using rule 45 (expr -> [ values ] .)
    '               reduce using rule 45 (expr -> [ values ] .)
    MDIVIDE         reduce using rule 45 (expr -> [ values ] .)
    MTIMES          reduce using rule 45 (expr -> [ values ] .)
    MMINUS          reduce using rule 45 (expr -> [ values ] .)
    MPLUS           reduce using rule 45 (expr -> [ values ] .)
    /               reduce using rule 45 (expr -> [ values ] .)
    *               reduce using rule 45 (expr -> [ values ] .)
    -               reduce using rule 45 (expr -> [ values ] .)
    +               reduce using rule 45 (expr -> [ values ] .)
    {               reduce using rule 45 (expr -> [ values ] .)
    FOR             reduce using rule 45 (expr -> [ values ] .)
    WHILE           reduce using rule 45 (expr -> [ values ] .)
    IF              reduce using rule 45 (expr -> [ values ] .)
    BREAK           reduce using rule 45 (expr -> [ values ] .)
    CONTINUE        reduce using rule 45 (expr -> [ values ] .)
    RETURN          reduce using rule 45 (expr -> [ values ] .)
    PRINT           reduce using rule 45 (expr -> [ values ] .)
    ID              reduce using rule 45 (expr -> [ values ] .)
    ;               reduce using rule 45 (expr -> [ values ] .)
    ,               reduce using rule 45 (expr -> [ values ] .)
    ]               reduce using rule 45 (expr -> [ values ] .)
    )               reduce using rule 45 (expr -> [ values ] .)
    :               reduce using rule 45 (expr -> [ values ] .)


state 101

    (50) flow_control_statement -> IF expr block ELSE . block
    (3) block -> . { next_statements }
    (4) block -> . statement
    (7) statement -> . flow_control_statement
    (8) statement -> . action_statement ;
    (48) flow_control_statement -> . FOR ID = range block
    (49) flow_control_statement -> . WHILE expr block
    (50) flow_control_statement -> . IF expr block ELSE block
    (51) flow_control_statement -> . IF expr block
    (9) action_statement -> . BREAK
    (10) action_statement -> . CONTINUE
    (11) action_statement -> . RETURN expr
    (12) action_statement -> . PRINT values
    (13) action_statement -> . id_expr DASSIGN expr
    (14) action_statement -> . id_expr TASSIGN expr
    (15) action_statement -> . id_expr MASSIGN expr
    (16) action_statement -> . id_expr PASSIGN expr
    (17) action_statement -> . id_expr = expr
    (53) id_expr -> . ID [ values ]
    (54) id_expr -> . ID
    {               shift and go to state 3
    FOR             shift and go to state 7
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    BREAK           shift and go to state 11
    CONTINUE        shift and go to state 12
    RETURN          shift and go to state 13
    PRINT           shift and go to state 14
    ID              shift and go to state 8

    block                          shift and go to state 109
    statement                      shift and go to state 4
    flow_control_statement         shift and go to state 5
    action_statement               shift and go to state 6
    id_expr                        shift and go to state 15

state 102

    (18) values -> expr , values .
    ;               reduce using rule 18 (values -> expr , values .)
    ]               reduce using rule 18 (values -> expr , values .)


state 103

    (48) flow_control_statement -> FOR ID = range block .
    {               reduce using rule 48 (flow_control_statement -> FOR ID = range block .)
    FOR             reduce using rule 48 (flow_control_statement -> FOR ID = range block .)
    WHILE           reduce using rule 48 (flow_control_statement -> FOR ID = range block .)
    IF              reduce using rule 48 (flow_control_statement -> FOR ID = range block .)
    BREAK           reduce using rule 48 (flow_control_statement -> FOR ID = range block .)
    CONTINUE        reduce using rule 48 (flow_control_statement -> FOR ID = range block .)
    RETURN          reduce using rule 48 (flow_control_statement -> FOR ID = range block .)
    PRINT           reduce using rule 48 (flow_control_statement -> FOR ID = range block .)
    ID              reduce using rule 48 (flow_control_statement -> FOR ID = range block .)
    $end            reduce using rule 48 (flow_control_statement -> FOR ID = range block .)
    }               reduce using rule 48 (flow_control_statement -> FOR ID = range block .)
    ELSE            reduce using rule 48 (flow_control_statement -> FOR ID = range block .)


state 104

    (52) range -> expr : . expr
    (20) expr -> . EYE ( expr )
    (21) expr -> . ONES ( expr )
    (22) expr -> . ZEROS ( expr )
    (23) expr -> . id_expr
    (24) expr -> . STRING
    (25) expr -> . FLOAT
    (26) expr -> . INT
    (27) expr -> . ( expr )
    (28) expr -> . expr NEQ expr
    (29) expr -> . expr EQ expr
    (30) expr -> . expr GEQ expr
    (31) expr -> . expr > expr
    (32) expr -> . expr LEQ expr
    (33) expr -> . expr < expr
    (34) expr -> . expr '
    (35) expr -> . - expr
    (36) expr -> . expr MDIVIDE expr
    (37) expr -> . expr MTIMES expr
    (38) expr -> . expr MMINUS expr
    (39) expr -> . expr MPLUS expr
    (40) expr -> . expr / expr
    (41) expr -> . expr * expr
    (42) expr -> . expr - expr
    (43) expr -> . expr + expr
    (44) expr -> . [ matrix ]
    (45) expr -> . [ values ]
    (53) id_expr -> . ID [ values ]
    (54) id_expr -> . ID
    EYE             shift and go to state 23
    ONES            shift and go to state 25
    ZEROS           shift and go to state 26
    STRING          shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    (               shift and go to state 24
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 8

    expr                           shift and go to state 110
    id_expr                        shift and go to state 27

state 105

    (20) expr -> EYE ( expr ) .
    NEQ             reduce using rule 20 (expr -> EYE ( expr ) .)
    EQ              reduce using rule 20 (expr -> EYE ( expr ) .)
    GEQ             reduce using rule 20 (expr -> EYE ( expr ) .)
    >               reduce using rule 20 (expr -> EYE ( expr ) .)
    LEQ             reduce using rule 20 (expr -> EYE ( expr ) .)
    <               reduce using rule 20 (expr -> EYE ( expr ) .)
    '               reduce using rule 20 (expr -> EYE ( expr ) .)
    MDIVIDE         reduce using rule 20 (expr -> EYE ( expr ) .)
    MTIMES          reduce using rule 20 (expr -> EYE ( expr ) .)
    MMINUS          reduce using rule 20 (expr -> EYE ( expr ) .)
    MPLUS           reduce using rule 20 (expr -> EYE ( expr ) .)
    /               reduce using rule 20 (expr -> EYE ( expr ) .)
    *               reduce using rule 20 (expr -> EYE ( expr ) .)
    -               reduce using rule 20 (expr -> EYE ( expr ) .)
    +               reduce using rule 20 (expr -> EYE ( expr ) .)
    {               reduce using rule 20 (expr -> EYE ( expr ) .)
    FOR             reduce using rule 20 (expr -> EYE ( expr ) .)
    WHILE           reduce using rule 20 (expr -> EYE ( expr ) .)
    IF              reduce using rule 20 (expr -> EYE ( expr ) .)
    BREAK           reduce using rule 20 (expr -> EYE ( expr ) .)
    CONTINUE        reduce using rule 20 (expr -> EYE ( expr ) .)
    RETURN          reduce using rule 20 (expr -> EYE ( expr ) .)
    PRINT           reduce using rule 20 (expr -> EYE ( expr ) .)
    ID              reduce using rule 20 (expr -> EYE ( expr ) .)
    ;               reduce using rule 20 (expr -> EYE ( expr ) .)
    ,               reduce using rule 20 (expr -> EYE ( expr ) .)
    ]               reduce using rule 20 (expr -> EYE ( expr ) .)
    )               reduce using rule 20 (expr -> EYE ( expr ) .)
    :               reduce using rule 20 (expr -> EYE ( expr ) .)


state 106

    (21) expr -> ONES ( expr ) .
    NEQ             reduce using rule 21 (expr -> ONES ( expr ) .)
    EQ              reduce using rule 21 (expr -> ONES ( expr ) .)
    GEQ             reduce using rule 21 (expr -> ONES ( expr ) .)
    >               reduce using rule 21 (expr -> ONES ( expr ) .)
    LEQ             reduce using rule 21 (expr -> ONES ( expr ) .)
    <               reduce using rule 21 (expr -> ONES ( expr ) .)
    '               reduce using rule 21 (expr -> ONES ( expr ) .)
    MDIVIDE         reduce using rule 21 (expr -> ONES ( expr ) .)
    MTIMES          reduce using rule 21 (expr -> ONES ( expr ) .)
    MMINUS          reduce using rule 21 (expr -> ONES ( expr ) .)
    MPLUS           reduce using rule 21 (expr -> ONES ( expr ) .)
    /               reduce using rule 21 (expr -> ONES ( expr ) .)
    *               reduce using rule 21 (expr -> ONES ( expr ) .)
    -               reduce using rule 21 (expr -> ONES ( expr ) .)
    +               reduce using rule 21 (expr -> ONES ( expr ) .)
    {               reduce using rule 21 (expr -> ONES ( expr ) .)
    FOR             reduce using rule 21 (expr -> ONES ( expr ) .)
    WHILE           reduce using rule 21 (expr -> ONES ( expr ) .)
    IF              reduce using rule 21 (expr -> ONES ( expr ) .)
    BREAK           reduce using rule 21 (expr -> ONES ( expr ) .)
    CONTINUE        reduce using rule 21 (expr -> ONES ( expr ) .)
    RETURN          reduce using rule 21 (expr -> ONES ( expr ) .)
    PRINT           reduce using rule 21 (expr -> ONES ( expr ) .)
    ID              reduce using rule 21 (expr -> ONES ( expr ) .)
    ;               reduce using rule 21 (expr -> ONES ( expr ) .)
    ,               reduce using rule 21 (expr -> ONES ( expr ) .)
    ]               reduce using rule 21 (expr -> ONES ( expr ) .)
    )               reduce using rule 21 (expr -> ONES ( expr ) .)
    :               reduce using rule 21 (expr -> ONES ( expr ) .)


state 107

    (22) expr -> ZEROS ( expr ) .
    NEQ             reduce using rule 22 (expr -> ZEROS ( expr ) .)
    EQ              reduce using rule 22 (expr -> ZEROS ( expr ) .)
    GEQ             reduce using rule 22 (expr -> ZEROS ( expr ) .)
    >               reduce using rule 22 (expr -> ZEROS ( expr ) .)
    LEQ             reduce using rule 22 (expr -> ZEROS ( expr ) .)
    <               reduce using rule 22 (expr -> ZEROS ( expr ) .)
    '               reduce using rule 22 (expr -> ZEROS ( expr ) .)
    MDIVIDE         reduce using rule 22 (expr -> ZEROS ( expr ) .)
    MTIMES          reduce using rule 22 (expr -> ZEROS ( expr ) .)
    MMINUS          reduce using rule 22 (expr -> ZEROS ( expr ) .)
    MPLUS           reduce using rule 22 (expr -> ZEROS ( expr ) .)
    /               reduce using rule 22 (expr -> ZEROS ( expr ) .)
    *               reduce using rule 22 (expr -> ZEROS ( expr ) .)
    -               reduce using rule 22 (expr -> ZEROS ( expr ) .)
    +               reduce using rule 22 (expr -> ZEROS ( expr ) .)
    {               reduce using rule 22 (expr -> ZEROS ( expr ) .)
    FOR             reduce using rule 22 (expr -> ZEROS ( expr ) .)
    WHILE           reduce using rule 22 (expr -> ZEROS ( expr ) .)
    IF              reduce using rule 22 (expr -> ZEROS ( expr ) .)
    BREAK           reduce using rule 22 (expr -> ZEROS ( expr ) .)
    CONTINUE        reduce using rule 22 (expr -> ZEROS ( expr ) .)
    RETURN          reduce using rule 22 (expr -> ZEROS ( expr ) .)
    PRINT           reduce using rule 22 (expr -> ZEROS ( expr ) .)
    ID              reduce using rule 22 (expr -> ZEROS ( expr ) .)
    ;               reduce using rule 22 (expr -> ZEROS ( expr ) .)
    ,               reduce using rule 22 (expr -> ZEROS ( expr ) .)
    ]               reduce using rule 22 (expr -> ZEROS ( expr ) .)
    )               reduce using rule 22 (expr -> ZEROS ( expr ) .)
    :               reduce using rule 22 (expr -> ZEROS ( expr ) .)


state 108

    (46) matrix -> [ values ] . , matrix
    (47) matrix -> [ values ] .
    (45) expr -> [ values ] .
  ! shift/reduce conflict for , resolved as shift
  ! reduce/reduce conflict for ] resolved using rule 45 (expr -> [ values ] .)
    ,               shift and go to state 111
    NEQ             reduce using rule 45 (expr -> [ values ] .)
    EQ              reduce using rule 45 (expr -> [ values ] .)
    GEQ             reduce using rule 45 (expr -> [ values ] .)
    >               reduce using rule 45 (expr -> [ values ] .)
    LEQ             reduce using rule 45 (expr -> [ values ] .)
    <               reduce using rule 45 (expr -> [ values ] .)
    '               reduce using rule 45 (expr -> [ values ] .)
    MDIVIDE         reduce using rule 45 (expr -> [ values ] .)
    MTIMES          reduce using rule 45 (expr -> [ values ] .)
    MMINUS          reduce using rule 45 (expr -> [ values ] .)
    MPLUS           reduce using rule 45 (expr -> [ values ] .)
    /               reduce using rule 45 (expr -> [ values ] .)
    *               reduce using rule 45 (expr -> [ values ] .)
    -               reduce using rule 45 (expr -> [ values ] .)
    +               reduce using rule 45 (expr -> [ values ] .)
    ]               reduce using rule 45 (expr -> [ values ] .)


state 109

    (50) flow_control_statement -> IF expr block ELSE block .
    {               reduce using rule 50 (flow_control_statement -> IF expr block ELSE block .)
    FOR             reduce using rule 50 (flow_control_statement -> IF expr block ELSE block .)
    WHILE           reduce using rule 50 (flow_control_statement -> IF expr block ELSE block .)
    IF              reduce using rule 50 (flow_control_statement -> IF expr block ELSE block .)
    BREAK           reduce using rule 50 (flow_control_statement -> IF expr block ELSE block .)
    CONTINUE        reduce using rule 50 (flow_control_statement -> IF expr block ELSE block .)
    RETURN          reduce using rule 50 (flow_control_statement -> IF expr block ELSE block .)
    PRINT           reduce using rule 50 (flow_control_statement -> IF expr block ELSE block .)
    ID              reduce using rule 50 (flow_control_statement -> IF expr block ELSE block .)
    $end            reduce using rule 50 (flow_control_statement -> IF expr block ELSE block .)
    }               reduce using rule 50 (flow_control_statement -> IF expr block ELSE block .)
    ELSE            reduce using rule 50 (flow_control_statement -> IF expr block ELSE block .)


state 110

    (52) range -> expr : expr .
    (28) expr -> expr . NEQ expr
    (29) expr -> expr . EQ expr
    (30) expr -> expr . GEQ expr
    (31) expr -> expr . > expr
    (32) expr -> expr . LEQ expr
    (33) expr -> expr . < expr
    (34) expr -> expr . '
    (36) expr -> expr . MDIVIDE expr
    (37) expr -> expr . MTIMES expr
    (38) expr -> expr . MMINUS expr
    (39) expr -> expr . MPLUS expr
    (40) expr -> expr . / expr
    (41) expr -> expr . * expr
    (42) expr -> expr . - expr
    (43) expr -> expr . + expr
    {               reduce using rule 52 (range -> expr : expr .)
    FOR             reduce using rule 52 (range -> expr : expr .)
    WHILE           reduce using rule 52 (range -> expr : expr .)
    IF              reduce using rule 52 (range -> expr : expr .)
    BREAK           reduce using rule 52 (range -> expr : expr .)
    CONTINUE        reduce using rule 52 (range -> expr : expr .)
    RETURN          reduce using rule 52 (range -> expr : expr .)
    PRINT           reduce using rule 52 (range -> expr : expr .)
    ID              reduce using rule 52 (range -> expr : expr .)
    NEQ             shift and go to state 47
    EQ              shift and go to state 48
    GEQ             shift and go to state 49
    >               shift and go to state 50
    LEQ             shift and go to state 51
    <               shift and go to state 52
    '               shift and go to state 53
    MDIVIDE         shift and go to state 54
    MTIMES          shift and go to state 55
    MMINUS          shift and go to state 56
    MPLUS           shift and go to state 57
    /               shift and go to state 58
    *               shift and go to state 59
    -               shift and go to state 60
    +               shift and go to state 61


state 111

    (46) matrix -> [ values ] , . matrix
    (46) matrix -> . [ values ] , matrix
    (47) matrix -> . [ values ]
    [               shift and go to state 112

    matrix                         shift and go to state 113

state 112

    (46) matrix -> [ . values ] , matrix
    (47) matrix -> [ . values ]
    (18) values -> . expr , values
    (19) values -> . expr
    (20) expr -> . EYE ( expr )
    (21) expr -> . ONES ( expr )
    (22) expr -> . ZEROS ( expr )
    (23) expr -> . id_expr
    (24) expr -> . STRING
    (25) expr -> . FLOAT
    (26) expr -> . INT
    (27) expr -> . ( expr )
    (28) expr -> . expr NEQ expr
    (29) expr -> . expr EQ expr
    (30) expr -> . expr GEQ expr
    (31) expr -> . expr > expr
    (32) expr -> . expr LEQ expr
    (33) expr -> . expr < expr
    (34) expr -> . expr '
    (35) expr -> . - expr
    (36) expr -> . expr MDIVIDE expr
    (37) expr -> . expr MTIMES expr
    (38) expr -> . expr MMINUS expr
    (39) expr -> . expr MPLUS expr
    (40) expr -> . expr / expr
    (41) expr -> . expr * expr
    (42) expr -> . expr - expr
    (43) expr -> . expr + expr
    (44) expr -> . [ matrix ]
    (45) expr -> . [ values ]
    (53) id_expr -> . ID [ values ]
    (54) id_expr -> . ID
    EYE             shift and go to state 23
    ONES            shift and go to state 25
    ZEROS           shift and go to state 26
    STRING          shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    (               shift and go to state 24
    -               shift and go to state 31
    [               shift and go to state 32
    ID              shift and go to state 8

    values                         shift and go to state 114
    expr                           shift and go to state 36
    id_expr                        shift and go to state 27

state 113

    (46) matrix -> [ values ] , matrix .
    ]               reduce using rule 46 (matrix -> [ values ] , matrix .)


state 114

    (46) matrix -> [ values . ] , matrix
    (47) matrix -> [ values . ]
    ]               shift and go to state 115


state 115

    (46) matrix -> [ values ] . , matrix
    (47) matrix -> [ values ] .
    ,               shift and go to state 111
    ]               reduce using rule 47 (matrix -> [ values ] .)


Conflicts:

shift/reduce conflict for , in state 108 resolved as shift
reduce/reduce conflict in state 108 resolved using rule expr -> [ values ]
rejected rule (matrix -> [ values ]) in state 108