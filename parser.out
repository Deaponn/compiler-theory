Grammar:

Rule 0     S' -> start
Rule 1     start -> block
Rule 2     start -> block start
Rule 3     block -> { next_statements }
Rule 4     block -> statement
Rule 5     next_statements -> statement
Rule 6     next_statements -> statement next_statements
Rule 7     statement -> FOR ID = range block
Rule 8     statement -> WHILE expr block
Rule 9     statement -> IF expr block ELSE block  [precedence=nonassoc, level=2]
Rule 10    statement -> IF expr block  [precedence=nonassoc, level=1]
Rule 11    statement -> PRINT values ;
Rule 12    statement -> BREAK ;
Rule 13    statement -> CONTINUE ;
Rule 14    statement -> RETURN expr ;
Rule 15    statement -> left_assign DASSIGN expr ;
Rule 16    statement -> left_assign TASSIGN expr ;
Rule 17    statement -> left_assign MASSIGN expr ;
Rule 18    statement -> left_assign PASSIGN expr ;
Rule 19    statement -> left_assign = expr ;
Rule 20    left_assign -> ID [ indexes ]
Rule 21    left_assign -> ID
Rule 22    indexes -> INT
Rule 23    indexes -> INT , indexes
Rule 24    values -> expr
Rule 25    values -> expr , values
Rule 26    expr -> EYE ( expr )
Rule 27    expr -> ONES ( expr )
Rule 28    expr -> ZEROS ( expr )
Rule 29    expr -> ID
Rule 30    expr -> [ outerlist ]
Rule 31    expr -> STRING
Rule 32    expr -> FLOAT
Rule 33    expr -> INT
Rule 34    expr -> expr '  [precedence=right, level=6]
Rule 35    expr -> ( expr )
Rule 36    expr -> expr NEQ expr  [precedence=nonassoc, level=3]
Rule 37    expr -> expr EQ expr  [precedence=nonassoc, level=3]
Rule 38    expr -> expr GEQ expr  [precedence=nonassoc, level=3]
Rule 39    expr -> expr > expr  [precedence=nonassoc, level=3]
Rule 40    expr -> expr LEQ expr  [precedence=nonassoc, level=3]
Rule 41    expr -> expr < expr  [precedence=nonassoc, level=3]
Rule 42    expr -> ' expr  [precedence=right, level=6]
Rule 43    expr -> - expr  [precedence=right, level=6]
Rule 44    expr -> expr MDIVIDE expr  [precedence=left, level=5]
Rule 45    expr -> expr MTIMES expr  [precedence=left, level=5]
Rule 46    expr -> expr MMINUS expr  [precedence=left, level=4]
Rule 47    expr -> expr MPLUS expr  [precedence=left, level=4]
Rule 48    expr -> expr / expr  [precedence=left, level=5]
Rule 49    expr -> expr * expr  [precedence=left, level=5]
Rule 50    expr -> expr - expr  [precedence=left, level=4]
Rule 51    expr -> expr + expr  [precedence=left, level=4]
Rule 52    range -> expr : expr
Rule 53    outerlist -> [ values ]
Rule 54    outerlist -> outerlist , [ values ]

Terminals, with rules where they appear:

'                    : 34 42
(                    : 26 27 28 35
)                    : 26 27 28 35
*                    : 49
+                    : 51
,                    : 23 25 54
-                    : 43 50
/                    : 48
:                    : 52
;                    : 11 12 13 14 15 16 17 18 19
<                    : 41
=                    : 7 19
>                    : 39
BREAK                : 12
CONTINUE             : 13
DASSIGN              : 15
ELSE                 : 9
EQ                   : 37
EYE                  : 26
FLOAT                : 32
FOR                  : 7
GEQ                  : 38
ID                   : 7 20 21 29
IF                   : 9 10
INT                  : 22 23 33
LEQ                  : 40
MASSIGN              : 17
MDIVIDE              : 44
MMINUS               : 46
MPLUS                : 47
MTIMES               : 45
NEQ                  : 36
ONES                 : 27
PASSIGN              : 18
PRINT                : 11
RETURN               : 14
STRING               : 31
TASSIGN              : 16
WHILE                : 8
ZEROS                : 28
[                    : 20 30 53 54
]                    : 20 30 53 54
error                : 
{                    : 3
}                    : 3

Nonterminals, with rules where they appear:

block                : 1 2 7 8 9 9 10
expr                 : 8 9 10 14 15 16 17 18 19 24 25 26 27 28 34 35 36 36 37 37 38 38 39 39 40 40 41 41 42 43 44 44 45 45 46 46 47 47 48 48 49 49 50 50 51 51 52 52
indexes              : 20 23
left_assign          : 15 16 17 18 19
next_statements      : 3 6
outerlist            : 30 54
range                : 7
start                : 2 0
statement            : 4 5 6
values               : 11 25 53 54


state 0

    (0) S' -> . start
    (1) start -> . block
    (2) start -> . block start
    (3) block -> . { next_statements }
    (4) block -> . statement
    (7) statement -> . FOR ID = range block
    (8) statement -> . WHILE expr block
    (9) statement -> . IF expr block ELSE block
    (10) statement -> . IF expr block
    (11) statement -> . PRINT values ;
    (12) statement -> . BREAK ;
    (13) statement -> . CONTINUE ;
    (14) statement -> . RETURN expr ;
    (15) statement -> . left_assign DASSIGN expr ;
    (16) statement -> . left_assign TASSIGN expr ;
    (17) statement -> . left_assign MASSIGN expr ;
    (18) statement -> . left_assign PASSIGN expr ;
    (19) statement -> . left_assign = expr ;
    (20) left_assign -> . ID [ indexes ]
    (21) left_assign -> . ID
    {               shift and go to state 3
    FOR             shift and go to state 5
    WHILE           shift and go to state 7
    IF              shift and go to state 8
    PRINT           shift and go to state 9
    BREAK           shift and go to state 10
    CONTINUE        shift and go to state 11
    RETURN          shift and go to state 12
    ID              shift and go to state 6

    start                          shift and go to state 1
    block                          shift and go to state 2
    statement                      shift and go to state 4
    left_assign                    shift and go to state 13

state 1

    (0) S' -> start .


state 2

    (1) start -> block .
    (2) start -> block . start
    (1) start -> . block
    (2) start -> . block start
    (3) block -> . { next_statements }
    (4) block -> . statement
    (7) statement -> . FOR ID = range block
    (8) statement -> . WHILE expr block
    (9) statement -> . IF expr block ELSE block
    (10) statement -> . IF expr block
    (11) statement -> . PRINT values ;
    (12) statement -> . BREAK ;
    (13) statement -> . CONTINUE ;
    (14) statement -> . RETURN expr ;
    (15) statement -> . left_assign DASSIGN expr ;
    (16) statement -> . left_assign TASSIGN expr ;
    (17) statement -> . left_assign MASSIGN expr ;
    (18) statement -> . left_assign PASSIGN expr ;
    (19) statement -> . left_assign = expr ;
    (20) left_assign -> . ID [ indexes ]
    (21) left_assign -> . ID
    $end            reduce using rule 1 (start -> block .)
    {               shift and go to state 3
    FOR             shift and go to state 5
    WHILE           shift and go to state 7
    IF              shift and go to state 8
    PRINT           shift and go to state 9
    BREAK           shift and go to state 10
    CONTINUE        shift and go to state 11
    RETURN          shift and go to state 12
    ID              shift and go to state 6

    block                          shift and go to state 2
    start                          shift and go to state 14
    statement                      shift and go to state 4
    left_assign                    shift and go to state 13

state 3

    (3) block -> { . next_statements }
    (5) next_statements -> . statement
    (6) next_statements -> . statement next_statements
    (7) statement -> . FOR ID = range block
    (8) statement -> . WHILE expr block
    (9) statement -> . IF expr block ELSE block
    (10) statement -> . IF expr block
    (11) statement -> . PRINT values ;
    (12) statement -> . BREAK ;
    (13) statement -> . CONTINUE ;
    (14) statement -> . RETURN expr ;
    (15) statement -> . left_assign DASSIGN expr ;
    (16) statement -> . left_assign TASSIGN expr ;
    (17) statement -> . left_assign MASSIGN expr ;
    (18) statement -> . left_assign PASSIGN expr ;
    (19) statement -> . left_assign = expr ;
    (20) left_assign -> . ID [ indexes ]
    (21) left_assign -> . ID
    FOR             shift and go to state 5
    WHILE           shift and go to state 7
    IF              shift and go to state 8
    PRINT           shift and go to state 9
    BREAK           shift and go to state 10
    CONTINUE        shift and go to state 11
    RETURN          shift and go to state 12
    ID              shift and go to state 6

    next_statements                shift and go to state 15
    statement                      shift and go to state 16
    left_assign                    shift and go to state 13

state 4

    (4) block -> statement .
    {               reduce using rule 4 (block -> statement .)
    FOR             reduce using rule 4 (block -> statement .)
    WHILE           reduce using rule 4 (block -> statement .)
    IF              reduce using rule 4 (block -> statement .)
    PRINT           reduce using rule 4 (block -> statement .)
    BREAK           reduce using rule 4 (block -> statement .)
    CONTINUE        reduce using rule 4 (block -> statement .)
    RETURN          reduce using rule 4 (block -> statement .)
    ID              reduce using rule 4 (block -> statement .)
    $end            reduce using rule 4 (block -> statement .)
    }               reduce using rule 4 (block -> statement .)
    ELSE            reduce using rule 4 (block -> statement .)


state 5

    (7) statement -> FOR . ID = range block
    ID              shift and go to state 17


state 6

    (20) left_assign -> ID . [ indexes ]
    (21) left_assign -> ID .
    [               shift and go to state 18
    DASSIGN         reduce using rule 21 (left_assign -> ID .)
    TASSIGN         reduce using rule 21 (left_assign -> ID .)
    MASSIGN         reduce using rule 21 (left_assign -> ID .)
    PASSIGN         reduce using rule 21 (left_assign -> ID .)
    =               reduce using rule 21 (left_assign -> ID .)


state 7

    (8) statement -> WHILE . expr block
    (26) expr -> . EYE ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . ZEROS ( expr )
    (29) expr -> . ID
    (30) expr -> . [ outerlist ]
    (31) expr -> . STRING
    (32) expr -> . FLOAT
    (33) expr -> . INT
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr GEQ expr
    (39) expr -> . expr > expr
    (40) expr -> . expr LEQ expr
    (41) expr -> . expr < expr
    (42) expr -> . ' expr
    (43) expr -> . - expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 20
    ONES            shift and go to state 22
    ZEROS           shift and go to state 23
    ID              shift and go to state 24
    [               shift and go to state 25
    STRING          shift and go to state 26
    FLOAT           shift and go to state 27
    INT             shift and go to state 28
    (               shift and go to state 21
    '               shift and go to state 29
    -               shift and go to state 30

    expr                           shift and go to state 19

state 8

    (9) statement -> IF . expr block ELSE block
    (10) statement -> IF . expr block
    (26) expr -> . EYE ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . ZEROS ( expr )
    (29) expr -> . ID
    (30) expr -> . [ outerlist ]
    (31) expr -> . STRING
    (32) expr -> . FLOAT
    (33) expr -> . INT
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr GEQ expr
    (39) expr -> . expr > expr
    (40) expr -> . expr LEQ expr
    (41) expr -> . expr < expr
    (42) expr -> . ' expr
    (43) expr -> . - expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 20
    ONES            shift and go to state 22
    ZEROS           shift and go to state 23
    ID              shift and go to state 24
    [               shift and go to state 25
    STRING          shift and go to state 26
    FLOAT           shift and go to state 27
    INT             shift and go to state 28
    (               shift and go to state 21
    '               shift and go to state 29
    -               shift and go to state 30

    expr                           shift and go to state 31

state 9

    (11) statement -> PRINT . values ;
    (24) values -> . expr
    (25) values -> . expr , values
    (26) expr -> . EYE ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . ZEROS ( expr )
    (29) expr -> . ID
    (30) expr -> . [ outerlist ]
    (31) expr -> . STRING
    (32) expr -> . FLOAT
    (33) expr -> . INT
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr GEQ expr
    (39) expr -> . expr > expr
    (40) expr -> . expr LEQ expr
    (41) expr -> . expr < expr
    (42) expr -> . ' expr
    (43) expr -> . - expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 20
    ONES            shift and go to state 22
    ZEROS           shift and go to state 23
    ID              shift and go to state 24
    [               shift and go to state 25
    STRING          shift and go to state 26
    FLOAT           shift and go to state 27
    INT             shift and go to state 28
    (               shift and go to state 21
    '               shift and go to state 29
    -               shift and go to state 30

    values                         shift and go to state 32
    expr                           shift and go to state 33

state 10

    (12) statement -> BREAK . ;
    ;               shift and go to state 34


state 11

    (13) statement -> CONTINUE . ;
    ;               shift and go to state 35


state 12

    (14) statement -> RETURN . expr ;
    (26) expr -> . EYE ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . ZEROS ( expr )
    (29) expr -> . ID
    (30) expr -> . [ outerlist ]
    (31) expr -> . STRING
    (32) expr -> . FLOAT
    (33) expr -> . INT
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr GEQ expr
    (39) expr -> . expr > expr
    (40) expr -> . expr LEQ expr
    (41) expr -> . expr < expr
    (42) expr -> . ' expr
    (43) expr -> . - expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 20
    ONES            shift and go to state 22
    ZEROS           shift and go to state 23
    ID              shift and go to state 24
    [               shift and go to state 25
    STRING          shift and go to state 26
    FLOAT           shift and go to state 27
    INT             shift and go to state 28
    (               shift and go to state 21
    '               shift and go to state 29
    -               shift and go to state 30

    expr                           shift and go to state 36

state 13

    (15) statement -> left_assign . DASSIGN expr ;
    (16) statement -> left_assign . TASSIGN expr ;
    (17) statement -> left_assign . MASSIGN expr ;
    (18) statement -> left_assign . PASSIGN expr ;
    (19) statement -> left_assign . = expr ;
    DASSIGN         shift and go to state 37
    TASSIGN         shift and go to state 38
    MASSIGN         shift and go to state 39
    PASSIGN         shift and go to state 40
    =               shift and go to state 41


state 14

    (2) start -> block start .
    $end            reduce using rule 2 (start -> block start .)


state 15

    (3) block -> { next_statements . }
    }               shift and go to state 42


state 16

    (5) next_statements -> statement .
    (6) next_statements -> statement . next_statements
    (5) next_statements -> . statement
    (6) next_statements -> . statement next_statements
    (7) statement -> . FOR ID = range block
    (8) statement -> . WHILE expr block
    (9) statement -> . IF expr block ELSE block
    (10) statement -> . IF expr block
    (11) statement -> . PRINT values ;
    (12) statement -> . BREAK ;
    (13) statement -> . CONTINUE ;
    (14) statement -> . RETURN expr ;
    (15) statement -> . left_assign DASSIGN expr ;
    (16) statement -> . left_assign TASSIGN expr ;
    (17) statement -> . left_assign MASSIGN expr ;
    (18) statement -> . left_assign PASSIGN expr ;
    (19) statement -> . left_assign = expr ;
    (20) left_assign -> . ID [ indexes ]
    (21) left_assign -> . ID
    }               reduce using rule 5 (next_statements -> statement .)
    FOR             shift and go to state 5
    WHILE           shift and go to state 7
    IF              shift and go to state 8
    PRINT           shift and go to state 9
    BREAK           shift and go to state 10
    CONTINUE        shift and go to state 11
    RETURN          shift and go to state 12
    ID              shift and go to state 6

    statement                      shift and go to state 16
    next_statements                shift and go to state 43
    left_assign                    shift and go to state 13

state 17

    (7) statement -> FOR ID . = range block
    =               shift and go to state 44


state 18

    (20) left_assign -> ID [ . indexes ]
    (22) indexes -> . INT
    (23) indexes -> . INT , indexes
    INT             shift and go to state 46

    indexes                        shift and go to state 45

state 19

    (8) statement -> WHILE expr . block
    (34) expr -> expr . '
    (36) expr -> expr . NEQ expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . GEQ expr
    (39) expr -> expr . > expr
    (40) expr -> expr . LEQ expr
    (41) expr -> expr . < expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . MTIMES expr
    (46) expr -> expr . MMINUS expr
    (47) expr -> expr . MPLUS expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    (3) block -> . { next_statements }
    (4) block -> . statement
    (7) statement -> . FOR ID = range block
    (8) statement -> . WHILE expr block
    (9) statement -> . IF expr block ELSE block
    (10) statement -> . IF expr block
    (11) statement -> . PRINT values ;
    (12) statement -> . BREAK ;
    (13) statement -> . CONTINUE ;
    (14) statement -> . RETURN expr ;
    (15) statement -> . left_assign DASSIGN expr ;
    (16) statement -> . left_assign TASSIGN expr ;
    (17) statement -> . left_assign MASSIGN expr ;
    (18) statement -> . left_assign PASSIGN expr ;
    (19) statement -> . left_assign = expr ;
    (20) left_assign -> . ID [ indexes ]
    (21) left_assign -> . ID
    '               shift and go to state 48
    NEQ             shift and go to state 49
    EQ              shift and go to state 50
    GEQ             shift and go to state 51
    >               shift and go to state 52
    LEQ             shift and go to state 53
    <               shift and go to state 54
    MDIVIDE         shift and go to state 55
    MTIMES          shift and go to state 56
    MMINUS          shift and go to state 57
    MPLUS           shift and go to state 58
    /               shift and go to state 59
    *               shift and go to state 60
    -               shift and go to state 61
    +               shift and go to state 62
    {               shift and go to state 3
    FOR             shift and go to state 5
    WHILE           shift and go to state 7
    IF              shift and go to state 8
    PRINT           shift and go to state 9
    BREAK           shift and go to state 10
    CONTINUE        shift and go to state 11
    RETURN          shift and go to state 12
    ID              shift and go to state 6

    block                          shift and go to state 47
    statement                      shift and go to state 4
    left_assign                    shift and go to state 13

state 20

    (26) expr -> EYE . ( expr )
    (               shift and go to state 63


state 21

    (35) expr -> ( . expr )
    (26) expr -> . EYE ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . ZEROS ( expr )
    (29) expr -> . ID
    (30) expr -> . [ outerlist ]
    (31) expr -> . STRING
    (32) expr -> . FLOAT
    (33) expr -> . INT
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr GEQ expr
    (39) expr -> . expr > expr
    (40) expr -> . expr LEQ expr
    (41) expr -> . expr < expr
    (42) expr -> . ' expr
    (43) expr -> . - expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 20
    ONES            shift and go to state 22
    ZEROS           shift and go to state 23
    ID              shift and go to state 24
    [               shift and go to state 25
    STRING          shift and go to state 26
    FLOAT           shift and go to state 27
    INT             shift and go to state 28
    (               shift and go to state 21
    '               shift and go to state 29
    -               shift and go to state 30

    expr                           shift and go to state 64

state 22

    (27) expr -> ONES . ( expr )
    (               shift and go to state 65


state 23

    (28) expr -> ZEROS . ( expr )
    (               shift and go to state 66


state 24

    (29) expr -> ID .
    '               reduce using rule 29 (expr -> ID .)
    NEQ             reduce using rule 29 (expr -> ID .)
    EQ              reduce using rule 29 (expr -> ID .)
    GEQ             reduce using rule 29 (expr -> ID .)
    >               reduce using rule 29 (expr -> ID .)
    LEQ             reduce using rule 29 (expr -> ID .)
    <               reduce using rule 29 (expr -> ID .)
    MDIVIDE         reduce using rule 29 (expr -> ID .)
    MTIMES          reduce using rule 29 (expr -> ID .)
    MMINUS          reduce using rule 29 (expr -> ID .)
    MPLUS           reduce using rule 29 (expr -> ID .)
    /               reduce using rule 29 (expr -> ID .)
    *               reduce using rule 29 (expr -> ID .)
    -               reduce using rule 29 (expr -> ID .)
    +               reduce using rule 29 (expr -> ID .)
    {               reduce using rule 29 (expr -> ID .)
    FOR             reduce using rule 29 (expr -> ID .)
    WHILE           reduce using rule 29 (expr -> ID .)
    IF              reduce using rule 29 (expr -> ID .)
    PRINT           reduce using rule 29 (expr -> ID .)
    BREAK           reduce using rule 29 (expr -> ID .)
    CONTINUE        reduce using rule 29 (expr -> ID .)
    RETURN          reduce using rule 29 (expr -> ID .)
    ID              reduce using rule 29 (expr -> ID .)
    ,               reduce using rule 29 (expr -> ID .)
    ;               reduce using rule 29 (expr -> ID .)
    )               reduce using rule 29 (expr -> ID .)
    :               reduce using rule 29 (expr -> ID .)
    ]               reduce using rule 29 (expr -> ID .)


state 25

    (30) expr -> [ . outerlist ]
    (53) outerlist -> . [ values ]
    (54) outerlist -> . outerlist , [ values ]
    [               shift and go to state 67

    outerlist                      shift and go to state 68

state 26

    (31) expr -> STRING .
    '               reduce using rule 31 (expr -> STRING .)
    NEQ             reduce using rule 31 (expr -> STRING .)
    EQ              reduce using rule 31 (expr -> STRING .)
    GEQ             reduce using rule 31 (expr -> STRING .)
    >               reduce using rule 31 (expr -> STRING .)
    LEQ             reduce using rule 31 (expr -> STRING .)
    <               reduce using rule 31 (expr -> STRING .)
    MDIVIDE         reduce using rule 31 (expr -> STRING .)
    MTIMES          reduce using rule 31 (expr -> STRING .)
    MMINUS          reduce using rule 31 (expr -> STRING .)
    MPLUS           reduce using rule 31 (expr -> STRING .)
    /               reduce using rule 31 (expr -> STRING .)
    *               reduce using rule 31 (expr -> STRING .)
    -               reduce using rule 31 (expr -> STRING .)
    +               reduce using rule 31 (expr -> STRING .)
    {               reduce using rule 31 (expr -> STRING .)
    FOR             reduce using rule 31 (expr -> STRING .)
    WHILE           reduce using rule 31 (expr -> STRING .)
    IF              reduce using rule 31 (expr -> STRING .)
    PRINT           reduce using rule 31 (expr -> STRING .)
    BREAK           reduce using rule 31 (expr -> STRING .)
    CONTINUE        reduce using rule 31 (expr -> STRING .)
    RETURN          reduce using rule 31 (expr -> STRING .)
    ID              reduce using rule 31 (expr -> STRING .)
    ,               reduce using rule 31 (expr -> STRING .)
    ;               reduce using rule 31 (expr -> STRING .)
    )               reduce using rule 31 (expr -> STRING .)
    :               reduce using rule 31 (expr -> STRING .)
    ]               reduce using rule 31 (expr -> STRING .)


state 27

    (32) expr -> FLOAT .
    '               reduce using rule 32 (expr -> FLOAT .)
    NEQ             reduce using rule 32 (expr -> FLOAT .)
    EQ              reduce using rule 32 (expr -> FLOAT .)
    GEQ             reduce using rule 32 (expr -> FLOAT .)
    >               reduce using rule 32 (expr -> FLOAT .)
    LEQ             reduce using rule 32 (expr -> FLOAT .)
    <               reduce using rule 32 (expr -> FLOAT .)
    MDIVIDE         reduce using rule 32 (expr -> FLOAT .)
    MTIMES          reduce using rule 32 (expr -> FLOAT .)
    MMINUS          reduce using rule 32 (expr -> FLOAT .)
    MPLUS           reduce using rule 32 (expr -> FLOAT .)
    /               reduce using rule 32 (expr -> FLOAT .)
    *               reduce using rule 32 (expr -> FLOAT .)
    -               reduce using rule 32 (expr -> FLOAT .)
    +               reduce using rule 32 (expr -> FLOAT .)
    {               reduce using rule 32 (expr -> FLOAT .)
    FOR             reduce using rule 32 (expr -> FLOAT .)
    WHILE           reduce using rule 32 (expr -> FLOAT .)
    IF              reduce using rule 32 (expr -> FLOAT .)
    PRINT           reduce using rule 32 (expr -> FLOAT .)
    BREAK           reduce using rule 32 (expr -> FLOAT .)
    CONTINUE        reduce using rule 32 (expr -> FLOAT .)
    RETURN          reduce using rule 32 (expr -> FLOAT .)
    ID              reduce using rule 32 (expr -> FLOAT .)
    ,               reduce using rule 32 (expr -> FLOAT .)
    ;               reduce using rule 32 (expr -> FLOAT .)
    )               reduce using rule 32 (expr -> FLOAT .)
    :               reduce using rule 32 (expr -> FLOAT .)
    ]               reduce using rule 32 (expr -> FLOAT .)


state 28

    (33) expr -> INT .
    '               reduce using rule 33 (expr -> INT .)
    NEQ             reduce using rule 33 (expr -> INT .)
    EQ              reduce using rule 33 (expr -> INT .)
    GEQ             reduce using rule 33 (expr -> INT .)
    >               reduce using rule 33 (expr -> INT .)
    LEQ             reduce using rule 33 (expr -> INT .)
    <               reduce using rule 33 (expr -> INT .)
    MDIVIDE         reduce using rule 33 (expr -> INT .)
    MTIMES          reduce using rule 33 (expr -> INT .)
    MMINUS          reduce using rule 33 (expr -> INT .)
    MPLUS           reduce using rule 33 (expr -> INT .)
    /               reduce using rule 33 (expr -> INT .)
    *               reduce using rule 33 (expr -> INT .)
    -               reduce using rule 33 (expr -> INT .)
    +               reduce using rule 33 (expr -> INT .)
    {               reduce using rule 33 (expr -> INT .)
    FOR             reduce using rule 33 (expr -> INT .)
    WHILE           reduce using rule 33 (expr -> INT .)
    IF              reduce using rule 33 (expr -> INT .)
    PRINT           reduce using rule 33 (expr -> INT .)
    BREAK           reduce using rule 33 (expr -> INT .)
    CONTINUE        reduce using rule 33 (expr -> INT .)
    RETURN          reduce using rule 33 (expr -> INT .)
    ID              reduce using rule 33 (expr -> INT .)
    ,               reduce using rule 33 (expr -> INT .)
    ;               reduce using rule 33 (expr -> INT .)
    )               reduce using rule 33 (expr -> INT .)
    :               reduce using rule 33 (expr -> INT .)
    ]               reduce using rule 33 (expr -> INT .)


state 29

    (42) expr -> ' . expr
    (26) expr -> . EYE ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . ZEROS ( expr )
    (29) expr -> . ID
    (30) expr -> . [ outerlist ]
    (31) expr -> . STRING
    (32) expr -> . FLOAT
    (33) expr -> . INT
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr GEQ expr
    (39) expr -> . expr > expr
    (40) expr -> . expr LEQ expr
    (41) expr -> . expr < expr
    (42) expr -> . ' expr
    (43) expr -> . - expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 20
    ONES            shift and go to state 22
    ZEROS           shift and go to state 23
    ID              shift and go to state 24
    [               shift and go to state 25
    STRING          shift and go to state 26
    FLOAT           shift and go to state 27
    INT             shift and go to state 28
    (               shift and go to state 21
    '               shift and go to state 29
    -               shift and go to state 30

    expr                           shift and go to state 69

state 30

    (43) expr -> - . expr
    (26) expr -> . EYE ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . ZEROS ( expr )
    (29) expr -> . ID
    (30) expr -> . [ outerlist ]
    (31) expr -> . STRING
    (32) expr -> . FLOAT
    (33) expr -> . INT
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr GEQ expr
    (39) expr -> . expr > expr
    (40) expr -> . expr LEQ expr
    (41) expr -> . expr < expr
    (42) expr -> . ' expr
    (43) expr -> . - expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 20
    ONES            shift and go to state 22
    ZEROS           shift and go to state 23
    ID              shift and go to state 24
    [               shift and go to state 25
    STRING          shift and go to state 26
    FLOAT           shift and go to state 27
    INT             shift and go to state 28
    (               shift and go to state 21
    '               shift and go to state 29
    -               shift and go to state 30

    expr                           shift and go to state 70

state 31

    (9) statement -> IF expr . block ELSE block
    (10) statement -> IF expr . block
    (34) expr -> expr . '
    (36) expr -> expr . NEQ expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . GEQ expr
    (39) expr -> expr . > expr
    (40) expr -> expr . LEQ expr
    (41) expr -> expr . < expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . MTIMES expr
    (46) expr -> expr . MMINUS expr
    (47) expr -> expr . MPLUS expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    (3) block -> . { next_statements }
    (4) block -> . statement
    (7) statement -> . FOR ID = range block
    (8) statement -> . WHILE expr block
    (9) statement -> . IF expr block ELSE block
    (10) statement -> . IF expr block
    (11) statement -> . PRINT values ;
    (12) statement -> . BREAK ;
    (13) statement -> . CONTINUE ;
    (14) statement -> . RETURN expr ;
    (15) statement -> . left_assign DASSIGN expr ;
    (16) statement -> . left_assign TASSIGN expr ;
    (17) statement -> . left_assign MASSIGN expr ;
    (18) statement -> . left_assign PASSIGN expr ;
    (19) statement -> . left_assign = expr ;
    (20) left_assign -> . ID [ indexes ]
    (21) left_assign -> . ID
    '               shift and go to state 48
    NEQ             shift and go to state 49
    EQ              shift and go to state 50
    GEQ             shift and go to state 51
    >               shift and go to state 52
    LEQ             shift and go to state 53
    <               shift and go to state 54
    MDIVIDE         shift and go to state 55
    MTIMES          shift and go to state 56
    MMINUS          shift and go to state 57
    MPLUS           shift and go to state 58
    /               shift and go to state 59
    *               shift and go to state 60
    -               shift and go to state 61
    +               shift and go to state 62
    {               shift and go to state 3
    FOR             shift and go to state 5
    WHILE           shift and go to state 7
    IF              shift and go to state 8
    PRINT           shift and go to state 9
    BREAK           shift and go to state 10
    CONTINUE        shift and go to state 11
    RETURN          shift and go to state 12
    ID              shift and go to state 6

    block                          shift and go to state 71
    statement                      shift and go to state 4
    left_assign                    shift and go to state 13

state 32

    (11) statement -> PRINT values . ;
    ;               shift and go to state 72


state 33

    (24) values -> expr .
    (25) values -> expr . , values
    (34) expr -> expr . '
    (36) expr -> expr . NEQ expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . GEQ expr
    (39) expr -> expr . > expr
    (40) expr -> expr . LEQ expr
    (41) expr -> expr . < expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . MTIMES expr
    (46) expr -> expr . MMINUS expr
    (47) expr -> expr . MPLUS expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    ;               reduce using rule 24 (values -> expr .)
    ]               reduce using rule 24 (values -> expr .)
    ,               shift and go to state 73
    '               shift and go to state 48
    NEQ             shift and go to state 49
    EQ              shift and go to state 50
    GEQ             shift and go to state 51
    >               shift and go to state 52
    LEQ             shift and go to state 53
    <               shift and go to state 54
    MDIVIDE         shift and go to state 55
    MTIMES          shift and go to state 56
    MMINUS          shift and go to state 57
    MPLUS           shift and go to state 58
    /               shift and go to state 59
    *               shift and go to state 60
    -               shift and go to state 61
    +               shift and go to state 62


state 34

    (12) statement -> BREAK ; .
    {               reduce using rule 12 (statement -> BREAK ; .)
    FOR             reduce using rule 12 (statement -> BREAK ; .)
    WHILE           reduce using rule 12 (statement -> BREAK ; .)
    IF              reduce using rule 12 (statement -> BREAK ; .)
    PRINT           reduce using rule 12 (statement -> BREAK ; .)
    BREAK           reduce using rule 12 (statement -> BREAK ; .)
    CONTINUE        reduce using rule 12 (statement -> BREAK ; .)
    RETURN          reduce using rule 12 (statement -> BREAK ; .)
    ID              reduce using rule 12 (statement -> BREAK ; .)
    $end            reduce using rule 12 (statement -> BREAK ; .)
    }               reduce using rule 12 (statement -> BREAK ; .)
    ELSE            reduce using rule 12 (statement -> BREAK ; .)


state 35

    (13) statement -> CONTINUE ; .
    {               reduce using rule 13 (statement -> CONTINUE ; .)
    FOR             reduce using rule 13 (statement -> CONTINUE ; .)
    WHILE           reduce using rule 13 (statement -> CONTINUE ; .)
    IF              reduce using rule 13 (statement -> CONTINUE ; .)
    PRINT           reduce using rule 13 (statement -> CONTINUE ; .)
    BREAK           reduce using rule 13 (statement -> CONTINUE ; .)
    CONTINUE        reduce using rule 13 (statement -> CONTINUE ; .)
    RETURN          reduce using rule 13 (statement -> CONTINUE ; .)
    ID              reduce using rule 13 (statement -> CONTINUE ; .)
    $end            reduce using rule 13 (statement -> CONTINUE ; .)
    }               reduce using rule 13 (statement -> CONTINUE ; .)
    ELSE            reduce using rule 13 (statement -> CONTINUE ; .)


state 36

    (14) statement -> RETURN expr . ;
    (34) expr -> expr . '
    (36) expr -> expr . NEQ expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . GEQ expr
    (39) expr -> expr . > expr
    (40) expr -> expr . LEQ expr
    (41) expr -> expr . < expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . MTIMES expr
    (46) expr -> expr . MMINUS expr
    (47) expr -> expr . MPLUS expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    ;               shift and go to state 74
    '               shift and go to state 48
    NEQ             shift and go to state 49
    EQ              shift and go to state 50
    GEQ             shift and go to state 51
    >               shift and go to state 52
    LEQ             shift and go to state 53
    <               shift and go to state 54
    MDIVIDE         shift and go to state 55
    MTIMES          shift and go to state 56
    MMINUS          shift and go to state 57
    MPLUS           shift and go to state 58
    /               shift and go to state 59
    *               shift and go to state 60
    -               shift and go to state 61
    +               shift and go to state 62


state 37

    (15) statement -> left_assign DASSIGN . expr ;
    (26) expr -> . EYE ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . ZEROS ( expr )
    (29) expr -> . ID
    (30) expr -> . [ outerlist ]
    (31) expr -> . STRING
    (32) expr -> . FLOAT
    (33) expr -> . INT
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr GEQ expr
    (39) expr -> . expr > expr
    (40) expr -> . expr LEQ expr
    (41) expr -> . expr < expr
    (42) expr -> . ' expr
    (43) expr -> . - expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 20
    ONES            shift and go to state 22
    ZEROS           shift and go to state 23
    ID              shift and go to state 24
    [               shift and go to state 25
    STRING          shift and go to state 26
    FLOAT           shift and go to state 27
    INT             shift and go to state 28
    (               shift and go to state 21
    '               shift and go to state 29
    -               shift and go to state 30

    expr                           shift and go to state 75

state 38

    (16) statement -> left_assign TASSIGN . expr ;
    (26) expr -> . EYE ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . ZEROS ( expr )
    (29) expr -> . ID
    (30) expr -> . [ outerlist ]
    (31) expr -> . STRING
    (32) expr -> . FLOAT
    (33) expr -> . INT
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr GEQ expr
    (39) expr -> . expr > expr
    (40) expr -> . expr LEQ expr
    (41) expr -> . expr < expr
    (42) expr -> . ' expr
    (43) expr -> . - expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 20
    ONES            shift and go to state 22
    ZEROS           shift and go to state 23
    ID              shift and go to state 24
    [               shift and go to state 25
    STRING          shift and go to state 26
    FLOAT           shift and go to state 27
    INT             shift and go to state 28
    (               shift and go to state 21
    '               shift and go to state 29
    -               shift and go to state 30

    expr                           shift and go to state 76

state 39

    (17) statement -> left_assign MASSIGN . expr ;
    (26) expr -> . EYE ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . ZEROS ( expr )
    (29) expr -> . ID
    (30) expr -> . [ outerlist ]
    (31) expr -> . STRING
    (32) expr -> . FLOAT
    (33) expr -> . INT
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr GEQ expr
    (39) expr -> . expr > expr
    (40) expr -> . expr LEQ expr
    (41) expr -> . expr < expr
    (42) expr -> . ' expr
    (43) expr -> . - expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 20
    ONES            shift and go to state 22
    ZEROS           shift and go to state 23
    ID              shift and go to state 24
    [               shift and go to state 25
    STRING          shift and go to state 26
    FLOAT           shift and go to state 27
    INT             shift and go to state 28
    (               shift and go to state 21
    '               shift and go to state 29
    -               shift and go to state 30

    expr                           shift and go to state 77

state 40

    (18) statement -> left_assign PASSIGN . expr ;
    (26) expr -> . EYE ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . ZEROS ( expr )
    (29) expr -> . ID
    (30) expr -> . [ outerlist ]
    (31) expr -> . STRING
    (32) expr -> . FLOAT
    (33) expr -> . INT
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr GEQ expr
    (39) expr -> . expr > expr
    (40) expr -> . expr LEQ expr
    (41) expr -> . expr < expr
    (42) expr -> . ' expr
    (43) expr -> . - expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 20
    ONES            shift and go to state 22
    ZEROS           shift and go to state 23
    ID              shift and go to state 24
    [               shift and go to state 25
    STRING          shift and go to state 26
    FLOAT           shift and go to state 27
    INT             shift and go to state 28
    (               shift and go to state 21
    '               shift and go to state 29
    -               shift and go to state 30

    expr                           shift and go to state 78

state 41

    (19) statement -> left_assign = . expr ;
    (26) expr -> . EYE ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . ZEROS ( expr )
    (29) expr -> . ID
    (30) expr -> . [ outerlist ]
    (31) expr -> . STRING
    (32) expr -> . FLOAT
    (33) expr -> . INT
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr GEQ expr
    (39) expr -> . expr > expr
    (40) expr -> . expr LEQ expr
    (41) expr -> . expr < expr
    (42) expr -> . ' expr
    (43) expr -> . - expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 20
    ONES            shift and go to state 22
    ZEROS           shift and go to state 23
    ID              shift and go to state 24
    [               shift and go to state 25
    STRING          shift and go to state 26
    FLOAT           shift and go to state 27
    INT             shift and go to state 28
    (               shift and go to state 21
    '               shift and go to state 29
    -               shift and go to state 30

    expr                           shift and go to state 79

state 42

    (3) block -> { next_statements } .
    {               reduce using rule 3 (block -> { next_statements } .)
    FOR             reduce using rule 3 (block -> { next_statements } .)
    WHILE           reduce using rule 3 (block -> { next_statements } .)
    IF              reduce using rule 3 (block -> { next_statements } .)
    PRINT           reduce using rule 3 (block -> { next_statements } .)
    BREAK           reduce using rule 3 (block -> { next_statements } .)
    CONTINUE        reduce using rule 3 (block -> { next_statements } .)
    RETURN          reduce using rule 3 (block -> { next_statements } .)
    ID              reduce using rule 3 (block -> { next_statements } .)
    $end            reduce using rule 3 (block -> { next_statements } .)
    }               reduce using rule 3 (block -> { next_statements } .)
    ELSE            reduce using rule 3 (block -> { next_statements } .)


state 43

    (6) next_statements -> statement next_statements .
    }               reduce using rule 6 (next_statements -> statement next_statements .)


state 44

    (7) statement -> FOR ID = . range block
    (52) range -> . expr : expr
    (26) expr -> . EYE ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . ZEROS ( expr )
    (29) expr -> . ID
    (30) expr -> . [ outerlist ]
    (31) expr -> . STRING
    (32) expr -> . FLOAT
    (33) expr -> . INT
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr GEQ expr
    (39) expr -> . expr > expr
    (40) expr -> . expr LEQ expr
    (41) expr -> . expr < expr
    (42) expr -> . ' expr
    (43) expr -> . - expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 20
    ONES            shift and go to state 22
    ZEROS           shift and go to state 23
    ID              shift and go to state 24
    [               shift and go to state 25
    STRING          shift and go to state 26
    FLOAT           shift and go to state 27
    INT             shift and go to state 28
    (               shift and go to state 21
    '               shift and go to state 29
    -               shift and go to state 30

    range                          shift and go to state 80
    expr                           shift and go to state 81

state 45

    (20) left_assign -> ID [ indexes . ]
    ]               shift and go to state 82


state 46

    (22) indexes -> INT .
    (23) indexes -> INT . , indexes
    ]               reduce using rule 22 (indexes -> INT .)
    ,               shift and go to state 83


state 47

    (8) statement -> WHILE expr block .
    {               reduce using rule 8 (statement -> WHILE expr block .)
    FOR             reduce using rule 8 (statement -> WHILE expr block .)
    WHILE           reduce using rule 8 (statement -> WHILE expr block .)
    IF              reduce using rule 8 (statement -> WHILE expr block .)
    PRINT           reduce using rule 8 (statement -> WHILE expr block .)
    BREAK           reduce using rule 8 (statement -> WHILE expr block .)
    CONTINUE        reduce using rule 8 (statement -> WHILE expr block .)
    RETURN          reduce using rule 8 (statement -> WHILE expr block .)
    ID              reduce using rule 8 (statement -> WHILE expr block .)
    $end            reduce using rule 8 (statement -> WHILE expr block .)
    }               reduce using rule 8 (statement -> WHILE expr block .)
    ELSE            reduce using rule 8 (statement -> WHILE expr block .)


state 48

    (34) expr -> expr ' .
    '               reduce using rule 34 (expr -> expr ' .)
    NEQ             reduce using rule 34 (expr -> expr ' .)
    EQ              reduce using rule 34 (expr -> expr ' .)
    GEQ             reduce using rule 34 (expr -> expr ' .)
    >               reduce using rule 34 (expr -> expr ' .)
    LEQ             reduce using rule 34 (expr -> expr ' .)
    <               reduce using rule 34 (expr -> expr ' .)
    MDIVIDE         reduce using rule 34 (expr -> expr ' .)
    MTIMES          reduce using rule 34 (expr -> expr ' .)
    MMINUS          reduce using rule 34 (expr -> expr ' .)
    MPLUS           reduce using rule 34 (expr -> expr ' .)
    /               reduce using rule 34 (expr -> expr ' .)
    *               reduce using rule 34 (expr -> expr ' .)
    -               reduce using rule 34 (expr -> expr ' .)
    +               reduce using rule 34 (expr -> expr ' .)
    {               reduce using rule 34 (expr -> expr ' .)
    FOR             reduce using rule 34 (expr -> expr ' .)
    WHILE           reduce using rule 34 (expr -> expr ' .)
    IF              reduce using rule 34 (expr -> expr ' .)
    PRINT           reduce using rule 34 (expr -> expr ' .)
    BREAK           reduce using rule 34 (expr -> expr ' .)
    CONTINUE        reduce using rule 34 (expr -> expr ' .)
    RETURN          reduce using rule 34 (expr -> expr ' .)
    ID              reduce using rule 34 (expr -> expr ' .)
    ,               reduce using rule 34 (expr -> expr ' .)
    ;               reduce using rule 34 (expr -> expr ' .)
    )               reduce using rule 34 (expr -> expr ' .)
    :               reduce using rule 34 (expr -> expr ' .)
    ]               reduce using rule 34 (expr -> expr ' .)


state 49

    (36) expr -> expr NEQ . expr
    (26) expr -> . EYE ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . ZEROS ( expr )
    (29) expr -> . ID
    (30) expr -> . [ outerlist ]
    (31) expr -> . STRING
    (32) expr -> . FLOAT
    (33) expr -> . INT
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr GEQ expr
    (39) expr -> . expr > expr
    (40) expr -> . expr LEQ expr
    (41) expr -> . expr < expr
    (42) expr -> . ' expr
    (43) expr -> . - expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 20
    ONES            shift and go to state 22
    ZEROS           shift and go to state 23
    ID              shift and go to state 24
    [               shift and go to state 25
    STRING          shift and go to state 26
    FLOAT           shift and go to state 27
    INT             shift and go to state 28
    (               shift and go to state 21
    '               shift and go to state 29
    -               shift and go to state 30

    expr                           shift and go to state 84

state 50

    (37) expr -> expr EQ . expr
    (26) expr -> . EYE ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . ZEROS ( expr )
    (29) expr -> . ID
    (30) expr -> . [ outerlist ]
    (31) expr -> . STRING
    (32) expr -> . FLOAT
    (33) expr -> . INT
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr GEQ expr
    (39) expr -> . expr > expr
    (40) expr -> . expr LEQ expr
    (41) expr -> . expr < expr
    (42) expr -> . ' expr
    (43) expr -> . - expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 20
    ONES            shift and go to state 22
    ZEROS           shift and go to state 23
    ID              shift and go to state 24
    [               shift and go to state 25
    STRING          shift and go to state 26
    FLOAT           shift and go to state 27
    INT             shift and go to state 28
    (               shift and go to state 21
    '               shift and go to state 29
    -               shift and go to state 30

    expr                           shift and go to state 85

state 51

    (38) expr -> expr GEQ . expr
    (26) expr -> . EYE ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . ZEROS ( expr )
    (29) expr -> . ID
    (30) expr -> . [ outerlist ]
    (31) expr -> . STRING
    (32) expr -> . FLOAT
    (33) expr -> . INT
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr GEQ expr
    (39) expr -> . expr > expr
    (40) expr -> . expr LEQ expr
    (41) expr -> . expr < expr
    (42) expr -> . ' expr
    (43) expr -> . - expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 20
    ONES            shift and go to state 22
    ZEROS           shift and go to state 23
    ID              shift and go to state 24
    [               shift and go to state 25
    STRING          shift and go to state 26
    FLOAT           shift and go to state 27
    INT             shift and go to state 28
    (               shift and go to state 21
    '               shift and go to state 29
    -               shift and go to state 30

    expr                           shift and go to state 86

state 52

    (39) expr -> expr > . expr
    (26) expr -> . EYE ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . ZEROS ( expr )
    (29) expr -> . ID
    (30) expr -> . [ outerlist ]
    (31) expr -> . STRING
    (32) expr -> . FLOAT
    (33) expr -> . INT
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr GEQ expr
    (39) expr -> . expr > expr
    (40) expr -> . expr LEQ expr
    (41) expr -> . expr < expr
    (42) expr -> . ' expr
    (43) expr -> . - expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 20
    ONES            shift and go to state 22
    ZEROS           shift and go to state 23
    ID              shift and go to state 24
    [               shift and go to state 25
    STRING          shift and go to state 26
    FLOAT           shift and go to state 27
    INT             shift and go to state 28
    (               shift and go to state 21
    '               shift and go to state 29
    -               shift and go to state 30

    expr                           shift and go to state 87

state 53

    (40) expr -> expr LEQ . expr
    (26) expr -> . EYE ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . ZEROS ( expr )
    (29) expr -> . ID
    (30) expr -> . [ outerlist ]
    (31) expr -> . STRING
    (32) expr -> . FLOAT
    (33) expr -> . INT
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr GEQ expr
    (39) expr -> . expr > expr
    (40) expr -> . expr LEQ expr
    (41) expr -> . expr < expr
    (42) expr -> . ' expr
    (43) expr -> . - expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 20
    ONES            shift and go to state 22
    ZEROS           shift and go to state 23
    ID              shift and go to state 24
    [               shift and go to state 25
    STRING          shift and go to state 26
    FLOAT           shift and go to state 27
    INT             shift and go to state 28
    (               shift and go to state 21
    '               shift and go to state 29
    -               shift and go to state 30

    expr                           shift and go to state 88

state 54

    (41) expr -> expr < . expr
    (26) expr -> . EYE ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . ZEROS ( expr )
    (29) expr -> . ID
    (30) expr -> . [ outerlist ]
    (31) expr -> . STRING
    (32) expr -> . FLOAT
    (33) expr -> . INT
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr GEQ expr
    (39) expr -> . expr > expr
    (40) expr -> . expr LEQ expr
    (41) expr -> . expr < expr
    (42) expr -> . ' expr
    (43) expr -> . - expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 20
    ONES            shift and go to state 22
    ZEROS           shift and go to state 23
    ID              shift and go to state 24
    [               shift and go to state 25
    STRING          shift and go to state 26
    FLOAT           shift and go to state 27
    INT             shift and go to state 28
    (               shift and go to state 21
    '               shift and go to state 29
    -               shift and go to state 30

    expr                           shift and go to state 89

state 55

    (44) expr -> expr MDIVIDE . expr
    (26) expr -> . EYE ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . ZEROS ( expr )
    (29) expr -> . ID
    (30) expr -> . [ outerlist ]
    (31) expr -> . STRING
    (32) expr -> . FLOAT
    (33) expr -> . INT
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr GEQ expr
    (39) expr -> . expr > expr
    (40) expr -> . expr LEQ expr
    (41) expr -> . expr < expr
    (42) expr -> . ' expr
    (43) expr -> . - expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 20
    ONES            shift and go to state 22
    ZEROS           shift and go to state 23
    ID              shift and go to state 24
    [               shift and go to state 25
    STRING          shift and go to state 26
    FLOAT           shift and go to state 27
    INT             shift and go to state 28
    (               shift and go to state 21
    '               shift and go to state 29
    -               shift and go to state 30

    expr                           shift and go to state 90

state 56

    (45) expr -> expr MTIMES . expr
    (26) expr -> . EYE ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . ZEROS ( expr )
    (29) expr -> . ID
    (30) expr -> . [ outerlist ]
    (31) expr -> . STRING
    (32) expr -> . FLOAT
    (33) expr -> . INT
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr GEQ expr
    (39) expr -> . expr > expr
    (40) expr -> . expr LEQ expr
    (41) expr -> . expr < expr
    (42) expr -> . ' expr
    (43) expr -> . - expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 20
    ONES            shift and go to state 22
    ZEROS           shift and go to state 23
    ID              shift and go to state 24
    [               shift and go to state 25
    STRING          shift and go to state 26
    FLOAT           shift and go to state 27
    INT             shift and go to state 28
    (               shift and go to state 21
    '               shift and go to state 29
    -               shift and go to state 30

    expr                           shift and go to state 91

state 57

    (46) expr -> expr MMINUS . expr
    (26) expr -> . EYE ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . ZEROS ( expr )
    (29) expr -> . ID
    (30) expr -> . [ outerlist ]
    (31) expr -> . STRING
    (32) expr -> . FLOAT
    (33) expr -> . INT
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr GEQ expr
    (39) expr -> . expr > expr
    (40) expr -> . expr LEQ expr
    (41) expr -> . expr < expr
    (42) expr -> . ' expr
    (43) expr -> . - expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 20
    ONES            shift and go to state 22
    ZEROS           shift and go to state 23
    ID              shift and go to state 24
    [               shift and go to state 25
    STRING          shift and go to state 26
    FLOAT           shift and go to state 27
    INT             shift and go to state 28
    (               shift and go to state 21
    '               shift and go to state 29
    -               shift and go to state 30

    expr                           shift and go to state 92

state 58

    (47) expr -> expr MPLUS . expr
    (26) expr -> . EYE ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . ZEROS ( expr )
    (29) expr -> . ID
    (30) expr -> . [ outerlist ]
    (31) expr -> . STRING
    (32) expr -> . FLOAT
    (33) expr -> . INT
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr GEQ expr
    (39) expr -> . expr > expr
    (40) expr -> . expr LEQ expr
    (41) expr -> . expr < expr
    (42) expr -> . ' expr
    (43) expr -> . - expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 20
    ONES            shift and go to state 22
    ZEROS           shift and go to state 23
    ID              shift and go to state 24
    [               shift and go to state 25
    STRING          shift and go to state 26
    FLOAT           shift and go to state 27
    INT             shift and go to state 28
    (               shift and go to state 21
    '               shift and go to state 29
    -               shift and go to state 30

    expr                           shift and go to state 93

state 59

    (48) expr -> expr / . expr
    (26) expr -> . EYE ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . ZEROS ( expr )
    (29) expr -> . ID
    (30) expr -> . [ outerlist ]
    (31) expr -> . STRING
    (32) expr -> . FLOAT
    (33) expr -> . INT
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr GEQ expr
    (39) expr -> . expr > expr
    (40) expr -> . expr LEQ expr
    (41) expr -> . expr < expr
    (42) expr -> . ' expr
    (43) expr -> . - expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 20
    ONES            shift and go to state 22
    ZEROS           shift and go to state 23
    ID              shift and go to state 24
    [               shift and go to state 25
    STRING          shift and go to state 26
    FLOAT           shift and go to state 27
    INT             shift and go to state 28
    (               shift and go to state 21
    '               shift and go to state 29
    -               shift and go to state 30

    expr                           shift and go to state 94

state 60

    (49) expr -> expr * . expr
    (26) expr -> . EYE ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . ZEROS ( expr )
    (29) expr -> . ID
    (30) expr -> . [ outerlist ]
    (31) expr -> . STRING
    (32) expr -> . FLOAT
    (33) expr -> . INT
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr GEQ expr
    (39) expr -> . expr > expr
    (40) expr -> . expr LEQ expr
    (41) expr -> . expr < expr
    (42) expr -> . ' expr
    (43) expr -> . - expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 20
    ONES            shift and go to state 22
    ZEROS           shift and go to state 23
    ID              shift and go to state 24
    [               shift and go to state 25
    STRING          shift and go to state 26
    FLOAT           shift and go to state 27
    INT             shift and go to state 28
    (               shift and go to state 21
    '               shift and go to state 29
    -               shift and go to state 30

    expr                           shift and go to state 95

state 61

    (50) expr -> expr - . expr
    (26) expr -> . EYE ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . ZEROS ( expr )
    (29) expr -> . ID
    (30) expr -> . [ outerlist ]
    (31) expr -> . STRING
    (32) expr -> . FLOAT
    (33) expr -> . INT
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr GEQ expr
    (39) expr -> . expr > expr
    (40) expr -> . expr LEQ expr
    (41) expr -> . expr < expr
    (42) expr -> . ' expr
    (43) expr -> . - expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 20
    ONES            shift and go to state 22
    ZEROS           shift and go to state 23
    ID              shift and go to state 24
    [               shift and go to state 25
    STRING          shift and go to state 26
    FLOAT           shift and go to state 27
    INT             shift and go to state 28
    (               shift and go to state 21
    '               shift and go to state 29
    -               shift and go to state 30

    expr                           shift and go to state 96

state 62

    (51) expr -> expr + . expr
    (26) expr -> . EYE ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . ZEROS ( expr )
    (29) expr -> . ID
    (30) expr -> . [ outerlist ]
    (31) expr -> . STRING
    (32) expr -> . FLOAT
    (33) expr -> . INT
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr GEQ expr
    (39) expr -> . expr > expr
    (40) expr -> . expr LEQ expr
    (41) expr -> . expr < expr
    (42) expr -> . ' expr
    (43) expr -> . - expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 20
    ONES            shift and go to state 22
    ZEROS           shift and go to state 23
    ID              shift and go to state 24
    [               shift and go to state 25
    STRING          shift and go to state 26
    FLOAT           shift and go to state 27
    INT             shift and go to state 28
    (               shift and go to state 21
    '               shift and go to state 29
    -               shift and go to state 30

    expr                           shift and go to state 97

state 63

    (26) expr -> EYE ( . expr )
    (26) expr -> . EYE ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . ZEROS ( expr )
    (29) expr -> . ID
    (30) expr -> . [ outerlist ]
    (31) expr -> . STRING
    (32) expr -> . FLOAT
    (33) expr -> . INT
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr GEQ expr
    (39) expr -> . expr > expr
    (40) expr -> . expr LEQ expr
    (41) expr -> . expr < expr
    (42) expr -> . ' expr
    (43) expr -> . - expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 20
    ONES            shift and go to state 22
    ZEROS           shift and go to state 23
    ID              shift and go to state 24
    [               shift and go to state 25
    STRING          shift and go to state 26
    FLOAT           shift and go to state 27
    INT             shift and go to state 28
    (               shift and go to state 21
    '               shift and go to state 29
    -               shift and go to state 30

    expr                           shift and go to state 98

state 64

    (35) expr -> ( expr . )
    (34) expr -> expr . '
    (36) expr -> expr . NEQ expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . GEQ expr
    (39) expr -> expr . > expr
    (40) expr -> expr . LEQ expr
    (41) expr -> expr . < expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . MTIMES expr
    (46) expr -> expr . MMINUS expr
    (47) expr -> expr . MPLUS expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    )               shift and go to state 99
    '               shift and go to state 48
    NEQ             shift and go to state 49
    EQ              shift and go to state 50
    GEQ             shift and go to state 51
    >               shift and go to state 52
    LEQ             shift and go to state 53
    <               shift and go to state 54
    MDIVIDE         shift and go to state 55
    MTIMES          shift and go to state 56
    MMINUS          shift and go to state 57
    MPLUS           shift and go to state 58
    /               shift and go to state 59
    *               shift and go to state 60
    -               shift and go to state 61
    +               shift and go to state 62


state 65

    (27) expr -> ONES ( . expr )
    (26) expr -> . EYE ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . ZEROS ( expr )
    (29) expr -> . ID
    (30) expr -> . [ outerlist ]
    (31) expr -> . STRING
    (32) expr -> . FLOAT
    (33) expr -> . INT
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr GEQ expr
    (39) expr -> . expr > expr
    (40) expr -> . expr LEQ expr
    (41) expr -> . expr < expr
    (42) expr -> . ' expr
    (43) expr -> . - expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 20
    ONES            shift and go to state 22
    ZEROS           shift and go to state 23
    ID              shift and go to state 24
    [               shift and go to state 25
    STRING          shift and go to state 26
    FLOAT           shift and go to state 27
    INT             shift and go to state 28
    (               shift and go to state 21
    '               shift and go to state 29
    -               shift and go to state 30

    expr                           shift and go to state 100

state 66

    (28) expr -> ZEROS ( . expr )
    (26) expr -> . EYE ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . ZEROS ( expr )
    (29) expr -> . ID
    (30) expr -> . [ outerlist ]
    (31) expr -> . STRING
    (32) expr -> . FLOAT
    (33) expr -> . INT
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr GEQ expr
    (39) expr -> . expr > expr
    (40) expr -> . expr LEQ expr
    (41) expr -> . expr < expr
    (42) expr -> . ' expr
    (43) expr -> . - expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 20
    ONES            shift and go to state 22
    ZEROS           shift and go to state 23
    ID              shift and go to state 24
    [               shift and go to state 25
    STRING          shift and go to state 26
    FLOAT           shift and go to state 27
    INT             shift and go to state 28
    (               shift and go to state 21
    '               shift and go to state 29
    -               shift and go to state 30

    expr                           shift and go to state 101

state 67

    (53) outerlist -> [ . values ]
    (24) values -> . expr
    (25) values -> . expr , values
    (26) expr -> . EYE ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . ZEROS ( expr )
    (29) expr -> . ID
    (30) expr -> . [ outerlist ]
    (31) expr -> . STRING
    (32) expr -> . FLOAT
    (33) expr -> . INT
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr GEQ expr
    (39) expr -> . expr > expr
    (40) expr -> . expr LEQ expr
    (41) expr -> . expr < expr
    (42) expr -> . ' expr
    (43) expr -> . - expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 20
    ONES            shift and go to state 22
    ZEROS           shift and go to state 23
    ID              shift and go to state 24
    [               shift and go to state 25
    STRING          shift and go to state 26
    FLOAT           shift and go to state 27
    INT             shift and go to state 28
    (               shift and go to state 21
    '               shift and go to state 29
    -               shift and go to state 30

    values                         shift and go to state 102
    expr                           shift and go to state 33

state 68

    (30) expr -> [ outerlist . ]
    (54) outerlist -> outerlist . , [ values ]
    ]               shift and go to state 103
    ,               shift and go to state 104


state 69

    (42) expr -> ' expr .
    (34) expr -> expr . '
    (36) expr -> expr . NEQ expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . GEQ expr
    (39) expr -> expr . > expr
    (40) expr -> expr . LEQ expr
    (41) expr -> expr . < expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . MTIMES expr
    (46) expr -> expr . MMINUS expr
    (47) expr -> expr . MPLUS expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    NEQ             reduce using rule 42 (expr -> ' expr .)
    EQ              reduce using rule 42 (expr -> ' expr .)
    GEQ             reduce using rule 42 (expr -> ' expr .)
    >               reduce using rule 42 (expr -> ' expr .)
    LEQ             reduce using rule 42 (expr -> ' expr .)
    <               reduce using rule 42 (expr -> ' expr .)
    MDIVIDE         reduce using rule 42 (expr -> ' expr .)
    MTIMES          reduce using rule 42 (expr -> ' expr .)
    MMINUS          reduce using rule 42 (expr -> ' expr .)
    MPLUS           reduce using rule 42 (expr -> ' expr .)
    /               reduce using rule 42 (expr -> ' expr .)
    *               reduce using rule 42 (expr -> ' expr .)
    -               reduce using rule 42 (expr -> ' expr .)
    +               reduce using rule 42 (expr -> ' expr .)
    {               reduce using rule 42 (expr -> ' expr .)
    FOR             reduce using rule 42 (expr -> ' expr .)
    WHILE           reduce using rule 42 (expr -> ' expr .)
    IF              reduce using rule 42 (expr -> ' expr .)
    PRINT           reduce using rule 42 (expr -> ' expr .)
    BREAK           reduce using rule 42 (expr -> ' expr .)
    CONTINUE        reduce using rule 42 (expr -> ' expr .)
    RETURN          reduce using rule 42 (expr -> ' expr .)
    ID              reduce using rule 42 (expr -> ' expr .)
    ,               reduce using rule 42 (expr -> ' expr .)
    ;               reduce using rule 42 (expr -> ' expr .)
    )               reduce using rule 42 (expr -> ' expr .)
    :               reduce using rule 42 (expr -> ' expr .)
    ]               reduce using rule 42 (expr -> ' expr .)
    '               shift and go to state 48


state 70

    (43) expr -> - expr .
    (34) expr -> expr . '
    (36) expr -> expr . NEQ expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . GEQ expr
    (39) expr -> expr . > expr
    (40) expr -> expr . LEQ expr
    (41) expr -> expr . < expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . MTIMES expr
    (46) expr -> expr . MMINUS expr
    (47) expr -> expr . MPLUS expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    NEQ             reduce using rule 43 (expr -> - expr .)
    EQ              reduce using rule 43 (expr -> - expr .)
    GEQ             reduce using rule 43 (expr -> - expr .)
    >               reduce using rule 43 (expr -> - expr .)
    LEQ             reduce using rule 43 (expr -> - expr .)
    <               reduce using rule 43 (expr -> - expr .)
    MDIVIDE         reduce using rule 43 (expr -> - expr .)
    MTIMES          reduce using rule 43 (expr -> - expr .)
    MMINUS          reduce using rule 43 (expr -> - expr .)
    MPLUS           reduce using rule 43 (expr -> - expr .)
    /               reduce using rule 43 (expr -> - expr .)
    *               reduce using rule 43 (expr -> - expr .)
    -               reduce using rule 43 (expr -> - expr .)
    +               reduce using rule 43 (expr -> - expr .)
    {               reduce using rule 43 (expr -> - expr .)
    FOR             reduce using rule 43 (expr -> - expr .)
    WHILE           reduce using rule 43 (expr -> - expr .)
    IF              reduce using rule 43 (expr -> - expr .)
    PRINT           reduce using rule 43 (expr -> - expr .)
    BREAK           reduce using rule 43 (expr -> - expr .)
    CONTINUE        reduce using rule 43 (expr -> - expr .)
    RETURN          reduce using rule 43 (expr -> - expr .)
    ID              reduce using rule 43 (expr -> - expr .)
    ,               reduce using rule 43 (expr -> - expr .)
    ;               reduce using rule 43 (expr -> - expr .)
    )               reduce using rule 43 (expr -> - expr .)
    :               reduce using rule 43 (expr -> - expr .)
    ]               reduce using rule 43 (expr -> - expr .)
    '               shift and go to state 48


state 71

    (9) statement -> IF expr block . ELSE block
    (10) statement -> IF expr block .
    ELSE            shift and go to state 105
    {               reduce using rule 10 (statement -> IF expr block .)
    FOR             reduce using rule 10 (statement -> IF expr block .)
    WHILE           reduce using rule 10 (statement -> IF expr block .)
    IF              reduce using rule 10 (statement -> IF expr block .)
    PRINT           reduce using rule 10 (statement -> IF expr block .)
    BREAK           reduce using rule 10 (statement -> IF expr block .)
    CONTINUE        reduce using rule 10 (statement -> IF expr block .)
    RETURN          reduce using rule 10 (statement -> IF expr block .)
    ID              reduce using rule 10 (statement -> IF expr block .)
    $end            reduce using rule 10 (statement -> IF expr block .)
    }               reduce using rule 10 (statement -> IF expr block .)


state 72

    (11) statement -> PRINT values ; .
    {               reduce using rule 11 (statement -> PRINT values ; .)
    FOR             reduce using rule 11 (statement -> PRINT values ; .)
    WHILE           reduce using rule 11 (statement -> PRINT values ; .)
    IF              reduce using rule 11 (statement -> PRINT values ; .)
    PRINT           reduce using rule 11 (statement -> PRINT values ; .)
    BREAK           reduce using rule 11 (statement -> PRINT values ; .)
    CONTINUE        reduce using rule 11 (statement -> PRINT values ; .)
    RETURN          reduce using rule 11 (statement -> PRINT values ; .)
    ID              reduce using rule 11 (statement -> PRINT values ; .)
    $end            reduce using rule 11 (statement -> PRINT values ; .)
    }               reduce using rule 11 (statement -> PRINT values ; .)
    ELSE            reduce using rule 11 (statement -> PRINT values ; .)


state 73

    (25) values -> expr , . values
    (24) values -> . expr
    (25) values -> . expr , values
    (26) expr -> . EYE ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . ZEROS ( expr )
    (29) expr -> . ID
    (30) expr -> . [ outerlist ]
    (31) expr -> . STRING
    (32) expr -> . FLOAT
    (33) expr -> . INT
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr GEQ expr
    (39) expr -> . expr > expr
    (40) expr -> . expr LEQ expr
    (41) expr -> . expr < expr
    (42) expr -> . ' expr
    (43) expr -> . - expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 20
    ONES            shift and go to state 22
    ZEROS           shift and go to state 23
    ID              shift and go to state 24
    [               shift and go to state 25
    STRING          shift and go to state 26
    FLOAT           shift and go to state 27
    INT             shift and go to state 28
    (               shift and go to state 21
    '               shift and go to state 29
    -               shift and go to state 30

    expr                           shift and go to state 33
    values                         shift and go to state 106

state 74

    (14) statement -> RETURN expr ; .
    {               reduce using rule 14 (statement -> RETURN expr ; .)
    FOR             reduce using rule 14 (statement -> RETURN expr ; .)
    WHILE           reduce using rule 14 (statement -> RETURN expr ; .)
    IF              reduce using rule 14 (statement -> RETURN expr ; .)
    PRINT           reduce using rule 14 (statement -> RETURN expr ; .)
    BREAK           reduce using rule 14 (statement -> RETURN expr ; .)
    CONTINUE        reduce using rule 14 (statement -> RETURN expr ; .)
    RETURN          reduce using rule 14 (statement -> RETURN expr ; .)
    ID              reduce using rule 14 (statement -> RETURN expr ; .)
    $end            reduce using rule 14 (statement -> RETURN expr ; .)
    }               reduce using rule 14 (statement -> RETURN expr ; .)
    ELSE            reduce using rule 14 (statement -> RETURN expr ; .)


state 75

    (15) statement -> left_assign DASSIGN expr . ;
    (34) expr -> expr . '
    (36) expr -> expr . NEQ expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . GEQ expr
    (39) expr -> expr . > expr
    (40) expr -> expr . LEQ expr
    (41) expr -> expr . < expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . MTIMES expr
    (46) expr -> expr . MMINUS expr
    (47) expr -> expr . MPLUS expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    ;               shift and go to state 107
    '               shift and go to state 48
    NEQ             shift and go to state 49
    EQ              shift and go to state 50
    GEQ             shift and go to state 51
    >               shift and go to state 52
    LEQ             shift and go to state 53
    <               shift and go to state 54
    MDIVIDE         shift and go to state 55
    MTIMES          shift and go to state 56
    MMINUS          shift and go to state 57
    MPLUS           shift and go to state 58
    /               shift and go to state 59
    *               shift and go to state 60
    -               shift and go to state 61
    +               shift and go to state 62


state 76

    (16) statement -> left_assign TASSIGN expr . ;
    (34) expr -> expr . '
    (36) expr -> expr . NEQ expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . GEQ expr
    (39) expr -> expr . > expr
    (40) expr -> expr . LEQ expr
    (41) expr -> expr . < expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . MTIMES expr
    (46) expr -> expr . MMINUS expr
    (47) expr -> expr . MPLUS expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    ;               shift and go to state 108
    '               shift and go to state 48
    NEQ             shift and go to state 49
    EQ              shift and go to state 50
    GEQ             shift and go to state 51
    >               shift and go to state 52
    LEQ             shift and go to state 53
    <               shift and go to state 54
    MDIVIDE         shift and go to state 55
    MTIMES          shift and go to state 56
    MMINUS          shift and go to state 57
    MPLUS           shift and go to state 58
    /               shift and go to state 59
    *               shift and go to state 60
    -               shift and go to state 61
    +               shift and go to state 62


state 77

    (17) statement -> left_assign MASSIGN expr . ;
    (34) expr -> expr . '
    (36) expr -> expr . NEQ expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . GEQ expr
    (39) expr -> expr . > expr
    (40) expr -> expr . LEQ expr
    (41) expr -> expr . < expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . MTIMES expr
    (46) expr -> expr . MMINUS expr
    (47) expr -> expr . MPLUS expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    ;               shift and go to state 109
    '               shift and go to state 48
    NEQ             shift and go to state 49
    EQ              shift and go to state 50
    GEQ             shift and go to state 51
    >               shift and go to state 52
    LEQ             shift and go to state 53
    <               shift and go to state 54
    MDIVIDE         shift and go to state 55
    MTIMES          shift and go to state 56
    MMINUS          shift and go to state 57
    MPLUS           shift and go to state 58
    /               shift and go to state 59
    *               shift and go to state 60
    -               shift and go to state 61
    +               shift and go to state 62


state 78

    (18) statement -> left_assign PASSIGN expr . ;
    (34) expr -> expr . '
    (36) expr -> expr . NEQ expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . GEQ expr
    (39) expr -> expr . > expr
    (40) expr -> expr . LEQ expr
    (41) expr -> expr . < expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . MTIMES expr
    (46) expr -> expr . MMINUS expr
    (47) expr -> expr . MPLUS expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    ;               shift and go to state 110
    '               shift and go to state 48
    NEQ             shift and go to state 49
    EQ              shift and go to state 50
    GEQ             shift and go to state 51
    >               shift and go to state 52
    LEQ             shift and go to state 53
    <               shift and go to state 54
    MDIVIDE         shift and go to state 55
    MTIMES          shift and go to state 56
    MMINUS          shift and go to state 57
    MPLUS           shift and go to state 58
    /               shift and go to state 59
    *               shift and go to state 60
    -               shift and go to state 61
    +               shift and go to state 62


state 79

    (19) statement -> left_assign = expr . ;
    (34) expr -> expr . '
    (36) expr -> expr . NEQ expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . GEQ expr
    (39) expr -> expr . > expr
    (40) expr -> expr . LEQ expr
    (41) expr -> expr . < expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . MTIMES expr
    (46) expr -> expr . MMINUS expr
    (47) expr -> expr . MPLUS expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    ;               shift and go to state 111
    '               shift and go to state 48
    NEQ             shift and go to state 49
    EQ              shift and go to state 50
    GEQ             shift and go to state 51
    >               shift and go to state 52
    LEQ             shift and go to state 53
    <               shift and go to state 54
    MDIVIDE         shift and go to state 55
    MTIMES          shift and go to state 56
    MMINUS          shift and go to state 57
    MPLUS           shift and go to state 58
    /               shift and go to state 59
    *               shift and go to state 60
    -               shift and go to state 61
    +               shift and go to state 62


state 80

    (7) statement -> FOR ID = range . block
    (3) block -> . { next_statements }
    (4) block -> . statement
    (7) statement -> . FOR ID = range block
    (8) statement -> . WHILE expr block
    (9) statement -> . IF expr block ELSE block
    (10) statement -> . IF expr block
    (11) statement -> . PRINT values ;
    (12) statement -> . BREAK ;
    (13) statement -> . CONTINUE ;
    (14) statement -> . RETURN expr ;
    (15) statement -> . left_assign DASSIGN expr ;
    (16) statement -> . left_assign TASSIGN expr ;
    (17) statement -> . left_assign MASSIGN expr ;
    (18) statement -> . left_assign PASSIGN expr ;
    (19) statement -> . left_assign = expr ;
    (20) left_assign -> . ID [ indexes ]
    (21) left_assign -> . ID
    {               shift and go to state 3
    FOR             shift and go to state 5
    WHILE           shift and go to state 7
    IF              shift and go to state 8
    PRINT           shift and go to state 9
    BREAK           shift and go to state 10
    CONTINUE        shift and go to state 11
    RETURN          shift and go to state 12
    ID              shift and go to state 6

    block                          shift and go to state 112
    statement                      shift and go to state 4
    left_assign                    shift and go to state 13

state 81

    (52) range -> expr . : expr
    (34) expr -> expr . '
    (36) expr -> expr . NEQ expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . GEQ expr
    (39) expr -> expr . > expr
    (40) expr -> expr . LEQ expr
    (41) expr -> expr . < expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . MTIMES expr
    (46) expr -> expr . MMINUS expr
    (47) expr -> expr . MPLUS expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    :               shift and go to state 113
    '               shift and go to state 48
    NEQ             shift and go to state 49
    EQ              shift and go to state 50
    GEQ             shift and go to state 51
    >               shift and go to state 52
    LEQ             shift and go to state 53
    <               shift and go to state 54
    MDIVIDE         shift and go to state 55
    MTIMES          shift and go to state 56
    MMINUS          shift and go to state 57
    MPLUS           shift and go to state 58
    /               shift and go to state 59
    *               shift and go to state 60
    -               shift and go to state 61
    +               shift and go to state 62


state 82

    (20) left_assign -> ID [ indexes ] .
    DASSIGN         reduce using rule 20 (left_assign -> ID [ indexes ] .)
    TASSIGN         reduce using rule 20 (left_assign -> ID [ indexes ] .)
    MASSIGN         reduce using rule 20 (left_assign -> ID [ indexes ] .)
    PASSIGN         reduce using rule 20 (left_assign -> ID [ indexes ] .)
    =               reduce using rule 20 (left_assign -> ID [ indexes ] .)


state 83

    (23) indexes -> INT , . indexes
    (22) indexes -> . INT
    (23) indexes -> . INT , indexes
    INT             shift and go to state 46

    indexes                        shift and go to state 114

state 84

    (36) expr -> expr NEQ expr .
    (34) expr -> expr . '
    (36) expr -> expr . NEQ expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . GEQ expr
    (39) expr -> expr . > expr
    (40) expr -> expr . LEQ expr
    (41) expr -> expr . < expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . MTIMES expr
    (46) expr -> expr . MMINUS expr
    (47) expr -> expr . MPLUS expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    NEQ             reduce using rule 36 (expr -> expr NEQ expr .)
    EQ              reduce using rule 36 (expr -> expr NEQ expr .)
    GEQ             reduce using rule 36 (expr -> expr NEQ expr .)
    >               reduce using rule 36 (expr -> expr NEQ expr .)
    LEQ             reduce using rule 36 (expr -> expr NEQ expr .)
    <               reduce using rule 36 (expr -> expr NEQ expr .)
    {               reduce using rule 36 (expr -> expr NEQ expr .)
    FOR             reduce using rule 36 (expr -> expr NEQ expr .)
    WHILE           reduce using rule 36 (expr -> expr NEQ expr .)
    IF              reduce using rule 36 (expr -> expr NEQ expr .)
    PRINT           reduce using rule 36 (expr -> expr NEQ expr .)
    BREAK           reduce using rule 36 (expr -> expr NEQ expr .)
    CONTINUE        reduce using rule 36 (expr -> expr NEQ expr .)
    RETURN          reduce using rule 36 (expr -> expr NEQ expr .)
    ID              reduce using rule 36 (expr -> expr NEQ expr .)
    ,               reduce using rule 36 (expr -> expr NEQ expr .)
    ;               reduce using rule 36 (expr -> expr NEQ expr .)
    )               reduce using rule 36 (expr -> expr NEQ expr .)
    :               reduce using rule 36 (expr -> expr NEQ expr .)
    ]               reduce using rule 36 (expr -> expr NEQ expr .)
    '               shift and go to state 48
    MDIVIDE         shift and go to state 55
    MTIMES          shift and go to state 56
    MMINUS          shift and go to state 57
    MPLUS           shift and go to state 58
    /               shift and go to state 59
    *               shift and go to state 60
    -               shift and go to state 61
    +               shift and go to state 62


state 85

    (37) expr -> expr EQ expr .
    (34) expr -> expr . '
    (36) expr -> expr . NEQ expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . GEQ expr
    (39) expr -> expr . > expr
    (40) expr -> expr . LEQ expr
    (41) expr -> expr . < expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . MTIMES expr
    (46) expr -> expr . MMINUS expr
    (47) expr -> expr . MPLUS expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    NEQ             reduce using rule 37 (expr -> expr EQ expr .)
    EQ              reduce using rule 37 (expr -> expr EQ expr .)
    GEQ             reduce using rule 37 (expr -> expr EQ expr .)
    >               reduce using rule 37 (expr -> expr EQ expr .)
    LEQ             reduce using rule 37 (expr -> expr EQ expr .)
    <               reduce using rule 37 (expr -> expr EQ expr .)
    {               reduce using rule 37 (expr -> expr EQ expr .)
    FOR             reduce using rule 37 (expr -> expr EQ expr .)
    WHILE           reduce using rule 37 (expr -> expr EQ expr .)
    IF              reduce using rule 37 (expr -> expr EQ expr .)
    PRINT           reduce using rule 37 (expr -> expr EQ expr .)
    BREAK           reduce using rule 37 (expr -> expr EQ expr .)
    CONTINUE        reduce using rule 37 (expr -> expr EQ expr .)
    RETURN          reduce using rule 37 (expr -> expr EQ expr .)
    ID              reduce using rule 37 (expr -> expr EQ expr .)
    ,               reduce using rule 37 (expr -> expr EQ expr .)
    ;               reduce using rule 37 (expr -> expr EQ expr .)
    )               reduce using rule 37 (expr -> expr EQ expr .)
    :               reduce using rule 37 (expr -> expr EQ expr .)
    ]               reduce using rule 37 (expr -> expr EQ expr .)
    '               shift and go to state 48
    MDIVIDE         shift and go to state 55
    MTIMES          shift and go to state 56
    MMINUS          shift and go to state 57
    MPLUS           shift and go to state 58
    /               shift and go to state 59
    *               shift and go to state 60
    -               shift and go to state 61
    +               shift and go to state 62


state 86

    (38) expr -> expr GEQ expr .
    (34) expr -> expr . '
    (36) expr -> expr . NEQ expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . GEQ expr
    (39) expr -> expr . > expr
    (40) expr -> expr . LEQ expr
    (41) expr -> expr . < expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . MTIMES expr
    (46) expr -> expr . MMINUS expr
    (47) expr -> expr . MPLUS expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    NEQ             reduce using rule 38 (expr -> expr GEQ expr .)
    EQ              reduce using rule 38 (expr -> expr GEQ expr .)
    GEQ             reduce using rule 38 (expr -> expr GEQ expr .)
    >               reduce using rule 38 (expr -> expr GEQ expr .)
    LEQ             reduce using rule 38 (expr -> expr GEQ expr .)
    <               reduce using rule 38 (expr -> expr GEQ expr .)
    {               reduce using rule 38 (expr -> expr GEQ expr .)
    FOR             reduce using rule 38 (expr -> expr GEQ expr .)
    WHILE           reduce using rule 38 (expr -> expr GEQ expr .)
    IF              reduce using rule 38 (expr -> expr GEQ expr .)
    PRINT           reduce using rule 38 (expr -> expr GEQ expr .)
    BREAK           reduce using rule 38 (expr -> expr GEQ expr .)
    CONTINUE        reduce using rule 38 (expr -> expr GEQ expr .)
    RETURN          reduce using rule 38 (expr -> expr GEQ expr .)
    ID              reduce using rule 38 (expr -> expr GEQ expr .)
    ,               reduce using rule 38 (expr -> expr GEQ expr .)
    ;               reduce using rule 38 (expr -> expr GEQ expr .)
    )               reduce using rule 38 (expr -> expr GEQ expr .)
    :               reduce using rule 38 (expr -> expr GEQ expr .)
    ]               reduce using rule 38 (expr -> expr GEQ expr .)
    '               shift and go to state 48
    MDIVIDE         shift and go to state 55
    MTIMES          shift and go to state 56
    MMINUS          shift and go to state 57
    MPLUS           shift and go to state 58
    /               shift and go to state 59
    *               shift and go to state 60
    -               shift and go to state 61
    +               shift and go to state 62


state 87

    (39) expr -> expr > expr .
    (34) expr -> expr . '
    (36) expr -> expr . NEQ expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . GEQ expr
    (39) expr -> expr . > expr
    (40) expr -> expr . LEQ expr
    (41) expr -> expr . < expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . MTIMES expr
    (46) expr -> expr . MMINUS expr
    (47) expr -> expr . MPLUS expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    NEQ             reduce using rule 39 (expr -> expr > expr .)
    EQ              reduce using rule 39 (expr -> expr > expr .)
    GEQ             reduce using rule 39 (expr -> expr > expr .)
    >               reduce using rule 39 (expr -> expr > expr .)
    LEQ             reduce using rule 39 (expr -> expr > expr .)
    <               reduce using rule 39 (expr -> expr > expr .)
    {               reduce using rule 39 (expr -> expr > expr .)
    FOR             reduce using rule 39 (expr -> expr > expr .)
    WHILE           reduce using rule 39 (expr -> expr > expr .)
    IF              reduce using rule 39 (expr -> expr > expr .)
    PRINT           reduce using rule 39 (expr -> expr > expr .)
    BREAK           reduce using rule 39 (expr -> expr > expr .)
    CONTINUE        reduce using rule 39 (expr -> expr > expr .)
    RETURN          reduce using rule 39 (expr -> expr > expr .)
    ID              reduce using rule 39 (expr -> expr > expr .)
    ,               reduce using rule 39 (expr -> expr > expr .)
    ;               reduce using rule 39 (expr -> expr > expr .)
    )               reduce using rule 39 (expr -> expr > expr .)
    :               reduce using rule 39 (expr -> expr > expr .)
    ]               reduce using rule 39 (expr -> expr > expr .)
    '               shift and go to state 48
    MDIVIDE         shift and go to state 55
    MTIMES          shift and go to state 56
    MMINUS          shift and go to state 57
    MPLUS           shift and go to state 58
    /               shift and go to state 59
    *               shift and go to state 60
    -               shift and go to state 61
    +               shift and go to state 62


state 88

    (40) expr -> expr LEQ expr .
    (34) expr -> expr . '
    (36) expr -> expr . NEQ expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . GEQ expr
    (39) expr -> expr . > expr
    (40) expr -> expr . LEQ expr
    (41) expr -> expr . < expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . MTIMES expr
    (46) expr -> expr . MMINUS expr
    (47) expr -> expr . MPLUS expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    NEQ             reduce using rule 40 (expr -> expr LEQ expr .)
    EQ              reduce using rule 40 (expr -> expr LEQ expr .)
    GEQ             reduce using rule 40 (expr -> expr LEQ expr .)
    >               reduce using rule 40 (expr -> expr LEQ expr .)
    LEQ             reduce using rule 40 (expr -> expr LEQ expr .)
    <               reduce using rule 40 (expr -> expr LEQ expr .)
    {               reduce using rule 40 (expr -> expr LEQ expr .)
    FOR             reduce using rule 40 (expr -> expr LEQ expr .)
    WHILE           reduce using rule 40 (expr -> expr LEQ expr .)
    IF              reduce using rule 40 (expr -> expr LEQ expr .)
    PRINT           reduce using rule 40 (expr -> expr LEQ expr .)
    BREAK           reduce using rule 40 (expr -> expr LEQ expr .)
    CONTINUE        reduce using rule 40 (expr -> expr LEQ expr .)
    RETURN          reduce using rule 40 (expr -> expr LEQ expr .)
    ID              reduce using rule 40 (expr -> expr LEQ expr .)
    ,               reduce using rule 40 (expr -> expr LEQ expr .)
    ;               reduce using rule 40 (expr -> expr LEQ expr .)
    )               reduce using rule 40 (expr -> expr LEQ expr .)
    :               reduce using rule 40 (expr -> expr LEQ expr .)
    ]               reduce using rule 40 (expr -> expr LEQ expr .)
    '               shift and go to state 48
    MDIVIDE         shift and go to state 55
    MTIMES          shift and go to state 56
    MMINUS          shift and go to state 57
    MPLUS           shift and go to state 58
    /               shift and go to state 59
    *               shift and go to state 60
    -               shift and go to state 61
    +               shift and go to state 62


state 89

    (41) expr -> expr < expr .
    (34) expr -> expr . '
    (36) expr -> expr . NEQ expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . GEQ expr
    (39) expr -> expr . > expr
    (40) expr -> expr . LEQ expr
    (41) expr -> expr . < expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . MTIMES expr
    (46) expr -> expr . MMINUS expr
    (47) expr -> expr . MPLUS expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    NEQ             reduce using rule 41 (expr -> expr < expr .)
    EQ              reduce using rule 41 (expr -> expr < expr .)
    GEQ             reduce using rule 41 (expr -> expr < expr .)
    >               reduce using rule 41 (expr -> expr < expr .)
    LEQ             reduce using rule 41 (expr -> expr < expr .)
    <               reduce using rule 41 (expr -> expr < expr .)
    {               reduce using rule 41 (expr -> expr < expr .)
    FOR             reduce using rule 41 (expr -> expr < expr .)
    WHILE           reduce using rule 41 (expr -> expr < expr .)
    IF              reduce using rule 41 (expr -> expr < expr .)
    PRINT           reduce using rule 41 (expr -> expr < expr .)
    BREAK           reduce using rule 41 (expr -> expr < expr .)
    CONTINUE        reduce using rule 41 (expr -> expr < expr .)
    RETURN          reduce using rule 41 (expr -> expr < expr .)
    ID              reduce using rule 41 (expr -> expr < expr .)
    ,               reduce using rule 41 (expr -> expr < expr .)
    ;               reduce using rule 41 (expr -> expr < expr .)
    )               reduce using rule 41 (expr -> expr < expr .)
    :               reduce using rule 41 (expr -> expr < expr .)
    ]               reduce using rule 41 (expr -> expr < expr .)
    '               shift and go to state 48
    MDIVIDE         shift and go to state 55
    MTIMES          shift and go to state 56
    MMINUS          shift and go to state 57
    MPLUS           shift and go to state 58
    /               shift and go to state 59
    *               shift and go to state 60
    -               shift and go to state 61
    +               shift and go to state 62


state 90

    (44) expr -> expr MDIVIDE expr .
    (34) expr -> expr . '
    (36) expr -> expr . NEQ expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . GEQ expr
    (39) expr -> expr . > expr
    (40) expr -> expr . LEQ expr
    (41) expr -> expr . < expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . MTIMES expr
    (46) expr -> expr . MMINUS expr
    (47) expr -> expr . MPLUS expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    NEQ             reduce using rule 44 (expr -> expr MDIVIDE expr .)
    EQ              reduce using rule 44 (expr -> expr MDIVIDE expr .)
    GEQ             reduce using rule 44 (expr -> expr MDIVIDE expr .)
    >               reduce using rule 44 (expr -> expr MDIVIDE expr .)
    LEQ             reduce using rule 44 (expr -> expr MDIVIDE expr .)
    <               reduce using rule 44 (expr -> expr MDIVIDE expr .)
    MDIVIDE         reduce using rule 44 (expr -> expr MDIVIDE expr .)
    MTIMES          reduce using rule 44 (expr -> expr MDIVIDE expr .)
    MMINUS          reduce using rule 44 (expr -> expr MDIVIDE expr .)
    MPLUS           reduce using rule 44 (expr -> expr MDIVIDE expr .)
    /               reduce using rule 44 (expr -> expr MDIVIDE expr .)
    *               reduce using rule 44 (expr -> expr MDIVIDE expr .)
    -               reduce using rule 44 (expr -> expr MDIVIDE expr .)
    +               reduce using rule 44 (expr -> expr MDIVIDE expr .)
    {               reduce using rule 44 (expr -> expr MDIVIDE expr .)
    FOR             reduce using rule 44 (expr -> expr MDIVIDE expr .)
    WHILE           reduce using rule 44 (expr -> expr MDIVIDE expr .)
    IF              reduce using rule 44 (expr -> expr MDIVIDE expr .)
    PRINT           reduce using rule 44 (expr -> expr MDIVIDE expr .)
    BREAK           reduce using rule 44 (expr -> expr MDIVIDE expr .)
    CONTINUE        reduce using rule 44 (expr -> expr MDIVIDE expr .)
    RETURN          reduce using rule 44 (expr -> expr MDIVIDE expr .)
    ID              reduce using rule 44 (expr -> expr MDIVIDE expr .)
    ,               reduce using rule 44 (expr -> expr MDIVIDE expr .)
    ;               reduce using rule 44 (expr -> expr MDIVIDE expr .)
    )               reduce using rule 44 (expr -> expr MDIVIDE expr .)
    :               reduce using rule 44 (expr -> expr MDIVIDE expr .)
    ]               reduce using rule 44 (expr -> expr MDIVIDE expr .)
    '               shift and go to state 48


state 91

    (45) expr -> expr MTIMES expr .
    (34) expr -> expr . '
    (36) expr -> expr . NEQ expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . GEQ expr
    (39) expr -> expr . > expr
    (40) expr -> expr . LEQ expr
    (41) expr -> expr . < expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . MTIMES expr
    (46) expr -> expr . MMINUS expr
    (47) expr -> expr . MPLUS expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    NEQ             reduce using rule 45 (expr -> expr MTIMES expr .)
    EQ              reduce using rule 45 (expr -> expr MTIMES expr .)
    GEQ             reduce using rule 45 (expr -> expr MTIMES expr .)
    >               reduce using rule 45 (expr -> expr MTIMES expr .)
    LEQ             reduce using rule 45 (expr -> expr MTIMES expr .)
    <               reduce using rule 45 (expr -> expr MTIMES expr .)
    MDIVIDE         reduce using rule 45 (expr -> expr MTIMES expr .)
    MTIMES          reduce using rule 45 (expr -> expr MTIMES expr .)
    MMINUS          reduce using rule 45 (expr -> expr MTIMES expr .)
    MPLUS           reduce using rule 45 (expr -> expr MTIMES expr .)
    /               reduce using rule 45 (expr -> expr MTIMES expr .)
    *               reduce using rule 45 (expr -> expr MTIMES expr .)
    -               reduce using rule 45 (expr -> expr MTIMES expr .)
    +               reduce using rule 45 (expr -> expr MTIMES expr .)
    {               reduce using rule 45 (expr -> expr MTIMES expr .)
    FOR             reduce using rule 45 (expr -> expr MTIMES expr .)
    WHILE           reduce using rule 45 (expr -> expr MTIMES expr .)
    IF              reduce using rule 45 (expr -> expr MTIMES expr .)
    PRINT           reduce using rule 45 (expr -> expr MTIMES expr .)
    BREAK           reduce using rule 45 (expr -> expr MTIMES expr .)
    CONTINUE        reduce using rule 45 (expr -> expr MTIMES expr .)
    RETURN          reduce using rule 45 (expr -> expr MTIMES expr .)
    ID              reduce using rule 45 (expr -> expr MTIMES expr .)
    ,               reduce using rule 45 (expr -> expr MTIMES expr .)
    ;               reduce using rule 45 (expr -> expr MTIMES expr .)
    )               reduce using rule 45 (expr -> expr MTIMES expr .)
    :               reduce using rule 45 (expr -> expr MTIMES expr .)
    ]               reduce using rule 45 (expr -> expr MTIMES expr .)
    '               shift and go to state 48


state 92

    (46) expr -> expr MMINUS expr .
    (34) expr -> expr . '
    (36) expr -> expr . NEQ expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . GEQ expr
    (39) expr -> expr . > expr
    (40) expr -> expr . LEQ expr
    (41) expr -> expr . < expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . MTIMES expr
    (46) expr -> expr . MMINUS expr
    (47) expr -> expr . MPLUS expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    NEQ             reduce using rule 46 (expr -> expr MMINUS expr .)
    EQ              reduce using rule 46 (expr -> expr MMINUS expr .)
    GEQ             reduce using rule 46 (expr -> expr MMINUS expr .)
    >               reduce using rule 46 (expr -> expr MMINUS expr .)
    LEQ             reduce using rule 46 (expr -> expr MMINUS expr .)
    <               reduce using rule 46 (expr -> expr MMINUS expr .)
    MMINUS          reduce using rule 46 (expr -> expr MMINUS expr .)
    MPLUS           reduce using rule 46 (expr -> expr MMINUS expr .)
    -               reduce using rule 46 (expr -> expr MMINUS expr .)
    +               reduce using rule 46 (expr -> expr MMINUS expr .)
    {               reduce using rule 46 (expr -> expr MMINUS expr .)
    FOR             reduce using rule 46 (expr -> expr MMINUS expr .)
    WHILE           reduce using rule 46 (expr -> expr MMINUS expr .)
    IF              reduce using rule 46 (expr -> expr MMINUS expr .)
    PRINT           reduce using rule 46 (expr -> expr MMINUS expr .)
    BREAK           reduce using rule 46 (expr -> expr MMINUS expr .)
    CONTINUE        reduce using rule 46 (expr -> expr MMINUS expr .)
    RETURN          reduce using rule 46 (expr -> expr MMINUS expr .)
    ID              reduce using rule 46 (expr -> expr MMINUS expr .)
    ,               reduce using rule 46 (expr -> expr MMINUS expr .)
    ;               reduce using rule 46 (expr -> expr MMINUS expr .)
    )               reduce using rule 46 (expr -> expr MMINUS expr .)
    :               reduce using rule 46 (expr -> expr MMINUS expr .)
    ]               reduce using rule 46 (expr -> expr MMINUS expr .)
    '               shift and go to state 48
    MDIVIDE         shift and go to state 55
    MTIMES          shift and go to state 56
    /               shift and go to state 59
    *               shift and go to state 60


state 93

    (47) expr -> expr MPLUS expr .
    (34) expr -> expr . '
    (36) expr -> expr . NEQ expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . GEQ expr
    (39) expr -> expr . > expr
    (40) expr -> expr . LEQ expr
    (41) expr -> expr . < expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . MTIMES expr
    (46) expr -> expr . MMINUS expr
    (47) expr -> expr . MPLUS expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    NEQ             reduce using rule 47 (expr -> expr MPLUS expr .)
    EQ              reduce using rule 47 (expr -> expr MPLUS expr .)
    GEQ             reduce using rule 47 (expr -> expr MPLUS expr .)
    >               reduce using rule 47 (expr -> expr MPLUS expr .)
    LEQ             reduce using rule 47 (expr -> expr MPLUS expr .)
    <               reduce using rule 47 (expr -> expr MPLUS expr .)
    MMINUS          reduce using rule 47 (expr -> expr MPLUS expr .)
    MPLUS           reduce using rule 47 (expr -> expr MPLUS expr .)
    -               reduce using rule 47 (expr -> expr MPLUS expr .)
    +               reduce using rule 47 (expr -> expr MPLUS expr .)
    {               reduce using rule 47 (expr -> expr MPLUS expr .)
    FOR             reduce using rule 47 (expr -> expr MPLUS expr .)
    WHILE           reduce using rule 47 (expr -> expr MPLUS expr .)
    IF              reduce using rule 47 (expr -> expr MPLUS expr .)
    PRINT           reduce using rule 47 (expr -> expr MPLUS expr .)
    BREAK           reduce using rule 47 (expr -> expr MPLUS expr .)
    CONTINUE        reduce using rule 47 (expr -> expr MPLUS expr .)
    RETURN          reduce using rule 47 (expr -> expr MPLUS expr .)
    ID              reduce using rule 47 (expr -> expr MPLUS expr .)
    ,               reduce using rule 47 (expr -> expr MPLUS expr .)
    ;               reduce using rule 47 (expr -> expr MPLUS expr .)
    )               reduce using rule 47 (expr -> expr MPLUS expr .)
    :               reduce using rule 47 (expr -> expr MPLUS expr .)
    ]               reduce using rule 47 (expr -> expr MPLUS expr .)
    '               shift and go to state 48
    MDIVIDE         shift and go to state 55
    MTIMES          shift and go to state 56
    /               shift and go to state 59
    *               shift and go to state 60


state 94

    (48) expr -> expr / expr .
    (34) expr -> expr . '
    (36) expr -> expr . NEQ expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . GEQ expr
    (39) expr -> expr . > expr
    (40) expr -> expr . LEQ expr
    (41) expr -> expr . < expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . MTIMES expr
    (46) expr -> expr . MMINUS expr
    (47) expr -> expr . MPLUS expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    NEQ             reduce using rule 48 (expr -> expr / expr .)
    EQ              reduce using rule 48 (expr -> expr / expr .)
    GEQ             reduce using rule 48 (expr -> expr / expr .)
    >               reduce using rule 48 (expr -> expr / expr .)
    LEQ             reduce using rule 48 (expr -> expr / expr .)
    <               reduce using rule 48 (expr -> expr / expr .)
    MDIVIDE         reduce using rule 48 (expr -> expr / expr .)
    MTIMES          reduce using rule 48 (expr -> expr / expr .)
    MMINUS          reduce using rule 48 (expr -> expr / expr .)
    MPLUS           reduce using rule 48 (expr -> expr / expr .)
    /               reduce using rule 48 (expr -> expr / expr .)
    *               reduce using rule 48 (expr -> expr / expr .)
    -               reduce using rule 48 (expr -> expr / expr .)
    +               reduce using rule 48 (expr -> expr / expr .)
    {               reduce using rule 48 (expr -> expr / expr .)
    FOR             reduce using rule 48 (expr -> expr / expr .)
    WHILE           reduce using rule 48 (expr -> expr / expr .)
    IF              reduce using rule 48 (expr -> expr / expr .)
    PRINT           reduce using rule 48 (expr -> expr / expr .)
    BREAK           reduce using rule 48 (expr -> expr / expr .)
    CONTINUE        reduce using rule 48 (expr -> expr / expr .)
    RETURN          reduce using rule 48 (expr -> expr / expr .)
    ID              reduce using rule 48 (expr -> expr / expr .)
    ,               reduce using rule 48 (expr -> expr / expr .)
    ;               reduce using rule 48 (expr -> expr / expr .)
    )               reduce using rule 48 (expr -> expr / expr .)
    :               reduce using rule 48 (expr -> expr / expr .)
    ]               reduce using rule 48 (expr -> expr / expr .)
    '               shift and go to state 48


state 95

    (49) expr -> expr * expr .
    (34) expr -> expr . '
    (36) expr -> expr . NEQ expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . GEQ expr
    (39) expr -> expr . > expr
    (40) expr -> expr . LEQ expr
    (41) expr -> expr . < expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . MTIMES expr
    (46) expr -> expr . MMINUS expr
    (47) expr -> expr . MPLUS expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    NEQ             reduce using rule 49 (expr -> expr * expr .)
    EQ              reduce using rule 49 (expr -> expr * expr .)
    GEQ             reduce using rule 49 (expr -> expr * expr .)
    >               reduce using rule 49 (expr -> expr * expr .)
    LEQ             reduce using rule 49 (expr -> expr * expr .)
    <               reduce using rule 49 (expr -> expr * expr .)
    MDIVIDE         reduce using rule 49 (expr -> expr * expr .)
    MTIMES          reduce using rule 49 (expr -> expr * expr .)
    MMINUS          reduce using rule 49 (expr -> expr * expr .)
    MPLUS           reduce using rule 49 (expr -> expr * expr .)
    /               reduce using rule 49 (expr -> expr * expr .)
    *               reduce using rule 49 (expr -> expr * expr .)
    -               reduce using rule 49 (expr -> expr * expr .)
    +               reduce using rule 49 (expr -> expr * expr .)
    {               reduce using rule 49 (expr -> expr * expr .)
    FOR             reduce using rule 49 (expr -> expr * expr .)
    WHILE           reduce using rule 49 (expr -> expr * expr .)
    IF              reduce using rule 49 (expr -> expr * expr .)
    PRINT           reduce using rule 49 (expr -> expr * expr .)
    BREAK           reduce using rule 49 (expr -> expr * expr .)
    CONTINUE        reduce using rule 49 (expr -> expr * expr .)
    RETURN          reduce using rule 49 (expr -> expr * expr .)
    ID              reduce using rule 49 (expr -> expr * expr .)
    ,               reduce using rule 49 (expr -> expr * expr .)
    ;               reduce using rule 49 (expr -> expr * expr .)
    )               reduce using rule 49 (expr -> expr * expr .)
    :               reduce using rule 49 (expr -> expr * expr .)
    ]               reduce using rule 49 (expr -> expr * expr .)
    '               shift and go to state 48


state 96

    (50) expr -> expr - expr .
    (34) expr -> expr . '
    (36) expr -> expr . NEQ expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . GEQ expr
    (39) expr -> expr . > expr
    (40) expr -> expr . LEQ expr
    (41) expr -> expr . < expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . MTIMES expr
    (46) expr -> expr . MMINUS expr
    (47) expr -> expr . MPLUS expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    NEQ             reduce using rule 50 (expr -> expr - expr .)
    EQ              reduce using rule 50 (expr -> expr - expr .)
    GEQ             reduce using rule 50 (expr -> expr - expr .)
    >               reduce using rule 50 (expr -> expr - expr .)
    LEQ             reduce using rule 50 (expr -> expr - expr .)
    <               reduce using rule 50 (expr -> expr - expr .)
    MMINUS          reduce using rule 50 (expr -> expr - expr .)
    MPLUS           reduce using rule 50 (expr -> expr - expr .)
    -               reduce using rule 50 (expr -> expr - expr .)
    +               reduce using rule 50 (expr -> expr - expr .)
    {               reduce using rule 50 (expr -> expr - expr .)
    FOR             reduce using rule 50 (expr -> expr - expr .)
    WHILE           reduce using rule 50 (expr -> expr - expr .)
    IF              reduce using rule 50 (expr -> expr - expr .)
    PRINT           reduce using rule 50 (expr -> expr - expr .)
    BREAK           reduce using rule 50 (expr -> expr - expr .)
    CONTINUE        reduce using rule 50 (expr -> expr - expr .)
    RETURN          reduce using rule 50 (expr -> expr - expr .)
    ID              reduce using rule 50 (expr -> expr - expr .)
    ,               reduce using rule 50 (expr -> expr - expr .)
    ;               reduce using rule 50 (expr -> expr - expr .)
    )               reduce using rule 50 (expr -> expr - expr .)
    :               reduce using rule 50 (expr -> expr - expr .)
    ]               reduce using rule 50 (expr -> expr - expr .)
    '               shift and go to state 48
    MDIVIDE         shift and go to state 55
    MTIMES          shift and go to state 56
    /               shift and go to state 59
    *               shift and go to state 60


state 97

    (51) expr -> expr + expr .
    (34) expr -> expr . '
    (36) expr -> expr . NEQ expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . GEQ expr
    (39) expr -> expr . > expr
    (40) expr -> expr . LEQ expr
    (41) expr -> expr . < expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . MTIMES expr
    (46) expr -> expr . MMINUS expr
    (47) expr -> expr . MPLUS expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    NEQ             reduce using rule 51 (expr -> expr + expr .)
    EQ              reduce using rule 51 (expr -> expr + expr .)
    GEQ             reduce using rule 51 (expr -> expr + expr .)
    >               reduce using rule 51 (expr -> expr + expr .)
    LEQ             reduce using rule 51 (expr -> expr + expr .)
    <               reduce using rule 51 (expr -> expr + expr .)
    MMINUS          reduce using rule 51 (expr -> expr + expr .)
    MPLUS           reduce using rule 51 (expr -> expr + expr .)
    -               reduce using rule 51 (expr -> expr + expr .)
    +               reduce using rule 51 (expr -> expr + expr .)
    {               reduce using rule 51 (expr -> expr + expr .)
    FOR             reduce using rule 51 (expr -> expr + expr .)
    WHILE           reduce using rule 51 (expr -> expr + expr .)
    IF              reduce using rule 51 (expr -> expr + expr .)
    PRINT           reduce using rule 51 (expr -> expr + expr .)
    BREAK           reduce using rule 51 (expr -> expr + expr .)
    CONTINUE        reduce using rule 51 (expr -> expr + expr .)
    RETURN          reduce using rule 51 (expr -> expr + expr .)
    ID              reduce using rule 51 (expr -> expr + expr .)
    ,               reduce using rule 51 (expr -> expr + expr .)
    ;               reduce using rule 51 (expr -> expr + expr .)
    )               reduce using rule 51 (expr -> expr + expr .)
    :               reduce using rule 51 (expr -> expr + expr .)
    ]               reduce using rule 51 (expr -> expr + expr .)
    '               shift and go to state 48
    MDIVIDE         shift and go to state 55
    MTIMES          shift and go to state 56
    /               shift and go to state 59
    *               shift and go to state 60


state 98

    (26) expr -> EYE ( expr . )
    (34) expr -> expr . '
    (36) expr -> expr . NEQ expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . GEQ expr
    (39) expr -> expr . > expr
    (40) expr -> expr . LEQ expr
    (41) expr -> expr . < expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . MTIMES expr
    (46) expr -> expr . MMINUS expr
    (47) expr -> expr . MPLUS expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    )               shift and go to state 115
    '               shift and go to state 48
    NEQ             shift and go to state 49
    EQ              shift and go to state 50
    GEQ             shift and go to state 51
    >               shift and go to state 52
    LEQ             shift and go to state 53
    <               shift and go to state 54
    MDIVIDE         shift and go to state 55
    MTIMES          shift and go to state 56
    MMINUS          shift and go to state 57
    MPLUS           shift and go to state 58
    /               shift and go to state 59
    *               shift and go to state 60
    -               shift and go to state 61
    +               shift and go to state 62


state 99

    (35) expr -> ( expr ) .
    '               reduce using rule 35 (expr -> ( expr ) .)
    NEQ             reduce using rule 35 (expr -> ( expr ) .)
    EQ              reduce using rule 35 (expr -> ( expr ) .)
    GEQ             reduce using rule 35 (expr -> ( expr ) .)
    >               reduce using rule 35 (expr -> ( expr ) .)
    LEQ             reduce using rule 35 (expr -> ( expr ) .)
    <               reduce using rule 35 (expr -> ( expr ) .)
    MDIVIDE         reduce using rule 35 (expr -> ( expr ) .)
    MTIMES          reduce using rule 35 (expr -> ( expr ) .)
    MMINUS          reduce using rule 35 (expr -> ( expr ) .)
    MPLUS           reduce using rule 35 (expr -> ( expr ) .)
    /               reduce using rule 35 (expr -> ( expr ) .)
    *               reduce using rule 35 (expr -> ( expr ) .)
    -               reduce using rule 35 (expr -> ( expr ) .)
    +               reduce using rule 35 (expr -> ( expr ) .)
    {               reduce using rule 35 (expr -> ( expr ) .)
    FOR             reduce using rule 35 (expr -> ( expr ) .)
    WHILE           reduce using rule 35 (expr -> ( expr ) .)
    IF              reduce using rule 35 (expr -> ( expr ) .)
    PRINT           reduce using rule 35 (expr -> ( expr ) .)
    BREAK           reduce using rule 35 (expr -> ( expr ) .)
    CONTINUE        reduce using rule 35 (expr -> ( expr ) .)
    RETURN          reduce using rule 35 (expr -> ( expr ) .)
    ID              reduce using rule 35 (expr -> ( expr ) .)
    ,               reduce using rule 35 (expr -> ( expr ) .)
    ;               reduce using rule 35 (expr -> ( expr ) .)
    )               reduce using rule 35 (expr -> ( expr ) .)
    :               reduce using rule 35 (expr -> ( expr ) .)
    ]               reduce using rule 35 (expr -> ( expr ) .)


state 100

    (27) expr -> ONES ( expr . )
    (34) expr -> expr . '
    (36) expr -> expr . NEQ expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . GEQ expr
    (39) expr -> expr . > expr
    (40) expr -> expr . LEQ expr
    (41) expr -> expr . < expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . MTIMES expr
    (46) expr -> expr . MMINUS expr
    (47) expr -> expr . MPLUS expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    )               shift and go to state 116
    '               shift and go to state 48
    NEQ             shift and go to state 49
    EQ              shift and go to state 50
    GEQ             shift and go to state 51
    >               shift and go to state 52
    LEQ             shift and go to state 53
    <               shift and go to state 54
    MDIVIDE         shift and go to state 55
    MTIMES          shift and go to state 56
    MMINUS          shift and go to state 57
    MPLUS           shift and go to state 58
    /               shift and go to state 59
    *               shift and go to state 60
    -               shift and go to state 61
    +               shift and go to state 62


state 101

    (28) expr -> ZEROS ( expr . )
    (34) expr -> expr . '
    (36) expr -> expr . NEQ expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . GEQ expr
    (39) expr -> expr . > expr
    (40) expr -> expr . LEQ expr
    (41) expr -> expr . < expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . MTIMES expr
    (46) expr -> expr . MMINUS expr
    (47) expr -> expr . MPLUS expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    )               shift and go to state 117
    '               shift and go to state 48
    NEQ             shift and go to state 49
    EQ              shift and go to state 50
    GEQ             shift and go to state 51
    >               shift and go to state 52
    LEQ             shift and go to state 53
    <               shift and go to state 54
    MDIVIDE         shift and go to state 55
    MTIMES          shift and go to state 56
    MMINUS          shift and go to state 57
    MPLUS           shift and go to state 58
    /               shift and go to state 59
    *               shift and go to state 60
    -               shift and go to state 61
    +               shift and go to state 62


state 102

    (53) outerlist -> [ values . ]
    ]               shift and go to state 118


state 103

    (30) expr -> [ outerlist ] .
    '               reduce using rule 30 (expr -> [ outerlist ] .)
    NEQ             reduce using rule 30 (expr -> [ outerlist ] .)
    EQ              reduce using rule 30 (expr -> [ outerlist ] .)
    GEQ             reduce using rule 30 (expr -> [ outerlist ] .)
    >               reduce using rule 30 (expr -> [ outerlist ] .)
    LEQ             reduce using rule 30 (expr -> [ outerlist ] .)
    <               reduce using rule 30 (expr -> [ outerlist ] .)
    MDIVIDE         reduce using rule 30 (expr -> [ outerlist ] .)
    MTIMES          reduce using rule 30 (expr -> [ outerlist ] .)
    MMINUS          reduce using rule 30 (expr -> [ outerlist ] .)
    MPLUS           reduce using rule 30 (expr -> [ outerlist ] .)
    /               reduce using rule 30 (expr -> [ outerlist ] .)
    *               reduce using rule 30 (expr -> [ outerlist ] .)
    -               reduce using rule 30 (expr -> [ outerlist ] .)
    +               reduce using rule 30 (expr -> [ outerlist ] .)
    {               reduce using rule 30 (expr -> [ outerlist ] .)
    FOR             reduce using rule 30 (expr -> [ outerlist ] .)
    WHILE           reduce using rule 30 (expr -> [ outerlist ] .)
    IF              reduce using rule 30 (expr -> [ outerlist ] .)
    PRINT           reduce using rule 30 (expr -> [ outerlist ] .)
    BREAK           reduce using rule 30 (expr -> [ outerlist ] .)
    CONTINUE        reduce using rule 30 (expr -> [ outerlist ] .)
    RETURN          reduce using rule 30 (expr -> [ outerlist ] .)
    ID              reduce using rule 30 (expr -> [ outerlist ] .)
    ,               reduce using rule 30 (expr -> [ outerlist ] .)
    ;               reduce using rule 30 (expr -> [ outerlist ] .)
    )               reduce using rule 30 (expr -> [ outerlist ] .)
    :               reduce using rule 30 (expr -> [ outerlist ] .)
    ]               reduce using rule 30 (expr -> [ outerlist ] .)


state 104

    (54) outerlist -> outerlist , . [ values ]
    [               shift and go to state 119


state 105

    (9) statement -> IF expr block ELSE . block
    (3) block -> . { next_statements }
    (4) block -> . statement
    (7) statement -> . FOR ID = range block
    (8) statement -> . WHILE expr block
    (9) statement -> . IF expr block ELSE block
    (10) statement -> . IF expr block
    (11) statement -> . PRINT values ;
    (12) statement -> . BREAK ;
    (13) statement -> . CONTINUE ;
    (14) statement -> . RETURN expr ;
    (15) statement -> . left_assign DASSIGN expr ;
    (16) statement -> . left_assign TASSIGN expr ;
    (17) statement -> . left_assign MASSIGN expr ;
    (18) statement -> . left_assign PASSIGN expr ;
    (19) statement -> . left_assign = expr ;
    (20) left_assign -> . ID [ indexes ]
    (21) left_assign -> . ID
    {               shift and go to state 3
    FOR             shift and go to state 5
    WHILE           shift and go to state 7
    IF              shift and go to state 8
    PRINT           shift and go to state 9
    BREAK           shift and go to state 10
    CONTINUE        shift and go to state 11
    RETURN          shift and go to state 12
    ID              shift and go to state 6

    block                          shift and go to state 120
    statement                      shift and go to state 4
    left_assign                    shift and go to state 13

state 106

    (25) values -> expr , values .
    ;               reduce using rule 25 (values -> expr , values .)
    ]               reduce using rule 25 (values -> expr , values .)


state 107

    (15) statement -> left_assign DASSIGN expr ; .
    {               reduce using rule 15 (statement -> left_assign DASSIGN expr ; .)
    FOR             reduce using rule 15 (statement -> left_assign DASSIGN expr ; .)
    WHILE           reduce using rule 15 (statement -> left_assign DASSIGN expr ; .)
    IF              reduce using rule 15 (statement -> left_assign DASSIGN expr ; .)
    PRINT           reduce using rule 15 (statement -> left_assign DASSIGN expr ; .)
    BREAK           reduce using rule 15 (statement -> left_assign DASSIGN expr ; .)
    CONTINUE        reduce using rule 15 (statement -> left_assign DASSIGN expr ; .)
    RETURN          reduce using rule 15 (statement -> left_assign DASSIGN expr ; .)
    ID              reduce using rule 15 (statement -> left_assign DASSIGN expr ; .)
    $end            reduce using rule 15 (statement -> left_assign DASSIGN expr ; .)
    }               reduce using rule 15 (statement -> left_assign DASSIGN expr ; .)
    ELSE            reduce using rule 15 (statement -> left_assign DASSIGN expr ; .)


state 108

    (16) statement -> left_assign TASSIGN expr ; .
    {               reduce using rule 16 (statement -> left_assign TASSIGN expr ; .)
    FOR             reduce using rule 16 (statement -> left_assign TASSIGN expr ; .)
    WHILE           reduce using rule 16 (statement -> left_assign TASSIGN expr ; .)
    IF              reduce using rule 16 (statement -> left_assign TASSIGN expr ; .)
    PRINT           reduce using rule 16 (statement -> left_assign TASSIGN expr ; .)
    BREAK           reduce using rule 16 (statement -> left_assign TASSIGN expr ; .)
    CONTINUE        reduce using rule 16 (statement -> left_assign TASSIGN expr ; .)
    RETURN          reduce using rule 16 (statement -> left_assign TASSIGN expr ; .)
    ID              reduce using rule 16 (statement -> left_assign TASSIGN expr ; .)
    $end            reduce using rule 16 (statement -> left_assign TASSIGN expr ; .)
    }               reduce using rule 16 (statement -> left_assign TASSIGN expr ; .)
    ELSE            reduce using rule 16 (statement -> left_assign TASSIGN expr ; .)


state 109

    (17) statement -> left_assign MASSIGN expr ; .
    {               reduce using rule 17 (statement -> left_assign MASSIGN expr ; .)
    FOR             reduce using rule 17 (statement -> left_assign MASSIGN expr ; .)
    WHILE           reduce using rule 17 (statement -> left_assign MASSIGN expr ; .)
    IF              reduce using rule 17 (statement -> left_assign MASSIGN expr ; .)
    PRINT           reduce using rule 17 (statement -> left_assign MASSIGN expr ; .)
    BREAK           reduce using rule 17 (statement -> left_assign MASSIGN expr ; .)
    CONTINUE        reduce using rule 17 (statement -> left_assign MASSIGN expr ; .)
    RETURN          reduce using rule 17 (statement -> left_assign MASSIGN expr ; .)
    ID              reduce using rule 17 (statement -> left_assign MASSIGN expr ; .)
    $end            reduce using rule 17 (statement -> left_assign MASSIGN expr ; .)
    }               reduce using rule 17 (statement -> left_assign MASSIGN expr ; .)
    ELSE            reduce using rule 17 (statement -> left_assign MASSIGN expr ; .)


state 110

    (18) statement -> left_assign PASSIGN expr ; .
    {               reduce using rule 18 (statement -> left_assign PASSIGN expr ; .)
    FOR             reduce using rule 18 (statement -> left_assign PASSIGN expr ; .)
    WHILE           reduce using rule 18 (statement -> left_assign PASSIGN expr ; .)
    IF              reduce using rule 18 (statement -> left_assign PASSIGN expr ; .)
    PRINT           reduce using rule 18 (statement -> left_assign PASSIGN expr ; .)
    BREAK           reduce using rule 18 (statement -> left_assign PASSIGN expr ; .)
    CONTINUE        reduce using rule 18 (statement -> left_assign PASSIGN expr ; .)
    RETURN          reduce using rule 18 (statement -> left_assign PASSIGN expr ; .)
    ID              reduce using rule 18 (statement -> left_assign PASSIGN expr ; .)
    $end            reduce using rule 18 (statement -> left_assign PASSIGN expr ; .)
    }               reduce using rule 18 (statement -> left_assign PASSIGN expr ; .)
    ELSE            reduce using rule 18 (statement -> left_assign PASSIGN expr ; .)


state 111

    (19) statement -> left_assign = expr ; .
    {               reduce using rule 19 (statement -> left_assign = expr ; .)
    FOR             reduce using rule 19 (statement -> left_assign = expr ; .)
    WHILE           reduce using rule 19 (statement -> left_assign = expr ; .)
    IF              reduce using rule 19 (statement -> left_assign = expr ; .)
    PRINT           reduce using rule 19 (statement -> left_assign = expr ; .)
    BREAK           reduce using rule 19 (statement -> left_assign = expr ; .)
    CONTINUE        reduce using rule 19 (statement -> left_assign = expr ; .)
    RETURN          reduce using rule 19 (statement -> left_assign = expr ; .)
    ID              reduce using rule 19 (statement -> left_assign = expr ; .)
    $end            reduce using rule 19 (statement -> left_assign = expr ; .)
    }               reduce using rule 19 (statement -> left_assign = expr ; .)
    ELSE            reduce using rule 19 (statement -> left_assign = expr ; .)


state 112

    (7) statement -> FOR ID = range block .
    {               reduce using rule 7 (statement -> FOR ID = range block .)
    FOR             reduce using rule 7 (statement -> FOR ID = range block .)
    WHILE           reduce using rule 7 (statement -> FOR ID = range block .)
    IF              reduce using rule 7 (statement -> FOR ID = range block .)
    PRINT           reduce using rule 7 (statement -> FOR ID = range block .)
    BREAK           reduce using rule 7 (statement -> FOR ID = range block .)
    CONTINUE        reduce using rule 7 (statement -> FOR ID = range block .)
    RETURN          reduce using rule 7 (statement -> FOR ID = range block .)
    ID              reduce using rule 7 (statement -> FOR ID = range block .)
    $end            reduce using rule 7 (statement -> FOR ID = range block .)
    }               reduce using rule 7 (statement -> FOR ID = range block .)
    ELSE            reduce using rule 7 (statement -> FOR ID = range block .)


state 113

    (52) range -> expr : . expr
    (26) expr -> . EYE ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . ZEROS ( expr )
    (29) expr -> . ID
    (30) expr -> . [ outerlist ]
    (31) expr -> . STRING
    (32) expr -> . FLOAT
    (33) expr -> . INT
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr GEQ expr
    (39) expr -> . expr > expr
    (40) expr -> . expr LEQ expr
    (41) expr -> . expr < expr
    (42) expr -> . ' expr
    (43) expr -> . - expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 20
    ONES            shift and go to state 22
    ZEROS           shift and go to state 23
    ID              shift and go to state 24
    [               shift and go to state 25
    STRING          shift and go to state 26
    FLOAT           shift and go to state 27
    INT             shift and go to state 28
    (               shift and go to state 21
    '               shift and go to state 29
    -               shift and go to state 30

    expr                           shift and go to state 121

state 114

    (23) indexes -> INT , indexes .
    ]               reduce using rule 23 (indexes -> INT , indexes .)


state 115

    (26) expr -> EYE ( expr ) .
    '               reduce using rule 26 (expr -> EYE ( expr ) .)
    NEQ             reduce using rule 26 (expr -> EYE ( expr ) .)
    EQ              reduce using rule 26 (expr -> EYE ( expr ) .)
    GEQ             reduce using rule 26 (expr -> EYE ( expr ) .)
    >               reduce using rule 26 (expr -> EYE ( expr ) .)
    LEQ             reduce using rule 26 (expr -> EYE ( expr ) .)
    <               reduce using rule 26 (expr -> EYE ( expr ) .)
    MDIVIDE         reduce using rule 26 (expr -> EYE ( expr ) .)
    MTIMES          reduce using rule 26 (expr -> EYE ( expr ) .)
    MMINUS          reduce using rule 26 (expr -> EYE ( expr ) .)
    MPLUS           reduce using rule 26 (expr -> EYE ( expr ) .)
    /               reduce using rule 26 (expr -> EYE ( expr ) .)
    *               reduce using rule 26 (expr -> EYE ( expr ) .)
    -               reduce using rule 26 (expr -> EYE ( expr ) .)
    +               reduce using rule 26 (expr -> EYE ( expr ) .)
    {               reduce using rule 26 (expr -> EYE ( expr ) .)
    FOR             reduce using rule 26 (expr -> EYE ( expr ) .)
    WHILE           reduce using rule 26 (expr -> EYE ( expr ) .)
    IF              reduce using rule 26 (expr -> EYE ( expr ) .)
    PRINT           reduce using rule 26 (expr -> EYE ( expr ) .)
    BREAK           reduce using rule 26 (expr -> EYE ( expr ) .)
    CONTINUE        reduce using rule 26 (expr -> EYE ( expr ) .)
    RETURN          reduce using rule 26 (expr -> EYE ( expr ) .)
    ID              reduce using rule 26 (expr -> EYE ( expr ) .)
    ,               reduce using rule 26 (expr -> EYE ( expr ) .)
    ;               reduce using rule 26 (expr -> EYE ( expr ) .)
    )               reduce using rule 26 (expr -> EYE ( expr ) .)
    :               reduce using rule 26 (expr -> EYE ( expr ) .)
    ]               reduce using rule 26 (expr -> EYE ( expr ) .)


state 116

    (27) expr -> ONES ( expr ) .
    '               reduce using rule 27 (expr -> ONES ( expr ) .)
    NEQ             reduce using rule 27 (expr -> ONES ( expr ) .)
    EQ              reduce using rule 27 (expr -> ONES ( expr ) .)
    GEQ             reduce using rule 27 (expr -> ONES ( expr ) .)
    >               reduce using rule 27 (expr -> ONES ( expr ) .)
    LEQ             reduce using rule 27 (expr -> ONES ( expr ) .)
    <               reduce using rule 27 (expr -> ONES ( expr ) .)
    MDIVIDE         reduce using rule 27 (expr -> ONES ( expr ) .)
    MTIMES          reduce using rule 27 (expr -> ONES ( expr ) .)
    MMINUS          reduce using rule 27 (expr -> ONES ( expr ) .)
    MPLUS           reduce using rule 27 (expr -> ONES ( expr ) .)
    /               reduce using rule 27 (expr -> ONES ( expr ) .)
    *               reduce using rule 27 (expr -> ONES ( expr ) .)
    -               reduce using rule 27 (expr -> ONES ( expr ) .)
    +               reduce using rule 27 (expr -> ONES ( expr ) .)
    {               reduce using rule 27 (expr -> ONES ( expr ) .)
    FOR             reduce using rule 27 (expr -> ONES ( expr ) .)
    WHILE           reduce using rule 27 (expr -> ONES ( expr ) .)
    IF              reduce using rule 27 (expr -> ONES ( expr ) .)
    PRINT           reduce using rule 27 (expr -> ONES ( expr ) .)
    BREAK           reduce using rule 27 (expr -> ONES ( expr ) .)
    CONTINUE        reduce using rule 27 (expr -> ONES ( expr ) .)
    RETURN          reduce using rule 27 (expr -> ONES ( expr ) .)
    ID              reduce using rule 27 (expr -> ONES ( expr ) .)
    ,               reduce using rule 27 (expr -> ONES ( expr ) .)
    ;               reduce using rule 27 (expr -> ONES ( expr ) .)
    )               reduce using rule 27 (expr -> ONES ( expr ) .)
    :               reduce using rule 27 (expr -> ONES ( expr ) .)
    ]               reduce using rule 27 (expr -> ONES ( expr ) .)


state 117

    (28) expr -> ZEROS ( expr ) .
    '               reduce using rule 28 (expr -> ZEROS ( expr ) .)
    NEQ             reduce using rule 28 (expr -> ZEROS ( expr ) .)
    EQ              reduce using rule 28 (expr -> ZEROS ( expr ) .)
    GEQ             reduce using rule 28 (expr -> ZEROS ( expr ) .)
    >               reduce using rule 28 (expr -> ZEROS ( expr ) .)
    LEQ             reduce using rule 28 (expr -> ZEROS ( expr ) .)
    <               reduce using rule 28 (expr -> ZEROS ( expr ) .)
    MDIVIDE         reduce using rule 28 (expr -> ZEROS ( expr ) .)
    MTIMES          reduce using rule 28 (expr -> ZEROS ( expr ) .)
    MMINUS          reduce using rule 28 (expr -> ZEROS ( expr ) .)
    MPLUS           reduce using rule 28 (expr -> ZEROS ( expr ) .)
    /               reduce using rule 28 (expr -> ZEROS ( expr ) .)
    *               reduce using rule 28 (expr -> ZEROS ( expr ) .)
    -               reduce using rule 28 (expr -> ZEROS ( expr ) .)
    +               reduce using rule 28 (expr -> ZEROS ( expr ) .)
    {               reduce using rule 28 (expr -> ZEROS ( expr ) .)
    FOR             reduce using rule 28 (expr -> ZEROS ( expr ) .)
    WHILE           reduce using rule 28 (expr -> ZEROS ( expr ) .)
    IF              reduce using rule 28 (expr -> ZEROS ( expr ) .)
    PRINT           reduce using rule 28 (expr -> ZEROS ( expr ) .)
    BREAK           reduce using rule 28 (expr -> ZEROS ( expr ) .)
    CONTINUE        reduce using rule 28 (expr -> ZEROS ( expr ) .)
    RETURN          reduce using rule 28 (expr -> ZEROS ( expr ) .)
    ID              reduce using rule 28 (expr -> ZEROS ( expr ) .)
    ,               reduce using rule 28 (expr -> ZEROS ( expr ) .)
    ;               reduce using rule 28 (expr -> ZEROS ( expr ) .)
    )               reduce using rule 28 (expr -> ZEROS ( expr ) .)
    :               reduce using rule 28 (expr -> ZEROS ( expr ) .)
    ]               reduce using rule 28 (expr -> ZEROS ( expr ) .)


state 118

    (53) outerlist -> [ values ] .
    ]               reduce using rule 53 (outerlist -> [ values ] .)
    ,               reduce using rule 53 (outerlist -> [ values ] .)


state 119

    (54) outerlist -> outerlist , [ . values ]
    (24) values -> . expr
    (25) values -> . expr , values
    (26) expr -> . EYE ( expr )
    (27) expr -> . ONES ( expr )
    (28) expr -> . ZEROS ( expr )
    (29) expr -> . ID
    (30) expr -> . [ outerlist ]
    (31) expr -> . STRING
    (32) expr -> . FLOAT
    (33) expr -> . INT
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr GEQ expr
    (39) expr -> . expr > expr
    (40) expr -> . expr LEQ expr
    (41) expr -> . expr < expr
    (42) expr -> . ' expr
    (43) expr -> . - expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 20
    ONES            shift and go to state 22
    ZEROS           shift and go to state 23
    ID              shift and go to state 24
    [               shift and go to state 25
    STRING          shift and go to state 26
    FLOAT           shift and go to state 27
    INT             shift and go to state 28
    (               shift and go to state 21
    '               shift and go to state 29
    -               shift and go to state 30

    values                         shift and go to state 122
    expr                           shift and go to state 33

state 120

    (9) statement -> IF expr block ELSE block .
    {               reduce using rule 9 (statement -> IF expr block ELSE block .)
    FOR             reduce using rule 9 (statement -> IF expr block ELSE block .)
    WHILE           reduce using rule 9 (statement -> IF expr block ELSE block .)
    IF              reduce using rule 9 (statement -> IF expr block ELSE block .)
    PRINT           reduce using rule 9 (statement -> IF expr block ELSE block .)
    BREAK           reduce using rule 9 (statement -> IF expr block ELSE block .)
    CONTINUE        reduce using rule 9 (statement -> IF expr block ELSE block .)
    RETURN          reduce using rule 9 (statement -> IF expr block ELSE block .)
    ID              reduce using rule 9 (statement -> IF expr block ELSE block .)
    $end            reduce using rule 9 (statement -> IF expr block ELSE block .)
    }               reduce using rule 9 (statement -> IF expr block ELSE block .)
    ELSE            reduce using rule 9 (statement -> IF expr block ELSE block .)


state 121

    (52) range -> expr : expr .
    (34) expr -> expr . '
    (36) expr -> expr . NEQ expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . GEQ expr
    (39) expr -> expr . > expr
    (40) expr -> expr . LEQ expr
    (41) expr -> expr . < expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . MTIMES expr
    (46) expr -> expr . MMINUS expr
    (47) expr -> expr . MPLUS expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    {               reduce using rule 52 (range -> expr : expr .)
    FOR             reduce using rule 52 (range -> expr : expr .)
    WHILE           reduce using rule 52 (range -> expr : expr .)
    IF              reduce using rule 52 (range -> expr : expr .)
    PRINT           reduce using rule 52 (range -> expr : expr .)
    BREAK           reduce using rule 52 (range -> expr : expr .)
    CONTINUE        reduce using rule 52 (range -> expr : expr .)
    RETURN          reduce using rule 52 (range -> expr : expr .)
    ID              reduce using rule 52 (range -> expr : expr .)
    '               shift and go to state 48
    NEQ             shift and go to state 49
    EQ              shift and go to state 50
    GEQ             shift and go to state 51
    >               shift and go to state 52
    LEQ             shift and go to state 53
    <               shift and go to state 54
    MDIVIDE         shift and go to state 55
    MTIMES          shift and go to state 56
    MMINUS          shift and go to state 57
    MPLUS           shift and go to state 58
    /               shift and go to state 59
    *               shift and go to state 60
    -               shift and go to state 61
    +               shift and go to state 62


state 122

    (54) outerlist -> outerlist , [ values . ]
    ]               shift and go to state 123


state 123

    (54) outerlist -> outerlist , [ values ] .
    ]               reduce using rule 54 (outerlist -> outerlist , [ values ] .)
    ,               reduce using rule 54 (outerlist -> outerlist , [ values ] .)
