Grammar:

Rule 0     S' -> start
Rule 1     empty -> <empty>
Rule 2     start -> empty
Rule 3     start -> { start } start
Rule 4     start -> statement start
Rule 5     statement -> FOR ID = range block
Rule 6     statement -> WHILE expr block  [precedence=left, level=2]
Rule 7     statement -> IF expr block ELSE block  [precedence=right, level=5]
Rule 8     statement -> IF expr block  [precedence=left, level=2]
Rule 9     statement -> PRINT values
Rule 10    statement -> expr ;
Rule 11    statement -> BREAK ;
Rule 12    statement -> CONTINUE ;
Rule 13    statement -> RETURN expr ;
Rule 14    statement -> left_assign DASSIGN expr ;
Rule 15    statement -> left_assign TASSIGN expr ;
Rule 16    statement -> left_assign MASSIGN expr ;
Rule 17    statement -> left_assign PASSIGN expr ;
Rule 18    statement -> left_assign = expr ;
Rule 19    left_assign -> ID [ indexes ]
Rule 20    left_assign -> ID
Rule 21    indexes -> INT
Rule 22    indexes -> INT , indexes
Rule 23    values -> expr ;
Rule 24    values -> expr , values
Rule 25    block -> { start }
Rule 26    block -> statement
Rule 27    expr -> EYE ( expr )
Rule 28    expr -> ONES ( expr )
Rule 29    expr -> ZEROS ( expr )
Rule 30    expr -> ID
Rule 31    expr -> [ outerlist ]
Rule 32    expr -> STRING
Rule 33    expr -> FLOAT
Rule 34    expr -> INT
Rule 35    expr -> expr '  [precedence=right, level=5]
Rule 36    expr -> ( expr )
Rule 37    expr -> expr NEQ expr  [precedence=nonassoc, level=1]
Rule 38    expr -> expr EQ expr  [precedence=nonassoc, level=1]
Rule 39    expr -> expr GEQ expr  [precedence=nonassoc, level=1]
Rule 40    expr -> expr > expr  [precedence=nonassoc, level=1]
Rule 41    expr -> expr LEQ expr  [precedence=nonassoc, level=1]
Rule 42    expr -> expr < expr  [precedence=nonassoc, level=1]
Rule 43    expr -> ' expr  [precedence=right, level=5]
Rule 44    expr -> expr MDIVIDE expr  [precedence=left, level=4]
Rule 45    expr -> expr MTIMES expr  [precedence=left, level=4]
Rule 46    expr -> expr MMINUS expr  [precedence=left, level=3]
Rule 47    expr -> expr MPLUS expr  [precedence=left, level=3]
Rule 48    expr -> expr / expr  [precedence=left, level=4]
Rule 49    expr -> expr * expr  [precedence=left, level=4]
Rule 50    expr -> expr - expr  [precedence=left, level=3]
Rule 51    expr -> expr + expr  [precedence=left, level=3]
Rule 52    range -> INT : ID
Rule 53    range -> ID : INT
Rule 54    range -> ID : ID
Rule 55    range -> INT : INT
Rule 56    outerlist -> [ innerlist ]
Rule 57    outerlist -> outerlist , [ innerlist ]
Rule 58    innerlist -> elem
Rule 59    innerlist -> innerlist , elem
Rule 60    elem -> STRING
Rule 61    elem -> FLOAT
Rule 62    elem -> INT

Terminals, with rules where they appear:

'                    : 35 43
(                    : 27 28 29 36
)                    : 27 28 29 36
*                    : 49
+                    : 51
,                    : 22 24 57 59
-                    : 50
/                    : 48
:                    : 52 53 54 55
;                    : 10 11 12 13 14 15 16 17 18 23
<                    : 42
=                    : 5 18
>                    : 40
BREAK                : 11
CONTINUE             : 12
DASSIGN              : 14
ELSE                 : 7
EQ                   : 38
EYE                  : 27
FLOAT                : 33 61
FOR                  : 5
GEQ                  : 39
ID                   : 5 19 20 30 52 53 54 54
IF                   : 7 8
INT                  : 21 22 34 52 53 55 55 62
LEQ                  : 41
MASSIGN              : 16
MDIVIDE              : 44
MMINUS               : 46
MPLUS                : 47
MTIMES               : 45
NEQ                  : 37
ONES                 : 28
PASSIGN              : 17
PRINT                : 9
RETURN               : 13
STRING               : 32 60
TASSIGN              : 15
WHILE                : 6
ZEROS                : 29
[                    : 19 31 56 57
]                    : 19 31 56 57
error                : 
{                    : 3 25
}                    : 3 25

Nonterminals, with rules where they appear:

block                : 5 6 7 7 8
elem                 : 58 59
empty                : 2
expr                 : 6 7 8 10 13 14 15 16 17 18 23 24 27 28 29 35 36 37 37 38 38 39 39 40 40 41 41 42 42 43 44 44 45 45 46 46 47 47 48 48 49 49 50 50 51 51
indexes              : 19 22
innerlist            : 56 57 59
left_assign          : 14 15 16 17 18
outerlist            : 31 57
range                : 5
start                : 3 3 4 25 0
statement            : 4 26
values               : 9 24


state 0

    (0) S' -> . start
    (2) start -> . empty
    (3) start -> . { start } start
    (4) start -> . statement start
    (1) empty -> .
    (5) statement -> . FOR ID = range block
    (6) statement -> . WHILE expr block
    (7) statement -> . IF expr block ELSE block
    (8) statement -> . IF expr block
    (9) statement -> . PRINT values
    (10) statement -> . expr ;
    (11) statement -> . BREAK ;
    (12) statement -> . CONTINUE ;
    (13) statement -> . RETURN expr ;
    (14) statement -> . left_assign DASSIGN expr ;
    (15) statement -> . left_assign TASSIGN expr ;
    (16) statement -> . left_assign MASSIGN expr ;
    (17) statement -> . left_assign PASSIGN expr ;
    (18) statement -> . left_assign = expr ;
    (27) expr -> . EYE ( expr )
    (28) expr -> . ONES ( expr )
    (29) expr -> . ZEROS ( expr )
    (30) expr -> . ID
    (31) expr -> . [ outerlist ]
    (32) expr -> . STRING
    (33) expr -> . FLOAT
    (34) expr -> . INT
    (35) expr -> . expr '
    (36) expr -> . ( expr )
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr GEQ expr
    (40) expr -> . expr > expr
    (41) expr -> . expr LEQ expr
    (42) expr -> . expr < expr
    (43) expr -> . ' expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (19) left_assign -> . ID [ indexes ]
    (20) left_assign -> . ID
    {               shift and go to state 3
    $end            reduce using rule 1 (empty -> .)
    FOR             shift and go to state 5
    WHILE           shift and go to state 7
    IF              shift and go to state 9
    PRINT           shift and go to state 10
    BREAK           shift and go to state 11
    CONTINUE        shift and go to state 12
    RETURN          shift and go to state 13
    EYE             shift and go to state 15
    ONES            shift and go to state 17
    ZEROS           shift and go to state 18
    ID              shift and go to state 6
    [               shift and go to state 19
    STRING          shift and go to state 20
    FLOAT           shift and go to state 21
    INT             shift and go to state 22
    (               shift and go to state 16
    '               shift and go to state 23

    start                          shift and go to state 1
    empty                          shift and go to state 2
    statement                      shift and go to state 4
    expr                           shift and go to state 8
    left_assign                    shift and go to state 14

state 1

    (0) S' -> start .


state 2

    (2) start -> empty .
    $end            reduce using rule 2 (start -> empty .)
    }               reduce using rule 2 (start -> empty .)


state 3

    (3) start -> { . start } start
    (2) start -> . empty
    (3) start -> . { start } start
    (4) start -> . statement start
    (1) empty -> .
    (5) statement -> . FOR ID = range block
    (6) statement -> . WHILE expr block
    (7) statement -> . IF expr block ELSE block
    (8) statement -> . IF expr block
    (9) statement -> . PRINT values
    (10) statement -> . expr ;
    (11) statement -> . BREAK ;
    (12) statement -> . CONTINUE ;
    (13) statement -> . RETURN expr ;
    (14) statement -> . left_assign DASSIGN expr ;
    (15) statement -> . left_assign TASSIGN expr ;
    (16) statement -> . left_assign MASSIGN expr ;
    (17) statement -> . left_assign PASSIGN expr ;
    (18) statement -> . left_assign = expr ;
    (27) expr -> . EYE ( expr )
    (28) expr -> . ONES ( expr )
    (29) expr -> . ZEROS ( expr )
    (30) expr -> . ID
    (31) expr -> . [ outerlist ]
    (32) expr -> . STRING
    (33) expr -> . FLOAT
    (34) expr -> . INT
    (35) expr -> . expr '
    (36) expr -> . ( expr )
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr GEQ expr
    (40) expr -> . expr > expr
    (41) expr -> . expr LEQ expr
    (42) expr -> . expr < expr
    (43) expr -> . ' expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (19) left_assign -> . ID [ indexes ]
    (20) left_assign -> . ID
    {               shift and go to state 3
    }               reduce using rule 1 (empty -> .)
    FOR             shift and go to state 5
    WHILE           shift and go to state 7
    IF              shift and go to state 9
    PRINT           shift and go to state 10
    BREAK           shift and go to state 11
    CONTINUE        shift and go to state 12
    RETURN          shift and go to state 13
    EYE             shift and go to state 15
    ONES            shift and go to state 17
    ZEROS           shift and go to state 18
    ID              shift and go to state 6
    [               shift and go to state 19
    STRING          shift and go to state 20
    FLOAT           shift and go to state 21
    INT             shift and go to state 22
    (               shift and go to state 16
    '               shift and go to state 23

    start                          shift and go to state 24
    empty                          shift and go to state 2
    statement                      shift and go to state 4
    expr                           shift and go to state 8
    left_assign                    shift and go to state 14

state 4

    (4) start -> statement . start
    (2) start -> . empty
    (3) start -> . { start } start
    (4) start -> . statement start
    (1) empty -> .
    (5) statement -> . FOR ID = range block
    (6) statement -> . WHILE expr block
    (7) statement -> . IF expr block ELSE block
    (8) statement -> . IF expr block
    (9) statement -> . PRINT values
    (10) statement -> . expr ;
    (11) statement -> . BREAK ;
    (12) statement -> . CONTINUE ;
    (13) statement -> . RETURN expr ;
    (14) statement -> . left_assign DASSIGN expr ;
    (15) statement -> . left_assign TASSIGN expr ;
    (16) statement -> . left_assign MASSIGN expr ;
    (17) statement -> . left_assign PASSIGN expr ;
    (18) statement -> . left_assign = expr ;
    (27) expr -> . EYE ( expr )
    (28) expr -> . ONES ( expr )
    (29) expr -> . ZEROS ( expr )
    (30) expr -> . ID
    (31) expr -> . [ outerlist ]
    (32) expr -> . STRING
    (33) expr -> . FLOAT
    (34) expr -> . INT
    (35) expr -> . expr '
    (36) expr -> . ( expr )
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr GEQ expr
    (40) expr -> . expr > expr
    (41) expr -> . expr LEQ expr
    (42) expr -> . expr < expr
    (43) expr -> . ' expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (19) left_assign -> . ID [ indexes ]
    (20) left_assign -> . ID
    {               shift and go to state 3
    $end            reduce using rule 1 (empty -> .)
    }               reduce using rule 1 (empty -> .)
    FOR             shift and go to state 5
    WHILE           shift and go to state 7
    IF              shift and go to state 9
    PRINT           shift and go to state 10
    BREAK           shift and go to state 11
    CONTINUE        shift and go to state 12
    RETURN          shift and go to state 13
    EYE             shift and go to state 15
    ONES            shift and go to state 17
    ZEROS           shift and go to state 18
    ID              shift and go to state 6
    [               shift and go to state 19
    STRING          shift and go to state 20
    FLOAT           shift and go to state 21
    INT             shift and go to state 22
    (               shift and go to state 16
    '               shift and go to state 23

    statement                      shift and go to state 4
    start                          shift and go to state 25
    empty                          shift and go to state 2
    expr                           shift and go to state 8
    left_assign                    shift and go to state 14

state 5

    (5) statement -> FOR . ID = range block
    ID              shift and go to state 26


state 6

    (30) expr -> ID .
    (19) left_assign -> ID . [ indexes ]
    (20) left_assign -> ID .
    ;               reduce using rule 30 (expr -> ID .)
    '               reduce using rule 30 (expr -> ID .)
    NEQ             reduce using rule 30 (expr -> ID .)
    EQ              reduce using rule 30 (expr -> ID .)
    GEQ             reduce using rule 30 (expr -> ID .)
    >               reduce using rule 30 (expr -> ID .)
    LEQ             reduce using rule 30 (expr -> ID .)
    <               reduce using rule 30 (expr -> ID .)
    MDIVIDE         reduce using rule 30 (expr -> ID .)
    MTIMES          reduce using rule 30 (expr -> ID .)
    MMINUS          reduce using rule 30 (expr -> ID .)
    MPLUS           reduce using rule 30 (expr -> ID .)
    /               reduce using rule 30 (expr -> ID .)
    *               reduce using rule 30 (expr -> ID .)
    -               reduce using rule 30 (expr -> ID .)
    +               reduce using rule 30 (expr -> ID .)
    [               shift and go to state 27
    DASSIGN         reduce using rule 20 (left_assign -> ID .)
    TASSIGN         reduce using rule 20 (left_assign -> ID .)
    MASSIGN         reduce using rule 20 (left_assign -> ID .)
    PASSIGN         reduce using rule 20 (left_assign -> ID .)
    =               reduce using rule 20 (left_assign -> ID .)


state 7

    (6) statement -> WHILE . expr block
    (27) expr -> . EYE ( expr )
    (28) expr -> . ONES ( expr )
    (29) expr -> . ZEROS ( expr )
    (30) expr -> . ID
    (31) expr -> . [ outerlist ]
    (32) expr -> . STRING
    (33) expr -> . FLOAT
    (34) expr -> . INT
    (35) expr -> . expr '
    (36) expr -> . ( expr )
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr GEQ expr
    (40) expr -> . expr > expr
    (41) expr -> . expr LEQ expr
    (42) expr -> . expr < expr
    (43) expr -> . ' expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 15
    ONES            shift and go to state 17
    ZEROS           shift and go to state 18
    ID              shift and go to state 29
    [               shift and go to state 19
    STRING          shift and go to state 20
    FLOAT           shift and go to state 21
    INT             shift and go to state 22
    (               shift and go to state 16
    '               shift and go to state 23

    expr                           shift and go to state 28

state 8

    (10) statement -> expr . ;
    (35) expr -> expr . '
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . GEQ expr
    (40) expr -> expr . > expr
    (41) expr -> expr . LEQ expr
    (42) expr -> expr . < expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . MTIMES expr
    (46) expr -> expr . MMINUS expr
    (47) expr -> expr . MPLUS expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    ;               shift and go to state 30
    '               shift and go to state 31
    NEQ             shift and go to state 32
    EQ              shift and go to state 33
    GEQ             shift and go to state 34
    >               shift and go to state 35
    LEQ             shift and go to state 36
    <               shift and go to state 37
    MDIVIDE         shift and go to state 38
    MTIMES          shift and go to state 39
    MMINUS          shift and go to state 40
    MPLUS           shift and go to state 41
    /               shift and go to state 42
    *               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45


state 9

    (7) statement -> IF . expr block ELSE block
    (8) statement -> IF . expr block
    (27) expr -> . EYE ( expr )
    (28) expr -> . ONES ( expr )
    (29) expr -> . ZEROS ( expr )
    (30) expr -> . ID
    (31) expr -> . [ outerlist ]
    (32) expr -> . STRING
    (33) expr -> . FLOAT
    (34) expr -> . INT
    (35) expr -> . expr '
    (36) expr -> . ( expr )
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr GEQ expr
    (40) expr -> . expr > expr
    (41) expr -> . expr LEQ expr
    (42) expr -> . expr < expr
    (43) expr -> . ' expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 15
    ONES            shift and go to state 17
    ZEROS           shift and go to state 18
    ID              shift and go to state 29
    [               shift and go to state 19
    STRING          shift and go to state 20
    FLOAT           shift and go to state 21
    INT             shift and go to state 22
    (               shift and go to state 16
    '               shift and go to state 23

    expr                           shift and go to state 46

state 10

    (9) statement -> PRINT . values
    (23) values -> . expr ;
    (24) values -> . expr , values
    (27) expr -> . EYE ( expr )
    (28) expr -> . ONES ( expr )
    (29) expr -> . ZEROS ( expr )
    (30) expr -> . ID
    (31) expr -> . [ outerlist ]
    (32) expr -> . STRING
    (33) expr -> . FLOAT
    (34) expr -> . INT
    (35) expr -> . expr '
    (36) expr -> . ( expr )
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr GEQ expr
    (40) expr -> . expr > expr
    (41) expr -> . expr LEQ expr
    (42) expr -> . expr < expr
    (43) expr -> . ' expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 15
    ONES            shift and go to state 17
    ZEROS           shift and go to state 18
    ID              shift and go to state 29
    [               shift and go to state 19
    STRING          shift and go to state 20
    FLOAT           shift and go to state 21
    INT             shift and go to state 22
    (               shift and go to state 16
    '               shift and go to state 23

    values                         shift and go to state 47
    expr                           shift and go to state 48

state 11

    (11) statement -> BREAK . ;
    ;               shift and go to state 49


state 12

    (12) statement -> CONTINUE . ;
    ;               shift and go to state 50


state 13

    (13) statement -> RETURN . expr ;
    (27) expr -> . EYE ( expr )
    (28) expr -> . ONES ( expr )
    (29) expr -> . ZEROS ( expr )
    (30) expr -> . ID
    (31) expr -> . [ outerlist ]
    (32) expr -> . STRING
    (33) expr -> . FLOAT
    (34) expr -> . INT
    (35) expr -> . expr '
    (36) expr -> . ( expr )
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr GEQ expr
    (40) expr -> . expr > expr
    (41) expr -> . expr LEQ expr
    (42) expr -> . expr < expr
    (43) expr -> . ' expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 15
    ONES            shift and go to state 17
    ZEROS           shift and go to state 18
    ID              shift and go to state 29
    [               shift and go to state 19
    STRING          shift and go to state 20
    FLOAT           shift and go to state 21
    INT             shift and go to state 22
    (               shift and go to state 16
    '               shift and go to state 23

    expr                           shift and go to state 51

state 14

    (14) statement -> left_assign . DASSIGN expr ;
    (15) statement -> left_assign . TASSIGN expr ;
    (16) statement -> left_assign . MASSIGN expr ;
    (17) statement -> left_assign . PASSIGN expr ;
    (18) statement -> left_assign . = expr ;
    DASSIGN         shift and go to state 52
    TASSIGN         shift and go to state 53
    MASSIGN         shift and go to state 54
    PASSIGN         shift and go to state 55
    =               shift and go to state 56


state 15

    (27) expr -> EYE . ( expr )
    (               shift and go to state 57


state 16

    (36) expr -> ( . expr )
    (27) expr -> . EYE ( expr )
    (28) expr -> . ONES ( expr )
    (29) expr -> . ZEROS ( expr )
    (30) expr -> . ID
    (31) expr -> . [ outerlist ]
    (32) expr -> . STRING
    (33) expr -> . FLOAT
    (34) expr -> . INT
    (35) expr -> . expr '
    (36) expr -> . ( expr )
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr GEQ expr
    (40) expr -> . expr > expr
    (41) expr -> . expr LEQ expr
    (42) expr -> . expr < expr
    (43) expr -> . ' expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 15
    ONES            shift and go to state 17
    ZEROS           shift and go to state 18
    ID              shift and go to state 29
    [               shift and go to state 19
    STRING          shift and go to state 20
    FLOAT           shift and go to state 21
    INT             shift and go to state 22
    (               shift and go to state 16
    '               shift and go to state 23

    expr                           shift and go to state 58

state 17

    (28) expr -> ONES . ( expr )
    (               shift and go to state 59


state 18

    (29) expr -> ZEROS . ( expr )
    (               shift and go to state 60


state 19

    (31) expr -> [ . outerlist ]
    (56) outerlist -> . [ innerlist ]
    (57) outerlist -> . outerlist , [ innerlist ]
    [               shift and go to state 61

    outerlist                      shift and go to state 62

state 20

    (32) expr -> STRING .
    ;               reduce using rule 32 (expr -> STRING .)
    '               reduce using rule 32 (expr -> STRING .)
    NEQ             reduce using rule 32 (expr -> STRING .)
    EQ              reduce using rule 32 (expr -> STRING .)
    GEQ             reduce using rule 32 (expr -> STRING .)
    >               reduce using rule 32 (expr -> STRING .)
    LEQ             reduce using rule 32 (expr -> STRING .)
    <               reduce using rule 32 (expr -> STRING .)
    MDIVIDE         reduce using rule 32 (expr -> STRING .)
    MTIMES          reduce using rule 32 (expr -> STRING .)
    MMINUS          reduce using rule 32 (expr -> STRING .)
    MPLUS           reduce using rule 32 (expr -> STRING .)
    /               reduce using rule 32 (expr -> STRING .)
    *               reduce using rule 32 (expr -> STRING .)
    -               reduce using rule 32 (expr -> STRING .)
    +               reduce using rule 32 (expr -> STRING .)
    {               reduce using rule 32 (expr -> STRING .)
    FOR             reduce using rule 32 (expr -> STRING .)
    WHILE           reduce using rule 32 (expr -> STRING .)
    IF              reduce using rule 32 (expr -> STRING .)
    PRINT           reduce using rule 32 (expr -> STRING .)
    BREAK           reduce using rule 32 (expr -> STRING .)
    CONTINUE        reduce using rule 32 (expr -> STRING .)
    RETURN          reduce using rule 32 (expr -> STRING .)
    EYE             reduce using rule 32 (expr -> STRING .)
    ONES            reduce using rule 32 (expr -> STRING .)
    ZEROS           reduce using rule 32 (expr -> STRING .)
    ID              reduce using rule 32 (expr -> STRING .)
    [               reduce using rule 32 (expr -> STRING .)
    STRING          reduce using rule 32 (expr -> STRING .)
    FLOAT           reduce using rule 32 (expr -> STRING .)
    INT             reduce using rule 32 (expr -> STRING .)
    (               reduce using rule 32 (expr -> STRING .)
    ,               reduce using rule 32 (expr -> STRING .)
    )               reduce using rule 32 (expr -> STRING .)


state 21

    (33) expr -> FLOAT .
    ;               reduce using rule 33 (expr -> FLOAT .)
    '               reduce using rule 33 (expr -> FLOAT .)
    NEQ             reduce using rule 33 (expr -> FLOAT .)
    EQ              reduce using rule 33 (expr -> FLOAT .)
    GEQ             reduce using rule 33 (expr -> FLOAT .)
    >               reduce using rule 33 (expr -> FLOAT .)
    LEQ             reduce using rule 33 (expr -> FLOAT .)
    <               reduce using rule 33 (expr -> FLOAT .)
    MDIVIDE         reduce using rule 33 (expr -> FLOAT .)
    MTIMES          reduce using rule 33 (expr -> FLOAT .)
    MMINUS          reduce using rule 33 (expr -> FLOAT .)
    MPLUS           reduce using rule 33 (expr -> FLOAT .)
    /               reduce using rule 33 (expr -> FLOAT .)
    *               reduce using rule 33 (expr -> FLOAT .)
    -               reduce using rule 33 (expr -> FLOAT .)
    +               reduce using rule 33 (expr -> FLOAT .)
    {               reduce using rule 33 (expr -> FLOAT .)
    FOR             reduce using rule 33 (expr -> FLOAT .)
    WHILE           reduce using rule 33 (expr -> FLOAT .)
    IF              reduce using rule 33 (expr -> FLOAT .)
    PRINT           reduce using rule 33 (expr -> FLOAT .)
    BREAK           reduce using rule 33 (expr -> FLOAT .)
    CONTINUE        reduce using rule 33 (expr -> FLOAT .)
    RETURN          reduce using rule 33 (expr -> FLOAT .)
    EYE             reduce using rule 33 (expr -> FLOAT .)
    ONES            reduce using rule 33 (expr -> FLOAT .)
    ZEROS           reduce using rule 33 (expr -> FLOAT .)
    ID              reduce using rule 33 (expr -> FLOAT .)
    [               reduce using rule 33 (expr -> FLOAT .)
    STRING          reduce using rule 33 (expr -> FLOAT .)
    FLOAT           reduce using rule 33 (expr -> FLOAT .)
    INT             reduce using rule 33 (expr -> FLOAT .)
    (               reduce using rule 33 (expr -> FLOAT .)
    ,               reduce using rule 33 (expr -> FLOAT .)
    )               reduce using rule 33 (expr -> FLOAT .)


state 22

    (34) expr -> INT .
    ;               reduce using rule 34 (expr -> INT .)
    '               reduce using rule 34 (expr -> INT .)
    NEQ             reduce using rule 34 (expr -> INT .)
    EQ              reduce using rule 34 (expr -> INT .)
    GEQ             reduce using rule 34 (expr -> INT .)
    >               reduce using rule 34 (expr -> INT .)
    LEQ             reduce using rule 34 (expr -> INT .)
    <               reduce using rule 34 (expr -> INT .)
    MDIVIDE         reduce using rule 34 (expr -> INT .)
    MTIMES          reduce using rule 34 (expr -> INT .)
    MMINUS          reduce using rule 34 (expr -> INT .)
    MPLUS           reduce using rule 34 (expr -> INT .)
    /               reduce using rule 34 (expr -> INT .)
    *               reduce using rule 34 (expr -> INT .)
    -               reduce using rule 34 (expr -> INT .)
    +               reduce using rule 34 (expr -> INT .)
    {               reduce using rule 34 (expr -> INT .)
    FOR             reduce using rule 34 (expr -> INT .)
    WHILE           reduce using rule 34 (expr -> INT .)
    IF              reduce using rule 34 (expr -> INT .)
    PRINT           reduce using rule 34 (expr -> INT .)
    BREAK           reduce using rule 34 (expr -> INT .)
    CONTINUE        reduce using rule 34 (expr -> INT .)
    RETURN          reduce using rule 34 (expr -> INT .)
    EYE             reduce using rule 34 (expr -> INT .)
    ONES            reduce using rule 34 (expr -> INT .)
    ZEROS           reduce using rule 34 (expr -> INT .)
    ID              reduce using rule 34 (expr -> INT .)
    [               reduce using rule 34 (expr -> INT .)
    STRING          reduce using rule 34 (expr -> INT .)
    FLOAT           reduce using rule 34 (expr -> INT .)
    INT             reduce using rule 34 (expr -> INT .)
    (               reduce using rule 34 (expr -> INT .)
    ,               reduce using rule 34 (expr -> INT .)
    )               reduce using rule 34 (expr -> INT .)


state 23

    (43) expr -> ' . expr
    (27) expr -> . EYE ( expr )
    (28) expr -> . ONES ( expr )
    (29) expr -> . ZEROS ( expr )
    (30) expr -> . ID
    (31) expr -> . [ outerlist ]
    (32) expr -> . STRING
    (33) expr -> . FLOAT
    (34) expr -> . INT
    (35) expr -> . expr '
    (36) expr -> . ( expr )
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr GEQ expr
    (40) expr -> . expr > expr
    (41) expr -> . expr LEQ expr
    (42) expr -> . expr < expr
    (43) expr -> . ' expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 15
    ONES            shift and go to state 17
    ZEROS           shift and go to state 18
    ID              shift and go to state 29
    [               shift and go to state 19
    STRING          shift and go to state 20
    FLOAT           shift and go to state 21
    INT             shift and go to state 22
    (               shift and go to state 16
    '               shift and go to state 23

    expr                           shift and go to state 63

state 24

    (3) start -> { start . } start
    }               shift and go to state 64


state 25

    (4) start -> statement start .
    $end            reduce using rule 4 (start -> statement start .)
    }               reduce using rule 4 (start -> statement start .)


state 26

    (5) statement -> FOR ID . = range block
    =               shift and go to state 65


state 27

    (19) left_assign -> ID [ . indexes ]
    (21) indexes -> . INT
    (22) indexes -> . INT , indexes
    INT             shift and go to state 67

    indexes                        shift and go to state 66

state 28

    (6) statement -> WHILE expr . block
    (35) expr -> expr . '
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . GEQ expr
    (40) expr -> expr . > expr
    (41) expr -> expr . LEQ expr
    (42) expr -> expr . < expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . MTIMES expr
    (46) expr -> expr . MMINUS expr
    (47) expr -> expr . MPLUS expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    (25) block -> . { start }
    (26) block -> . statement
    (5) statement -> . FOR ID = range block
    (6) statement -> . WHILE expr block
    (7) statement -> . IF expr block ELSE block
    (8) statement -> . IF expr block
    (9) statement -> . PRINT values
    (10) statement -> . expr ;
    (11) statement -> . BREAK ;
    (12) statement -> . CONTINUE ;
    (13) statement -> . RETURN expr ;
    (14) statement -> . left_assign DASSIGN expr ;
    (15) statement -> . left_assign TASSIGN expr ;
    (16) statement -> . left_assign MASSIGN expr ;
    (17) statement -> . left_assign PASSIGN expr ;
    (18) statement -> . left_assign = expr ;
    (27) expr -> . EYE ( expr )
    (28) expr -> . ONES ( expr )
    (29) expr -> . ZEROS ( expr )
    (30) expr -> . ID
    (31) expr -> . [ outerlist ]
    (32) expr -> . STRING
    (33) expr -> . FLOAT
    (34) expr -> . INT
    (35) expr -> . expr '
    (36) expr -> . ( expr )
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr GEQ expr
    (40) expr -> . expr > expr
    (41) expr -> . expr LEQ expr
    (42) expr -> . expr < expr
    (43) expr -> . ' expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (19) left_assign -> . ID [ indexes ]
    (20) left_assign -> . ID
    '               shift and go to state 69
    NEQ             shift and go to state 32
    EQ              shift and go to state 33
    GEQ             shift and go to state 34
    >               shift and go to state 35
    LEQ             shift and go to state 36
    <               shift and go to state 37
    MDIVIDE         shift and go to state 38
    MTIMES          shift and go to state 39
    MMINUS          shift and go to state 40
    MPLUS           shift and go to state 41
    /               shift and go to state 42
    *               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45
    {               shift and go to state 70
    FOR             shift and go to state 5
    WHILE           shift and go to state 7
    IF              shift and go to state 9
    PRINT           shift and go to state 10
    BREAK           shift and go to state 11
    CONTINUE        shift and go to state 12
    RETURN          shift and go to state 13
    EYE             shift and go to state 15
    ONES            shift and go to state 17
    ZEROS           shift and go to state 18
    ID              shift and go to state 6
    [               shift and go to state 19
    STRING          shift and go to state 20
    FLOAT           shift and go to state 21
    INT             shift and go to state 22
    (               shift and go to state 16

    expr                           shift and go to state 8
    block                          shift and go to state 68
    statement                      shift and go to state 71
    left_assign                    shift and go to state 14

state 29

    (30) expr -> ID .
    '               reduce using rule 30 (expr -> ID .)
    NEQ             reduce using rule 30 (expr -> ID .)
    EQ              reduce using rule 30 (expr -> ID .)
    GEQ             reduce using rule 30 (expr -> ID .)
    >               reduce using rule 30 (expr -> ID .)
    LEQ             reduce using rule 30 (expr -> ID .)
    <               reduce using rule 30 (expr -> ID .)
    MDIVIDE         reduce using rule 30 (expr -> ID .)
    MTIMES          reduce using rule 30 (expr -> ID .)
    MMINUS          reduce using rule 30 (expr -> ID .)
    MPLUS           reduce using rule 30 (expr -> ID .)
    /               reduce using rule 30 (expr -> ID .)
    *               reduce using rule 30 (expr -> ID .)
    -               reduce using rule 30 (expr -> ID .)
    +               reduce using rule 30 (expr -> ID .)
    {               reduce using rule 30 (expr -> ID .)
    FOR             reduce using rule 30 (expr -> ID .)
    WHILE           reduce using rule 30 (expr -> ID .)
    IF              reduce using rule 30 (expr -> ID .)
    PRINT           reduce using rule 30 (expr -> ID .)
    BREAK           reduce using rule 30 (expr -> ID .)
    CONTINUE        reduce using rule 30 (expr -> ID .)
    RETURN          reduce using rule 30 (expr -> ID .)
    EYE             reduce using rule 30 (expr -> ID .)
    ONES            reduce using rule 30 (expr -> ID .)
    ZEROS           reduce using rule 30 (expr -> ID .)
    ID              reduce using rule 30 (expr -> ID .)
    [               reduce using rule 30 (expr -> ID .)
    STRING          reduce using rule 30 (expr -> ID .)
    FLOAT           reduce using rule 30 (expr -> ID .)
    INT             reduce using rule 30 (expr -> ID .)
    (               reduce using rule 30 (expr -> ID .)
    ;               reduce using rule 30 (expr -> ID .)
    ,               reduce using rule 30 (expr -> ID .)
    )               reduce using rule 30 (expr -> ID .)


state 30

    (10) statement -> expr ; .
    {               reduce using rule 10 (statement -> expr ; .)
    FOR             reduce using rule 10 (statement -> expr ; .)
    WHILE           reduce using rule 10 (statement -> expr ; .)
    IF              reduce using rule 10 (statement -> expr ; .)
    PRINT           reduce using rule 10 (statement -> expr ; .)
    BREAK           reduce using rule 10 (statement -> expr ; .)
    CONTINUE        reduce using rule 10 (statement -> expr ; .)
    RETURN          reduce using rule 10 (statement -> expr ; .)
    EYE             reduce using rule 10 (statement -> expr ; .)
    ONES            reduce using rule 10 (statement -> expr ; .)
    ZEROS           reduce using rule 10 (statement -> expr ; .)
    ID              reduce using rule 10 (statement -> expr ; .)
    [               reduce using rule 10 (statement -> expr ; .)
    STRING          reduce using rule 10 (statement -> expr ; .)
    FLOAT           reduce using rule 10 (statement -> expr ; .)
    INT             reduce using rule 10 (statement -> expr ; .)
    (               reduce using rule 10 (statement -> expr ; .)
    '               reduce using rule 10 (statement -> expr ; .)
    $end            reduce using rule 10 (statement -> expr ; .)
    }               reduce using rule 10 (statement -> expr ; .)
    ELSE            reduce using rule 10 (statement -> expr ; .)


state 31

    (35) expr -> expr ' .
    ;               reduce using rule 35 (expr -> expr ' .)
    '               reduce using rule 35 (expr -> expr ' .)
    NEQ             reduce using rule 35 (expr -> expr ' .)
    EQ              reduce using rule 35 (expr -> expr ' .)
    GEQ             reduce using rule 35 (expr -> expr ' .)
    >               reduce using rule 35 (expr -> expr ' .)
    LEQ             reduce using rule 35 (expr -> expr ' .)
    <               reduce using rule 35 (expr -> expr ' .)
    MDIVIDE         reduce using rule 35 (expr -> expr ' .)
    MTIMES          reduce using rule 35 (expr -> expr ' .)
    MMINUS          reduce using rule 35 (expr -> expr ' .)
    MPLUS           reduce using rule 35 (expr -> expr ' .)
    /               reduce using rule 35 (expr -> expr ' .)
    *               reduce using rule 35 (expr -> expr ' .)
    -               reduce using rule 35 (expr -> expr ' .)
    +               reduce using rule 35 (expr -> expr ' .)
    ,               reduce using rule 35 (expr -> expr ' .)
    )               reduce using rule 35 (expr -> expr ' .)
    {               reduce using rule 35 (expr -> expr ' .)
    FOR             reduce using rule 35 (expr -> expr ' .)
    WHILE           reduce using rule 35 (expr -> expr ' .)
    IF              reduce using rule 35 (expr -> expr ' .)
    PRINT           reduce using rule 35 (expr -> expr ' .)
    BREAK           reduce using rule 35 (expr -> expr ' .)
    CONTINUE        reduce using rule 35 (expr -> expr ' .)
    RETURN          reduce using rule 35 (expr -> expr ' .)
    EYE             reduce using rule 35 (expr -> expr ' .)
    ONES            reduce using rule 35 (expr -> expr ' .)
    ZEROS           reduce using rule 35 (expr -> expr ' .)
    ID              reduce using rule 35 (expr -> expr ' .)
    [               reduce using rule 35 (expr -> expr ' .)
    STRING          reduce using rule 35 (expr -> expr ' .)
    FLOAT           reduce using rule 35 (expr -> expr ' .)
    INT             reduce using rule 35 (expr -> expr ' .)
    (               reduce using rule 35 (expr -> expr ' .)


state 32

    (37) expr -> expr NEQ . expr
    (27) expr -> . EYE ( expr )
    (28) expr -> . ONES ( expr )
    (29) expr -> . ZEROS ( expr )
    (30) expr -> . ID
    (31) expr -> . [ outerlist ]
    (32) expr -> . STRING
    (33) expr -> . FLOAT
    (34) expr -> . INT
    (35) expr -> . expr '
    (36) expr -> . ( expr )
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr GEQ expr
    (40) expr -> . expr > expr
    (41) expr -> . expr LEQ expr
    (42) expr -> . expr < expr
    (43) expr -> . ' expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 15
    ONES            shift and go to state 17
    ZEROS           shift and go to state 18
    ID              shift and go to state 29
    [               shift and go to state 19
    STRING          shift and go to state 20
    FLOAT           shift and go to state 21
    INT             shift and go to state 22
    (               shift and go to state 16
    '               shift and go to state 23

    expr                           shift and go to state 72

state 33

    (38) expr -> expr EQ . expr
    (27) expr -> . EYE ( expr )
    (28) expr -> . ONES ( expr )
    (29) expr -> . ZEROS ( expr )
    (30) expr -> . ID
    (31) expr -> . [ outerlist ]
    (32) expr -> . STRING
    (33) expr -> . FLOAT
    (34) expr -> . INT
    (35) expr -> . expr '
    (36) expr -> . ( expr )
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr GEQ expr
    (40) expr -> . expr > expr
    (41) expr -> . expr LEQ expr
    (42) expr -> . expr < expr
    (43) expr -> . ' expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 15
    ONES            shift and go to state 17
    ZEROS           shift and go to state 18
    ID              shift and go to state 29
    [               shift and go to state 19
    STRING          shift and go to state 20
    FLOAT           shift and go to state 21
    INT             shift and go to state 22
    (               shift and go to state 16
    '               shift and go to state 23

    expr                           shift and go to state 73

state 34

    (39) expr -> expr GEQ . expr
    (27) expr -> . EYE ( expr )
    (28) expr -> . ONES ( expr )
    (29) expr -> . ZEROS ( expr )
    (30) expr -> . ID
    (31) expr -> . [ outerlist ]
    (32) expr -> . STRING
    (33) expr -> . FLOAT
    (34) expr -> . INT
    (35) expr -> . expr '
    (36) expr -> . ( expr )
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr GEQ expr
    (40) expr -> . expr > expr
    (41) expr -> . expr LEQ expr
    (42) expr -> . expr < expr
    (43) expr -> . ' expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 15
    ONES            shift and go to state 17
    ZEROS           shift and go to state 18
    ID              shift and go to state 29
    [               shift and go to state 19
    STRING          shift and go to state 20
    FLOAT           shift and go to state 21
    INT             shift and go to state 22
    (               shift and go to state 16
    '               shift and go to state 23

    expr                           shift and go to state 74

state 35

    (40) expr -> expr > . expr
    (27) expr -> . EYE ( expr )
    (28) expr -> . ONES ( expr )
    (29) expr -> . ZEROS ( expr )
    (30) expr -> . ID
    (31) expr -> . [ outerlist ]
    (32) expr -> . STRING
    (33) expr -> . FLOAT
    (34) expr -> . INT
    (35) expr -> . expr '
    (36) expr -> . ( expr )
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr GEQ expr
    (40) expr -> . expr > expr
    (41) expr -> . expr LEQ expr
    (42) expr -> . expr < expr
    (43) expr -> . ' expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 15
    ONES            shift and go to state 17
    ZEROS           shift and go to state 18
    ID              shift and go to state 29
    [               shift and go to state 19
    STRING          shift and go to state 20
    FLOAT           shift and go to state 21
    INT             shift and go to state 22
    (               shift and go to state 16
    '               shift and go to state 23

    expr                           shift and go to state 75

state 36

    (41) expr -> expr LEQ . expr
    (27) expr -> . EYE ( expr )
    (28) expr -> . ONES ( expr )
    (29) expr -> . ZEROS ( expr )
    (30) expr -> . ID
    (31) expr -> . [ outerlist ]
    (32) expr -> . STRING
    (33) expr -> . FLOAT
    (34) expr -> . INT
    (35) expr -> . expr '
    (36) expr -> . ( expr )
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr GEQ expr
    (40) expr -> . expr > expr
    (41) expr -> . expr LEQ expr
    (42) expr -> . expr < expr
    (43) expr -> . ' expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 15
    ONES            shift and go to state 17
    ZEROS           shift and go to state 18
    ID              shift and go to state 29
    [               shift and go to state 19
    STRING          shift and go to state 20
    FLOAT           shift and go to state 21
    INT             shift and go to state 22
    (               shift and go to state 16
    '               shift and go to state 23

    expr                           shift and go to state 76

state 37

    (42) expr -> expr < . expr
    (27) expr -> . EYE ( expr )
    (28) expr -> . ONES ( expr )
    (29) expr -> . ZEROS ( expr )
    (30) expr -> . ID
    (31) expr -> . [ outerlist ]
    (32) expr -> . STRING
    (33) expr -> . FLOAT
    (34) expr -> . INT
    (35) expr -> . expr '
    (36) expr -> . ( expr )
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr GEQ expr
    (40) expr -> . expr > expr
    (41) expr -> . expr LEQ expr
    (42) expr -> . expr < expr
    (43) expr -> . ' expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 15
    ONES            shift and go to state 17
    ZEROS           shift and go to state 18
    ID              shift and go to state 29
    [               shift and go to state 19
    STRING          shift and go to state 20
    FLOAT           shift and go to state 21
    INT             shift and go to state 22
    (               shift and go to state 16
    '               shift and go to state 23

    expr                           shift and go to state 77

state 38

    (44) expr -> expr MDIVIDE . expr
    (27) expr -> . EYE ( expr )
    (28) expr -> . ONES ( expr )
    (29) expr -> . ZEROS ( expr )
    (30) expr -> . ID
    (31) expr -> . [ outerlist ]
    (32) expr -> . STRING
    (33) expr -> . FLOAT
    (34) expr -> . INT
    (35) expr -> . expr '
    (36) expr -> . ( expr )
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr GEQ expr
    (40) expr -> . expr > expr
    (41) expr -> . expr LEQ expr
    (42) expr -> . expr < expr
    (43) expr -> . ' expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 15
    ONES            shift and go to state 17
    ZEROS           shift and go to state 18
    ID              shift and go to state 29
    [               shift and go to state 19
    STRING          shift and go to state 20
    FLOAT           shift and go to state 21
    INT             shift and go to state 22
    (               shift and go to state 16
    '               shift and go to state 23

    expr                           shift and go to state 78

state 39

    (45) expr -> expr MTIMES . expr
    (27) expr -> . EYE ( expr )
    (28) expr -> . ONES ( expr )
    (29) expr -> . ZEROS ( expr )
    (30) expr -> . ID
    (31) expr -> . [ outerlist ]
    (32) expr -> . STRING
    (33) expr -> . FLOAT
    (34) expr -> . INT
    (35) expr -> . expr '
    (36) expr -> . ( expr )
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr GEQ expr
    (40) expr -> . expr > expr
    (41) expr -> . expr LEQ expr
    (42) expr -> . expr < expr
    (43) expr -> . ' expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 15
    ONES            shift and go to state 17
    ZEROS           shift and go to state 18
    ID              shift and go to state 29
    [               shift and go to state 19
    STRING          shift and go to state 20
    FLOAT           shift and go to state 21
    INT             shift and go to state 22
    (               shift and go to state 16
    '               shift and go to state 23

    expr                           shift and go to state 79

state 40

    (46) expr -> expr MMINUS . expr
    (27) expr -> . EYE ( expr )
    (28) expr -> . ONES ( expr )
    (29) expr -> . ZEROS ( expr )
    (30) expr -> . ID
    (31) expr -> . [ outerlist ]
    (32) expr -> . STRING
    (33) expr -> . FLOAT
    (34) expr -> . INT
    (35) expr -> . expr '
    (36) expr -> . ( expr )
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr GEQ expr
    (40) expr -> . expr > expr
    (41) expr -> . expr LEQ expr
    (42) expr -> . expr < expr
    (43) expr -> . ' expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 15
    ONES            shift and go to state 17
    ZEROS           shift and go to state 18
    ID              shift and go to state 29
    [               shift and go to state 19
    STRING          shift and go to state 20
    FLOAT           shift and go to state 21
    INT             shift and go to state 22
    (               shift and go to state 16
    '               shift and go to state 23

    expr                           shift and go to state 80

state 41

    (47) expr -> expr MPLUS . expr
    (27) expr -> . EYE ( expr )
    (28) expr -> . ONES ( expr )
    (29) expr -> . ZEROS ( expr )
    (30) expr -> . ID
    (31) expr -> . [ outerlist ]
    (32) expr -> . STRING
    (33) expr -> . FLOAT
    (34) expr -> . INT
    (35) expr -> . expr '
    (36) expr -> . ( expr )
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr GEQ expr
    (40) expr -> . expr > expr
    (41) expr -> . expr LEQ expr
    (42) expr -> . expr < expr
    (43) expr -> . ' expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 15
    ONES            shift and go to state 17
    ZEROS           shift and go to state 18
    ID              shift and go to state 29
    [               shift and go to state 19
    STRING          shift and go to state 20
    FLOAT           shift and go to state 21
    INT             shift and go to state 22
    (               shift and go to state 16
    '               shift and go to state 23

    expr                           shift and go to state 81

state 42

    (48) expr -> expr / . expr
    (27) expr -> . EYE ( expr )
    (28) expr -> . ONES ( expr )
    (29) expr -> . ZEROS ( expr )
    (30) expr -> . ID
    (31) expr -> . [ outerlist ]
    (32) expr -> . STRING
    (33) expr -> . FLOAT
    (34) expr -> . INT
    (35) expr -> . expr '
    (36) expr -> . ( expr )
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr GEQ expr
    (40) expr -> . expr > expr
    (41) expr -> . expr LEQ expr
    (42) expr -> . expr < expr
    (43) expr -> . ' expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 15
    ONES            shift and go to state 17
    ZEROS           shift and go to state 18
    ID              shift and go to state 29
    [               shift and go to state 19
    STRING          shift and go to state 20
    FLOAT           shift and go to state 21
    INT             shift and go to state 22
    (               shift and go to state 16
    '               shift and go to state 23

    expr                           shift and go to state 82

state 43

    (49) expr -> expr * . expr
    (27) expr -> . EYE ( expr )
    (28) expr -> . ONES ( expr )
    (29) expr -> . ZEROS ( expr )
    (30) expr -> . ID
    (31) expr -> . [ outerlist ]
    (32) expr -> . STRING
    (33) expr -> . FLOAT
    (34) expr -> . INT
    (35) expr -> . expr '
    (36) expr -> . ( expr )
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr GEQ expr
    (40) expr -> . expr > expr
    (41) expr -> . expr LEQ expr
    (42) expr -> . expr < expr
    (43) expr -> . ' expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 15
    ONES            shift and go to state 17
    ZEROS           shift and go to state 18
    ID              shift and go to state 29
    [               shift and go to state 19
    STRING          shift and go to state 20
    FLOAT           shift and go to state 21
    INT             shift and go to state 22
    (               shift and go to state 16
    '               shift and go to state 23

    expr                           shift and go to state 83

state 44

    (50) expr -> expr - . expr
    (27) expr -> . EYE ( expr )
    (28) expr -> . ONES ( expr )
    (29) expr -> . ZEROS ( expr )
    (30) expr -> . ID
    (31) expr -> . [ outerlist ]
    (32) expr -> . STRING
    (33) expr -> . FLOAT
    (34) expr -> . INT
    (35) expr -> . expr '
    (36) expr -> . ( expr )
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr GEQ expr
    (40) expr -> . expr > expr
    (41) expr -> . expr LEQ expr
    (42) expr -> . expr < expr
    (43) expr -> . ' expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 15
    ONES            shift and go to state 17
    ZEROS           shift and go to state 18
    ID              shift and go to state 29
    [               shift and go to state 19
    STRING          shift and go to state 20
    FLOAT           shift and go to state 21
    INT             shift and go to state 22
    (               shift and go to state 16
    '               shift and go to state 23

    expr                           shift and go to state 84

state 45

    (51) expr -> expr + . expr
    (27) expr -> . EYE ( expr )
    (28) expr -> . ONES ( expr )
    (29) expr -> . ZEROS ( expr )
    (30) expr -> . ID
    (31) expr -> . [ outerlist ]
    (32) expr -> . STRING
    (33) expr -> . FLOAT
    (34) expr -> . INT
    (35) expr -> . expr '
    (36) expr -> . ( expr )
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr GEQ expr
    (40) expr -> . expr > expr
    (41) expr -> . expr LEQ expr
    (42) expr -> . expr < expr
    (43) expr -> . ' expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 15
    ONES            shift and go to state 17
    ZEROS           shift and go to state 18
    ID              shift and go to state 29
    [               shift and go to state 19
    STRING          shift and go to state 20
    FLOAT           shift and go to state 21
    INT             shift and go to state 22
    (               shift and go to state 16
    '               shift and go to state 23

    expr                           shift and go to state 85

state 46

    (7) statement -> IF expr . block ELSE block
    (8) statement -> IF expr . block
    (35) expr -> expr . '
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . GEQ expr
    (40) expr -> expr . > expr
    (41) expr -> expr . LEQ expr
    (42) expr -> expr . < expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . MTIMES expr
    (46) expr -> expr . MMINUS expr
    (47) expr -> expr . MPLUS expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    (25) block -> . { start }
    (26) block -> . statement
    (5) statement -> . FOR ID = range block
    (6) statement -> . WHILE expr block
    (7) statement -> . IF expr block ELSE block
    (8) statement -> . IF expr block
    (9) statement -> . PRINT values
    (10) statement -> . expr ;
    (11) statement -> . BREAK ;
    (12) statement -> . CONTINUE ;
    (13) statement -> . RETURN expr ;
    (14) statement -> . left_assign DASSIGN expr ;
    (15) statement -> . left_assign TASSIGN expr ;
    (16) statement -> . left_assign MASSIGN expr ;
    (17) statement -> . left_assign PASSIGN expr ;
    (18) statement -> . left_assign = expr ;
    (27) expr -> . EYE ( expr )
    (28) expr -> . ONES ( expr )
    (29) expr -> . ZEROS ( expr )
    (30) expr -> . ID
    (31) expr -> . [ outerlist ]
    (32) expr -> . STRING
    (33) expr -> . FLOAT
    (34) expr -> . INT
    (35) expr -> . expr '
    (36) expr -> . ( expr )
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr GEQ expr
    (40) expr -> . expr > expr
    (41) expr -> . expr LEQ expr
    (42) expr -> . expr < expr
    (43) expr -> . ' expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (19) left_assign -> . ID [ indexes ]
    (20) left_assign -> . ID
    '               shift and go to state 69
    NEQ             shift and go to state 32
    EQ              shift and go to state 33
    GEQ             shift and go to state 34
    >               shift and go to state 35
    LEQ             shift and go to state 36
    <               shift and go to state 37
    MDIVIDE         shift and go to state 38
    MTIMES          shift and go to state 39
    MMINUS          shift and go to state 40
    MPLUS           shift and go to state 41
    /               shift and go to state 42
    *               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45
    {               shift and go to state 70
    FOR             shift and go to state 5
    WHILE           shift and go to state 7
    IF              shift and go to state 9
    PRINT           shift and go to state 10
    BREAK           shift and go to state 11
    CONTINUE        shift and go to state 12
    RETURN          shift and go to state 13
    EYE             shift and go to state 15
    ONES            shift and go to state 17
    ZEROS           shift and go to state 18
    ID              shift and go to state 6
    [               shift and go to state 19
    STRING          shift and go to state 20
    FLOAT           shift and go to state 21
    INT             shift and go to state 22
    (               shift and go to state 16

    expr                           shift and go to state 8
    block                          shift and go to state 86
    statement                      shift and go to state 71
    left_assign                    shift and go to state 14

state 47

    (9) statement -> PRINT values .
    {               reduce using rule 9 (statement -> PRINT values .)
    FOR             reduce using rule 9 (statement -> PRINT values .)
    WHILE           reduce using rule 9 (statement -> PRINT values .)
    IF              reduce using rule 9 (statement -> PRINT values .)
    PRINT           reduce using rule 9 (statement -> PRINT values .)
    BREAK           reduce using rule 9 (statement -> PRINT values .)
    CONTINUE        reduce using rule 9 (statement -> PRINT values .)
    RETURN          reduce using rule 9 (statement -> PRINT values .)
    EYE             reduce using rule 9 (statement -> PRINT values .)
    ONES            reduce using rule 9 (statement -> PRINT values .)
    ZEROS           reduce using rule 9 (statement -> PRINT values .)
    ID              reduce using rule 9 (statement -> PRINT values .)
    [               reduce using rule 9 (statement -> PRINT values .)
    STRING          reduce using rule 9 (statement -> PRINT values .)
    FLOAT           reduce using rule 9 (statement -> PRINT values .)
    INT             reduce using rule 9 (statement -> PRINT values .)
    (               reduce using rule 9 (statement -> PRINT values .)
    '               reduce using rule 9 (statement -> PRINT values .)
    $end            reduce using rule 9 (statement -> PRINT values .)
    }               reduce using rule 9 (statement -> PRINT values .)
    ELSE            reduce using rule 9 (statement -> PRINT values .)


state 48

    (23) values -> expr . ;
    (24) values -> expr . , values
    (35) expr -> expr . '
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . GEQ expr
    (40) expr -> expr . > expr
    (41) expr -> expr . LEQ expr
    (42) expr -> expr . < expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . MTIMES expr
    (46) expr -> expr . MMINUS expr
    (47) expr -> expr . MPLUS expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    ;               shift and go to state 87
    ,               shift and go to state 88
    '               shift and go to state 31
    NEQ             shift and go to state 32
    EQ              shift and go to state 33
    GEQ             shift and go to state 34
    >               shift and go to state 35
    LEQ             shift and go to state 36
    <               shift and go to state 37
    MDIVIDE         shift and go to state 38
    MTIMES          shift and go to state 39
    MMINUS          shift and go to state 40
    MPLUS           shift and go to state 41
    /               shift and go to state 42
    *               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45


state 49

    (11) statement -> BREAK ; .
    {               reduce using rule 11 (statement -> BREAK ; .)
    FOR             reduce using rule 11 (statement -> BREAK ; .)
    WHILE           reduce using rule 11 (statement -> BREAK ; .)
    IF              reduce using rule 11 (statement -> BREAK ; .)
    PRINT           reduce using rule 11 (statement -> BREAK ; .)
    BREAK           reduce using rule 11 (statement -> BREAK ; .)
    CONTINUE        reduce using rule 11 (statement -> BREAK ; .)
    RETURN          reduce using rule 11 (statement -> BREAK ; .)
    EYE             reduce using rule 11 (statement -> BREAK ; .)
    ONES            reduce using rule 11 (statement -> BREAK ; .)
    ZEROS           reduce using rule 11 (statement -> BREAK ; .)
    ID              reduce using rule 11 (statement -> BREAK ; .)
    [               reduce using rule 11 (statement -> BREAK ; .)
    STRING          reduce using rule 11 (statement -> BREAK ; .)
    FLOAT           reduce using rule 11 (statement -> BREAK ; .)
    INT             reduce using rule 11 (statement -> BREAK ; .)
    (               reduce using rule 11 (statement -> BREAK ; .)
    '               reduce using rule 11 (statement -> BREAK ; .)
    $end            reduce using rule 11 (statement -> BREAK ; .)
    }               reduce using rule 11 (statement -> BREAK ; .)
    ELSE            reduce using rule 11 (statement -> BREAK ; .)


state 50

    (12) statement -> CONTINUE ; .
    {               reduce using rule 12 (statement -> CONTINUE ; .)
    FOR             reduce using rule 12 (statement -> CONTINUE ; .)
    WHILE           reduce using rule 12 (statement -> CONTINUE ; .)
    IF              reduce using rule 12 (statement -> CONTINUE ; .)
    PRINT           reduce using rule 12 (statement -> CONTINUE ; .)
    BREAK           reduce using rule 12 (statement -> CONTINUE ; .)
    CONTINUE        reduce using rule 12 (statement -> CONTINUE ; .)
    RETURN          reduce using rule 12 (statement -> CONTINUE ; .)
    EYE             reduce using rule 12 (statement -> CONTINUE ; .)
    ONES            reduce using rule 12 (statement -> CONTINUE ; .)
    ZEROS           reduce using rule 12 (statement -> CONTINUE ; .)
    ID              reduce using rule 12 (statement -> CONTINUE ; .)
    [               reduce using rule 12 (statement -> CONTINUE ; .)
    STRING          reduce using rule 12 (statement -> CONTINUE ; .)
    FLOAT           reduce using rule 12 (statement -> CONTINUE ; .)
    INT             reduce using rule 12 (statement -> CONTINUE ; .)
    (               reduce using rule 12 (statement -> CONTINUE ; .)
    '               reduce using rule 12 (statement -> CONTINUE ; .)
    $end            reduce using rule 12 (statement -> CONTINUE ; .)
    }               reduce using rule 12 (statement -> CONTINUE ; .)
    ELSE            reduce using rule 12 (statement -> CONTINUE ; .)


state 51

    (13) statement -> RETURN expr . ;
    (35) expr -> expr . '
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . GEQ expr
    (40) expr -> expr . > expr
    (41) expr -> expr . LEQ expr
    (42) expr -> expr . < expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . MTIMES expr
    (46) expr -> expr . MMINUS expr
    (47) expr -> expr . MPLUS expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    ;               shift and go to state 89
    '               shift and go to state 31
    NEQ             shift and go to state 32
    EQ              shift and go to state 33
    GEQ             shift and go to state 34
    >               shift and go to state 35
    LEQ             shift and go to state 36
    <               shift and go to state 37
    MDIVIDE         shift and go to state 38
    MTIMES          shift and go to state 39
    MMINUS          shift and go to state 40
    MPLUS           shift and go to state 41
    /               shift and go to state 42
    *               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45


state 52

    (14) statement -> left_assign DASSIGN . expr ;
    (27) expr -> . EYE ( expr )
    (28) expr -> . ONES ( expr )
    (29) expr -> . ZEROS ( expr )
    (30) expr -> . ID
    (31) expr -> . [ outerlist ]
    (32) expr -> . STRING
    (33) expr -> . FLOAT
    (34) expr -> . INT
    (35) expr -> . expr '
    (36) expr -> . ( expr )
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr GEQ expr
    (40) expr -> . expr > expr
    (41) expr -> . expr LEQ expr
    (42) expr -> . expr < expr
    (43) expr -> . ' expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 15
    ONES            shift and go to state 17
    ZEROS           shift and go to state 18
    ID              shift and go to state 29
    [               shift and go to state 19
    STRING          shift and go to state 20
    FLOAT           shift and go to state 21
    INT             shift and go to state 22
    (               shift and go to state 16
    '               shift and go to state 23

    expr                           shift and go to state 90

state 53

    (15) statement -> left_assign TASSIGN . expr ;
    (27) expr -> . EYE ( expr )
    (28) expr -> . ONES ( expr )
    (29) expr -> . ZEROS ( expr )
    (30) expr -> . ID
    (31) expr -> . [ outerlist ]
    (32) expr -> . STRING
    (33) expr -> . FLOAT
    (34) expr -> . INT
    (35) expr -> . expr '
    (36) expr -> . ( expr )
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr GEQ expr
    (40) expr -> . expr > expr
    (41) expr -> . expr LEQ expr
    (42) expr -> . expr < expr
    (43) expr -> . ' expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 15
    ONES            shift and go to state 17
    ZEROS           shift and go to state 18
    ID              shift and go to state 29
    [               shift and go to state 19
    STRING          shift and go to state 20
    FLOAT           shift and go to state 21
    INT             shift and go to state 22
    (               shift and go to state 16
    '               shift and go to state 23

    expr                           shift and go to state 91

state 54

    (16) statement -> left_assign MASSIGN . expr ;
    (27) expr -> . EYE ( expr )
    (28) expr -> . ONES ( expr )
    (29) expr -> . ZEROS ( expr )
    (30) expr -> . ID
    (31) expr -> . [ outerlist ]
    (32) expr -> . STRING
    (33) expr -> . FLOAT
    (34) expr -> . INT
    (35) expr -> . expr '
    (36) expr -> . ( expr )
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr GEQ expr
    (40) expr -> . expr > expr
    (41) expr -> . expr LEQ expr
    (42) expr -> . expr < expr
    (43) expr -> . ' expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 15
    ONES            shift and go to state 17
    ZEROS           shift and go to state 18
    ID              shift and go to state 29
    [               shift and go to state 19
    STRING          shift and go to state 20
    FLOAT           shift and go to state 21
    INT             shift and go to state 22
    (               shift and go to state 16
    '               shift and go to state 23

    expr                           shift and go to state 92

state 55

    (17) statement -> left_assign PASSIGN . expr ;
    (27) expr -> . EYE ( expr )
    (28) expr -> . ONES ( expr )
    (29) expr -> . ZEROS ( expr )
    (30) expr -> . ID
    (31) expr -> . [ outerlist ]
    (32) expr -> . STRING
    (33) expr -> . FLOAT
    (34) expr -> . INT
    (35) expr -> . expr '
    (36) expr -> . ( expr )
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr GEQ expr
    (40) expr -> . expr > expr
    (41) expr -> . expr LEQ expr
    (42) expr -> . expr < expr
    (43) expr -> . ' expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 15
    ONES            shift and go to state 17
    ZEROS           shift and go to state 18
    ID              shift and go to state 29
    [               shift and go to state 19
    STRING          shift and go to state 20
    FLOAT           shift and go to state 21
    INT             shift and go to state 22
    (               shift and go to state 16
    '               shift and go to state 23

    expr                           shift and go to state 93

state 56

    (18) statement -> left_assign = . expr ;
    (27) expr -> . EYE ( expr )
    (28) expr -> . ONES ( expr )
    (29) expr -> . ZEROS ( expr )
    (30) expr -> . ID
    (31) expr -> . [ outerlist ]
    (32) expr -> . STRING
    (33) expr -> . FLOAT
    (34) expr -> . INT
    (35) expr -> . expr '
    (36) expr -> . ( expr )
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr GEQ expr
    (40) expr -> . expr > expr
    (41) expr -> . expr LEQ expr
    (42) expr -> . expr < expr
    (43) expr -> . ' expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 15
    ONES            shift and go to state 17
    ZEROS           shift and go to state 18
    ID              shift and go to state 29
    [               shift and go to state 19
    STRING          shift and go to state 20
    FLOAT           shift and go to state 21
    INT             shift and go to state 22
    (               shift and go to state 16
    '               shift and go to state 23

    expr                           shift and go to state 94

state 57

    (27) expr -> EYE ( . expr )
    (27) expr -> . EYE ( expr )
    (28) expr -> . ONES ( expr )
    (29) expr -> . ZEROS ( expr )
    (30) expr -> . ID
    (31) expr -> . [ outerlist ]
    (32) expr -> . STRING
    (33) expr -> . FLOAT
    (34) expr -> . INT
    (35) expr -> . expr '
    (36) expr -> . ( expr )
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr GEQ expr
    (40) expr -> . expr > expr
    (41) expr -> . expr LEQ expr
    (42) expr -> . expr < expr
    (43) expr -> . ' expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 15
    ONES            shift and go to state 17
    ZEROS           shift and go to state 18
    ID              shift and go to state 29
    [               shift and go to state 19
    STRING          shift and go to state 20
    FLOAT           shift and go to state 21
    INT             shift and go to state 22
    (               shift and go to state 16
    '               shift and go to state 23

    expr                           shift and go to state 95

state 58

    (36) expr -> ( expr . )
    (35) expr -> expr . '
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . GEQ expr
    (40) expr -> expr . > expr
    (41) expr -> expr . LEQ expr
    (42) expr -> expr . < expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . MTIMES expr
    (46) expr -> expr . MMINUS expr
    (47) expr -> expr . MPLUS expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    )               shift and go to state 96
    '               shift and go to state 31
    NEQ             shift and go to state 32
    EQ              shift and go to state 33
    GEQ             shift and go to state 34
    >               shift and go to state 35
    LEQ             shift and go to state 36
    <               shift and go to state 37
    MDIVIDE         shift and go to state 38
    MTIMES          shift and go to state 39
    MMINUS          shift and go to state 40
    MPLUS           shift and go to state 41
    /               shift and go to state 42
    *               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45


state 59

    (28) expr -> ONES ( . expr )
    (27) expr -> . EYE ( expr )
    (28) expr -> . ONES ( expr )
    (29) expr -> . ZEROS ( expr )
    (30) expr -> . ID
    (31) expr -> . [ outerlist ]
    (32) expr -> . STRING
    (33) expr -> . FLOAT
    (34) expr -> . INT
    (35) expr -> . expr '
    (36) expr -> . ( expr )
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr GEQ expr
    (40) expr -> . expr > expr
    (41) expr -> . expr LEQ expr
    (42) expr -> . expr < expr
    (43) expr -> . ' expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 15
    ONES            shift and go to state 17
    ZEROS           shift and go to state 18
    ID              shift and go to state 29
    [               shift and go to state 19
    STRING          shift and go to state 20
    FLOAT           shift and go to state 21
    INT             shift and go to state 22
    (               shift and go to state 16
    '               shift and go to state 23

    expr                           shift and go to state 97

state 60

    (29) expr -> ZEROS ( . expr )
    (27) expr -> . EYE ( expr )
    (28) expr -> . ONES ( expr )
    (29) expr -> . ZEROS ( expr )
    (30) expr -> . ID
    (31) expr -> . [ outerlist ]
    (32) expr -> . STRING
    (33) expr -> . FLOAT
    (34) expr -> . INT
    (35) expr -> . expr '
    (36) expr -> . ( expr )
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr GEQ expr
    (40) expr -> . expr > expr
    (41) expr -> . expr LEQ expr
    (42) expr -> . expr < expr
    (43) expr -> . ' expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 15
    ONES            shift and go to state 17
    ZEROS           shift and go to state 18
    ID              shift and go to state 29
    [               shift and go to state 19
    STRING          shift and go to state 20
    FLOAT           shift and go to state 21
    INT             shift and go to state 22
    (               shift and go to state 16
    '               shift and go to state 23

    expr                           shift and go to state 98

state 61

    (56) outerlist -> [ . innerlist ]
    (58) innerlist -> . elem
    (59) innerlist -> . innerlist , elem
    (60) elem -> . STRING
    (61) elem -> . FLOAT
    (62) elem -> . INT
    STRING          shift and go to state 101
    FLOAT           shift and go to state 102
    INT             shift and go to state 103

    innerlist                      shift and go to state 99
    elem                           shift and go to state 100

state 62

    (31) expr -> [ outerlist . ]
    (57) outerlist -> outerlist . , [ innerlist ]
    ]               shift and go to state 104
    ,               shift and go to state 105


state 63

    (43) expr -> ' expr .
    (35) expr -> expr . '
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . GEQ expr
    (40) expr -> expr . > expr
    (41) expr -> expr . LEQ expr
    (42) expr -> expr . < expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . MTIMES expr
    (46) expr -> expr . MMINUS expr
    (47) expr -> expr . MPLUS expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    ;               reduce using rule 43 (expr -> ' expr .)
    NEQ             reduce using rule 43 (expr -> ' expr .)
    EQ              reduce using rule 43 (expr -> ' expr .)
    GEQ             reduce using rule 43 (expr -> ' expr .)
    >               reduce using rule 43 (expr -> ' expr .)
    LEQ             reduce using rule 43 (expr -> ' expr .)
    <               reduce using rule 43 (expr -> ' expr .)
    MDIVIDE         reduce using rule 43 (expr -> ' expr .)
    MTIMES          reduce using rule 43 (expr -> ' expr .)
    MMINUS          reduce using rule 43 (expr -> ' expr .)
    MPLUS           reduce using rule 43 (expr -> ' expr .)
    /               reduce using rule 43 (expr -> ' expr .)
    *               reduce using rule 43 (expr -> ' expr .)
    -               reduce using rule 43 (expr -> ' expr .)
    +               reduce using rule 43 (expr -> ' expr .)
    {               reduce using rule 43 (expr -> ' expr .)
    FOR             reduce using rule 43 (expr -> ' expr .)
    WHILE           reduce using rule 43 (expr -> ' expr .)
    IF              reduce using rule 43 (expr -> ' expr .)
    PRINT           reduce using rule 43 (expr -> ' expr .)
    BREAK           reduce using rule 43 (expr -> ' expr .)
    CONTINUE        reduce using rule 43 (expr -> ' expr .)
    RETURN          reduce using rule 43 (expr -> ' expr .)
    EYE             reduce using rule 43 (expr -> ' expr .)
    ONES            reduce using rule 43 (expr -> ' expr .)
    ZEROS           reduce using rule 43 (expr -> ' expr .)
    ID              reduce using rule 43 (expr -> ' expr .)
    [               reduce using rule 43 (expr -> ' expr .)
    STRING          reduce using rule 43 (expr -> ' expr .)
    FLOAT           reduce using rule 43 (expr -> ' expr .)
    INT             reduce using rule 43 (expr -> ' expr .)
    (               reduce using rule 43 (expr -> ' expr .)
    ,               reduce using rule 43 (expr -> ' expr .)
    )               reduce using rule 43 (expr -> ' expr .)
    '               shift and go to state 31


state 64

    (3) start -> { start } . start
    (2) start -> . empty
    (3) start -> . { start } start
    (4) start -> . statement start
    (1) empty -> .
    (5) statement -> . FOR ID = range block
    (6) statement -> . WHILE expr block
    (7) statement -> . IF expr block ELSE block
    (8) statement -> . IF expr block
    (9) statement -> . PRINT values
    (10) statement -> . expr ;
    (11) statement -> . BREAK ;
    (12) statement -> . CONTINUE ;
    (13) statement -> . RETURN expr ;
    (14) statement -> . left_assign DASSIGN expr ;
    (15) statement -> . left_assign TASSIGN expr ;
    (16) statement -> . left_assign MASSIGN expr ;
    (17) statement -> . left_assign PASSIGN expr ;
    (18) statement -> . left_assign = expr ;
    (27) expr -> . EYE ( expr )
    (28) expr -> . ONES ( expr )
    (29) expr -> . ZEROS ( expr )
    (30) expr -> . ID
    (31) expr -> . [ outerlist ]
    (32) expr -> . STRING
    (33) expr -> . FLOAT
    (34) expr -> . INT
    (35) expr -> . expr '
    (36) expr -> . ( expr )
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr GEQ expr
    (40) expr -> . expr > expr
    (41) expr -> . expr LEQ expr
    (42) expr -> . expr < expr
    (43) expr -> . ' expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (19) left_assign -> . ID [ indexes ]
    (20) left_assign -> . ID
    {               shift and go to state 3
    $end            reduce using rule 1 (empty -> .)
    }               reduce using rule 1 (empty -> .)
    FOR             shift and go to state 5
    WHILE           shift and go to state 7
    IF              shift and go to state 9
    PRINT           shift and go to state 10
    BREAK           shift and go to state 11
    CONTINUE        shift and go to state 12
    RETURN          shift and go to state 13
    EYE             shift and go to state 15
    ONES            shift and go to state 17
    ZEROS           shift and go to state 18
    ID              shift and go to state 6
    [               shift and go to state 19
    STRING          shift and go to state 20
    FLOAT           shift and go to state 21
    INT             shift and go to state 22
    (               shift and go to state 16
    '               shift and go to state 23

    start                          shift and go to state 106
    empty                          shift and go to state 2
    statement                      shift and go to state 4
    expr                           shift and go to state 8
    left_assign                    shift and go to state 14

state 65

    (5) statement -> FOR ID = . range block
    (52) range -> . INT : ID
    (53) range -> . ID : INT
    (54) range -> . ID : ID
    (55) range -> . INT : INT
    INT             shift and go to state 109
    ID              shift and go to state 107

    range                          shift and go to state 108

state 66

    (19) left_assign -> ID [ indexes . ]
    ]               shift and go to state 110


state 67

    (21) indexes -> INT .
    (22) indexes -> INT . , indexes
    ]               reduce using rule 21 (indexes -> INT .)
    ,               shift and go to state 111


state 68

    (6) statement -> WHILE expr block .
    {               reduce using rule 6 (statement -> WHILE expr block .)
    FOR             reduce using rule 6 (statement -> WHILE expr block .)
    WHILE           reduce using rule 6 (statement -> WHILE expr block .)
    IF              reduce using rule 6 (statement -> WHILE expr block .)
    PRINT           reduce using rule 6 (statement -> WHILE expr block .)
    BREAK           reduce using rule 6 (statement -> WHILE expr block .)
    CONTINUE        reduce using rule 6 (statement -> WHILE expr block .)
    RETURN          reduce using rule 6 (statement -> WHILE expr block .)
    EYE             reduce using rule 6 (statement -> WHILE expr block .)
    ONES            reduce using rule 6 (statement -> WHILE expr block .)
    ZEROS           reduce using rule 6 (statement -> WHILE expr block .)
    ID              reduce using rule 6 (statement -> WHILE expr block .)
    [               reduce using rule 6 (statement -> WHILE expr block .)
    STRING          reduce using rule 6 (statement -> WHILE expr block .)
    FLOAT           reduce using rule 6 (statement -> WHILE expr block .)
    INT             reduce using rule 6 (statement -> WHILE expr block .)
    (               reduce using rule 6 (statement -> WHILE expr block .)
    '               reduce using rule 6 (statement -> WHILE expr block .)
    $end            reduce using rule 6 (statement -> WHILE expr block .)
    }               reduce using rule 6 (statement -> WHILE expr block .)
    ELSE            reduce using rule 6 (statement -> WHILE expr block .)


state 69

    (35) expr -> expr ' .
    (43) expr -> ' . expr
    (27) expr -> . EYE ( expr )
    (28) expr -> . ONES ( expr )
    (29) expr -> . ZEROS ( expr )
    (30) expr -> . ID
    (31) expr -> . [ outerlist ]
    (32) expr -> . STRING
    (33) expr -> . FLOAT
    (34) expr -> . INT
    (35) expr -> . expr '
    (36) expr -> . ( expr )
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr GEQ expr
    (40) expr -> . expr > expr
    (41) expr -> . expr LEQ expr
    (42) expr -> . expr < expr
    (43) expr -> . ' expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    NEQ             reduce using rule 35 (expr -> expr ' .)
    EQ              reduce using rule 35 (expr -> expr ' .)
    GEQ             reduce using rule 35 (expr -> expr ' .)
    >               reduce using rule 35 (expr -> expr ' .)
    LEQ             reduce using rule 35 (expr -> expr ' .)
    <               reduce using rule 35 (expr -> expr ' .)
    MDIVIDE         reduce using rule 35 (expr -> expr ' .)
    MTIMES          reduce using rule 35 (expr -> expr ' .)
    MMINUS          reduce using rule 35 (expr -> expr ' .)
    MPLUS           reduce using rule 35 (expr -> expr ' .)
    /               reduce using rule 35 (expr -> expr ' .)
    *               reduce using rule 35 (expr -> expr ' .)
    -               reduce using rule 35 (expr -> expr ' .)
    +               reduce using rule 35 (expr -> expr ' .)
    {               reduce using rule 35 (expr -> expr ' .)
    FOR             reduce using rule 35 (expr -> expr ' .)
    WHILE           reduce using rule 35 (expr -> expr ' .)
    IF              reduce using rule 35 (expr -> expr ' .)
    PRINT           reduce using rule 35 (expr -> expr ' .)
    BREAK           reduce using rule 35 (expr -> expr ' .)
    CONTINUE        reduce using rule 35 (expr -> expr ' .)
    RETURN          reduce using rule 35 (expr -> expr ' .)
    EYE             reduce using rule 35 (expr -> expr ' .)
    ONES            reduce using rule 35 (expr -> expr ' .)
    ZEROS           reduce using rule 35 (expr -> expr ' .)
    ID              reduce using rule 35 (expr -> expr ' .)
    [               reduce using rule 35 (expr -> expr ' .)
    STRING          reduce using rule 35 (expr -> expr ' .)
    FLOAT           reduce using rule 35 (expr -> expr ' .)
    INT             reduce using rule 35 (expr -> expr ' .)
    (               reduce using rule 35 (expr -> expr ' .)
    '               shift and go to state 23

    expr                           shift and go to state 63

state 70

    (25) block -> { . start }
    (2) start -> . empty
    (3) start -> . { start } start
    (4) start -> . statement start
    (1) empty -> .
    (5) statement -> . FOR ID = range block
    (6) statement -> . WHILE expr block
    (7) statement -> . IF expr block ELSE block
    (8) statement -> . IF expr block
    (9) statement -> . PRINT values
    (10) statement -> . expr ;
    (11) statement -> . BREAK ;
    (12) statement -> . CONTINUE ;
    (13) statement -> . RETURN expr ;
    (14) statement -> . left_assign DASSIGN expr ;
    (15) statement -> . left_assign TASSIGN expr ;
    (16) statement -> . left_assign MASSIGN expr ;
    (17) statement -> . left_assign PASSIGN expr ;
    (18) statement -> . left_assign = expr ;
    (27) expr -> . EYE ( expr )
    (28) expr -> . ONES ( expr )
    (29) expr -> . ZEROS ( expr )
    (30) expr -> . ID
    (31) expr -> . [ outerlist ]
    (32) expr -> . STRING
    (33) expr -> . FLOAT
    (34) expr -> . INT
    (35) expr -> . expr '
    (36) expr -> . ( expr )
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr GEQ expr
    (40) expr -> . expr > expr
    (41) expr -> . expr LEQ expr
    (42) expr -> . expr < expr
    (43) expr -> . ' expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (19) left_assign -> . ID [ indexes ]
    (20) left_assign -> . ID
    {               shift and go to state 3
    }               reduce using rule 1 (empty -> .)
    FOR             shift and go to state 5
    WHILE           shift and go to state 7
    IF              shift and go to state 9
    PRINT           shift and go to state 10
    BREAK           shift and go to state 11
    CONTINUE        shift and go to state 12
    RETURN          shift and go to state 13
    EYE             shift and go to state 15
    ONES            shift and go to state 17
    ZEROS           shift and go to state 18
    ID              shift and go to state 6
    [               shift and go to state 19
    STRING          shift and go to state 20
    FLOAT           shift and go to state 21
    INT             shift and go to state 22
    (               shift and go to state 16
    '               shift and go to state 23

    start                          shift and go to state 112
    empty                          shift and go to state 2
    statement                      shift and go to state 4
    expr                           shift and go to state 8
    left_assign                    shift and go to state 14

state 71

    (26) block -> statement .
    {               reduce using rule 26 (block -> statement .)
    FOR             reduce using rule 26 (block -> statement .)
    WHILE           reduce using rule 26 (block -> statement .)
    IF              reduce using rule 26 (block -> statement .)
    PRINT           reduce using rule 26 (block -> statement .)
    BREAK           reduce using rule 26 (block -> statement .)
    CONTINUE        reduce using rule 26 (block -> statement .)
    RETURN          reduce using rule 26 (block -> statement .)
    EYE             reduce using rule 26 (block -> statement .)
    ONES            reduce using rule 26 (block -> statement .)
    ZEROS           reduce using rule 26 (block -> statement .)
    ID              reduce using rule 26 (block -> statement .)
    [               reduce using rule 26 (block -> statement .)
    STRING          reduce using rule 26 (block -> statement .)
    FLOAT           reduce using rule 26 (block -> statement .)
    INT             reduce using rule 26 (block -> statement .)
    (               reduce using rule 26 (block -> statement .)
    '               reduce using rule 26 (block -> statement .)
    $end            reduce using rule 26 (block -> statement .)
    }               reduce using rule 26 (block -> statement .)
    ELSE            reduce using rule 26 (block -> statement .)


state 72

    (37) expr -> expr NEQ expr .
    (35) expr -> expr . '
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . GEQ expr
    (40) expr -> expr . > expr
    (41) expr -> expr . LEQ expr
    (42) expr -> expr . < expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . MTIMES expr
    (46) expr -> expr . MMINUS expr
    (47) expr -> expr . MPLUS expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    ;               reduce using rule 37 (expr -> expr NEQ expr .)
    NEQ             reduce using rule 37 (expr -> expr NEQ expr .)
    EQ              reduce using rule 37 (expr -> expr NEQ expr .)
    GEQ             reduce using rule 37 (expr -> expr NEQ expr .)
    >               reduce using rule 37 (expr -> expr NEQ expr .)
    LEQ             reduce using rule 37 (expr -> expr NEQ expr .)
    <               reduce using rule 37 (expr -> expr NEQ expr .)
    {               reduce using rule 37 (expr -> expr NEQ expr .)
    FOR             reduce using rule 37 (expr -> expr NEQ expr .)
    WHILE           reduce using rule 37 (expr -> expr NEQ expr .)
    IF              reduce using rule 37 (expr -> expr NEQ expr .)
    PRINT           reduce using rule 37 (expr -> expr NEQ expr .)
    BREAK           reduce using rule 37 (expr -> expr NEQ expr .)
    CONTINUE        reduce using rule 37 (expr -> expr NEQ expr .)
    RETURN          reduce using rule 37 (expr -> expr NEQ expr .)
    EYE             reduce using rule 37 (expr -> expr NEQ expr .)
    ONES            reduce using rule 37 (expr -> expr NEQ expr .)
    ZEROS           reduce using rule 37 (expr -> expr NEQ expr .)
    ID              reduce using rule 37 (expr -> expr NEQ expr .)
    [               reduce using rule 37 (expr -> expr NEQ expr .)
    STRING          reduce using rule 37 (expr -> expr NEQ expr .)
    FLOAT           reduce using rule 37 (expr -> expr NEQ expr .)
    INT             reduce using rule 37 (expr -> expr NEQ expr .)
    (               reduce using rule 37 (expr -> expr NEQ expr .)
    ,               reduce using rule 37 (expr -> expr NEQ expr .)
    )               reduce using rule 37 (expr -> expr NEQ expr .)
    '               shift and go to state 31
    MDIVIDE         shift and go to state 38
    MTIMES          shift and go to state 39
    MMINUS          shift and go to state 40
    MPLUS           shift and go to state 41
    /               shift and go to state 42
    *               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45


state 73

    (38) expr -> expr EQ expr .
    (35) expr -> expr . '
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . GEQ expr
    (40) expr -> expr . > expr
    (41) expr -> expr . LEQ expr
    (42) expr -> expr . < expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . MTIMES expr
    (46) expr -> expr . MMINUS expr
    (47) expr -> expr . MPLUS expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    ;               reduce using rule 38 (expr -> expr EQ expr .)
    NEQ             reduce using rule 38 (expr -> expr EQ expr .)
    EQ              reduce using rule 38 (expr -> expr EQ expr .)
    GEQ             reduce using rule 38 (expr -> expr EQ expr .)
    >               reduce using rule 38 (expr -> expr EQ expr .)
    LEQ             reduce using rule 38 (expr -> expr EQ expr .)
    <               reduce using rule 38 (expr -> expr EQ expr .)
    {               reduce using rule 38 (expr -> expr EQ expr .)
    FOR             reduce using rule 38 (expr -> expr EQ expr .)
    WHILE           reduce using rule 38 (expr -> expr EQ expr .)
    IF              reduce using rule 38 (expr -> expr EQ expr .)
    PRINT           reduce using rule 38 (expr -> expr EQ expr .)
    BREAK           reduce using rule 38 (expr -> expr EQ expr .)
    CONTINUE        reduce using rule 38 (expr -> expr EQ expr .)
    RETURN          reduce using rule 38 (expr -> expr EQ expr .)
    EYE             reduce using rule 38 (expr -> expr EQ expr .)
    ONES            reduce using rule 38 (expr -> expr EQ expr .)
    ZEROS           reduce using rule 38 (expr -> expr EQ expr .)
    ID              reduce using rule 38 (expr -> expr EQ expr .)
    [               reduce using rule 38 (expr -> expr EQ expr .)
    STRING          reduce using rule 38 (expr -> expr EQ expr .)
    FLOAT           reduce using rule 38 (expr -> expr EQ expr .)
    INT             reduce using rule 38 (expr -> expr EQ expr .)
    (               reduce using rule 38 (expr -> expr EQ expr .)
    ,               reduce using rule 38 (expr -> expr EQ expr .)
    )               reduce using rule 38 (expr -> expr EQ expr .)
    '               shift and go to state 31
    MDIVIDE         shift and go to state 38
    MTIMES          shift and go to state 39
    MMINUS          shift and go to state 40
    MPLUS           shift and go to state 41
    /               shift and go to state 42
    *               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45


state 74

    (39) expr -> expr GEQ expr .
    (35) expr -> expr . '
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . GEQ expr
    (40) expr -> expr . > expr
    (41) expr -> expr . LEQ expr
    (42) expr -> expr . < expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . MTIMES expr
    (46) expr -> expr . MMINUS expr
    (47) expr -> expr . MPLUS expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    ;               reduce using rule 39 (expr -> expr GEQ expr .)
    NEQ             reduce using rule 39 (expr -> expr GEQ expr .)
    EQ              reduce using rule 39 (expr -> expr GEQ expr .)
    GEQ             reduce using rule 39 (expr -> expr GEQ expr .)
    >               reduce using rule 39 (expr -> expr GEQ expr .)
    LEQ             reduce using rule 39 (expr -> expr GEQ expr .)
    <               reduce using rule 39 (expr -> expr GEQ expr .)
    {               reduce using rule 39 (expr -> expr GEQ expr .)
    FOR             reduce using rule 39 (expr -> expr GEQ expr .)
    WHILE           reduce using rule 39 (expr -> expr GEQ expr .)
    IF              reduce using rule 39 (expr -> expr GEQ expr .)
    PRINT           reduce using rule 39 (expr -> expr GEQ expr .)
    BREAK           reduce using rule 39 (expr -> expr GEQ expr .)
    CONTINUE        reduce using rule 39 (expr -> expr GEQ expr .)
    RETURN          reduce using rule 39 (expr -> expr GEQ expr .)
    EYE             reduce using rule 39 (expr -> expr GEQ expr .)
    ONES            reduce using rule 39 (expr -> expr GEQ expr .)
    ZEROS           reduce using rule 39 (expr -> expr GEQ expr .)
    ID              reduce using rule 39 (expr -> expr GEQ expr .)
    [               reduce using rule 39 (expr -> expr GEQ expr .)
    STRING          reduce using rule 39 (expr -> expr GEQ expr .)
    FLOAT           reduce using rule 39 (expr -> expr GEQ expr .)
    INT             reduce using rule 39 (expr -> expr GEQ expr .)
    (               reduce using rule 39 (expr -> expr GEQ expr .)
    ,               reduce using rule 39 (expr -> expr GEQ expr .)
    )               reduce using rule 39 (expr -> expr GEQ expr .)
    '               shift and go to state 31
    MDIVIDE         shift and go to state 38
    MTIMES          shift and go to state 39
    MMINUS          shift and go to state 40
    MPLUS           shift and go to state 41
    /               shift and go to state 42
    *               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45


state 75

    (40) expr -> expr > expr .
    (35) expr -> expr . '
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . GEQ expr
    (40) expr -> expr . > expr
    (41) expr -> expr . LEQ expr
    (42) expr -> expr . < expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . MTIMES expr
    (46) expr -> expr . MMINUS expr
    (47) expr -> expr . MPLUS expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    ;               reduce using rule 40 (expr -> expr > expr .)
    NEQ             reduce using rule 40 (expr -> expr > expr .)
    EQ              reduce using rule 40 (expr -> expr > expr .)
    GEQ             reduce using rule 40 (expr -> expr > expr .)
    >               reduce using rule 40 (expr -> expr > expr .)
    LEQ             reduce using rule 40 (expr -> expr > expr .)
    <               reduce using rule 40 (expr -> expr > expr .)
    {               reduce using rule 40 (expr -> expr > expr .)
    FOR             reduce using rule 40 (expr -> expr > expr .)
    WHILE           reduce using rule 40 (expr -> expr > expr .)
    IF              reduce using rule 40 (expr -> expr > expr .)
    PRINT           reduce using rule 40 (expr -> expr > expr .)
    BREAK           reduce using rule 40 (expr -> expr > expr .)
    CONTINUE        reduce using rule 40 (expr -> expr > expr .)
    RETURN          reduce using rule 40 (expr -> expr > expr .)
    EYE             reduce using rule 40 (expr -> expr > expr .)
    ONES            reduce using rule 40 (expr -> expr > expr .)
    ZEROS           reduce using rule 40 (expr -> expr > expr .)
    ID              reduce using rule 40 (expr -> expr > expr .)
    [               reduce using rule 40 (expr -> expr > expr .)
    STRING          reduce using rule 40 (expr -> expr > expr .)
    FLOAT           reduce using rule 40 (expr -> expr > expr .)
    INT             reduce using rule 40 (expr -> expr > expr .)
    (               reduce using rule 40 (expr -> expr > expr .)
    ,               reduce using rule 40 (expr -> expr > expr .)
    )               reduce using rule 40 (expr -> expr > expr .)
    '               shift and go to state 31
    MDIVIDE         shift and go to state 38
    MTIMES          shift and go to state 39
    MMINUS          shift and go to state 40
    MPLUS           shift and go to state 41
    /               shift and go to state 42
    *               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45


state 76

    (41) expr -> expr LEQ expr .
    (35) expr -> expr . '
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . GEQ expr
    (40) expr -> expr . > expr
    (41) expr -> expr . LEQ expr
    (42) expr -> expr . < expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . MTIMES expr
    (46) expr -> expr . MMINUS expr
    (47) expr -> expr . MPLUS expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    ;               reduce using rule 41 (expr -> expr LEQ expr .)
    NEQ             reduce using rule 41 (expr -> expr LEQ expr .)
    EQ              reduce using rule 41 (expr -> expr LEQ expr .)
    GEQ             reduce using rule 41 (expr -> expr LEQ expr .)
    >               reduce using rule 41 (expr -> expr LEQ expr .)
    LEQ             reduce using rule 41 (expr -> expr LEQ expr .)
    <               reduce using rule 41 (expr -> expr LEQ expr .)
    {               reduce using rule 41 (expr -> expr LEQ expr .)
    FOR             reduce using rule 41 (expr -> expr LEQ expr .)
    WHILE           reduce using rule 41 (expr -> expr LEQ expr .)
    IF              reduce using rule 41 (expr -> expr LEQ expr .)
    PRINT           reduce using rule 41 (expr -> expr LEQ expr .)
    BREAK           reduce using rule 41 (expr -> expr LEQ expr .)
    CONTINUE        reduce using rule 41 (expr -> expr LEQ expr .)
    RETURN          reduce using rule 41 (expr -> expr LEQ expr .)
    EYE             reduce using rule 41 (expr -> expr LEQ expr .)
    ONES            reduce using rule 41 (expr -> expr LEQ expr .)
    ZEROS           reduce using rule 41 (expr -> expr LEQ expr .)
    ID              reduce using rule 41 (expr -> expr LEQ expr .)
    [               reduce using rule 41 (expr -> expr LEQ expr .)
    STRING          reduce using rule 41 (expr -> expr LEQ expr .)
    FLOAT           reduce using rule 41 (expr -> expr LEQ expr .)
    INT             reduce using rule 41 (expr -> expr LEQ expr .)
    (               reduce using rule 41 (expr -> expr LEQ expr .)
    ,               reduce using rule 41 (expr -> expr LEQ expr .)
    )               reduce using rule 41 (expr -> expr LEQ expr .)
    '               shift and go to state 31
    MDIVIDE         shift and go to state 38
    MTIMES          shift and go to state 39
    MMINUS          shift and go to state 40
    MPLUS           shift and go to state 41
    /               shift and go to state 42
    *               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45


state 77

    (42) expr -> expr < expr .
    (35) expr -> expr . '
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . GEQ expr
    (40) expr -> expr . > expr
    (41) expr -> expr . LEQ expr
    (42) expr -> expr . < expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . MTIMES expr
    (46) expr -> expr . MMINUS expr
    (47) expr -> expr . MPLUS expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    ;               reduce using rule 42 (expr -> expr < expr .)
    NEQ             reduce using rule 42 (expr -> expr < expr .)
    EQ              reduce using rule 42 (expr -> expr < expr .)
    GEQ             reduce using rule 42 (expr -> expr < expr .)
    >               reduce using rule 42 (expr -> expr < expr .)
    LEQ             reduce using rule 42 (expr -> expr < expr .)
    <               reduce using rule 42 (expr -> expr < expr .)
    {               reduce using rule 42 (expr -> expr < expr .)
    FOR             reduce using rule 42 (expr -> expr < expr .)
    WHILE           reduce using rule 42 (expr -> expr < expr .)
    IF              reduce using rule 42 (expr -> expr < expr .)
    PRINT           reduce using rule 42 (expr -> expr < expr .)
    BREAK           reduce using rule 42 (expr -> expr < expr .)
    CONTINUE        reduce using rule 42 (expr -> expr < expr .)
    RETURN          reduce using rule 42 (expr -> expr < expr .)
    EYE             reduce using rule 42 (expr -> expr < expr .)
    ONES            reduce using rule 42 (expr -> expr < expr .)
    ZEROS           reduce using rule 42 (expr -> expr < expr .)
    ID              reduce using rule 42 (expr -> expr < expr .)
    [               reduce using rule 42 (expr -> expr < expr .)
    STRING          reduce using rule 42 (expr -> expr < expr .)
    FLOAT           reduce using rule 42 (expr -> expr < expr .)
    INT             reduce using rule 42 (expr -> expr < expr .)
    (               reduce using rule 42 (expr -> expr < expr .)
    ,               reduce using rule 42 (expr -> expr < expr .)
    )               reduce using rule 42 (expr -> expr < expr .)
    '               shift and go to state 31
    MDIVIDE         shift and go to state 38
    MTIMES          shift and go to state 39
    MMINUS          shift and go to state 40
    MPLUS           shift and go to state 41
    /               shift and go to state 42
    *               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45


state 78

    (44) expr -> expr MDIVIDE expr .
    (35) expr -> expr . '
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . GEQ expr
    (40) expr -> expr . > expr
    (41) expr -> expr . LEQ expr
    (42) expr -> expr . < expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . MTIMES expr
    (46) expr -> expr . MMINUS expr
    (47) expr -> expr . MPLUS expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    ;               reduce using rule 44 (expr -> expr MDIVIDE expr .)
    NEQ             reduce using rule 44 (expr -> expr MDIVIDE expr .)
    EQ              reduce using rule 44 (expr -> expr MDIVIDE expr .)
    GEQ             reduce using rule 44 (expr -> expr MDIVIDE expr .)
    >               reduce using rule 44 (expr -> expr MDIVIDE expr .)
    LEQ             reduce using rule 44 (expr -> expr MDIVIDE expr .)
    <               reduce using rule 44 (expr -> expr MDIVIDE expr .)
    MDIVIDE         reduce using rule 44 (expr -> expr MDIVIDE expr .)
    MTIMES          reduce using rule 44 (expr -> expr MDIVIDE expr .)
    MMINUS          reduce using rule 44 (expr -> expr MDIVIDE expr .)
    MPLUS           reduce using rule 44 (expr -> expr MDIVIDE expr .)
    /               reduce using rule 44 (expr -> expr MDIVIDE expr .)
    *               reduce using rule 44 (expr -> expr MDIVIDE expr .)
    -               reduce using rule 44 (expr -> expr MDIVIDE expr .)
    +               reduce using rule 44 (expr -> expr MDIVIDE expr .)
    {               reduce using rule 44 (expr -> expr MDIVIDE expr .)
    FOR             reduce using rule 44 (expr -> expr MDIVIDE expr .)
    WHILE           reduce using rule 44 (expr -> expr MDIVIDE expr .)
    IF              reduce using rule 44 (expr -> expr MDIVIDE expr .)
    PRINT           reduce using rule 44 (expr -> expr MDIVIDE expr .)
    BREAK           reduce using rule 44 (expr -> expr MDIVIDE expr .)
    CONTINUE        reduce using rule 44 (expr -> expr MDIVIDE expr .)
    RETURN          reduce using rule 44 (expr -> expr MDIVIDE expr .)
    EYE             reduce using rule 44 (expr -> expr MDIVIDE expr .)
    ONES            reduce using rule 44 (expr -> expr MDIVIDE expr .)
    ZEROS           reduce using rule 44 (expr -> expr MDIVIDE expr .)
    ID              reduce using rule 44 (expr -> expr MDIVIDE expr .)
    [               reduce using rule 44 (expr -> expr MDIVIDE expr .)
    STRING          reduce using rule 44 (expr -> expr MDIVIDE expr .)
    FLOAT           reduce using rule 44 (expr -> expr MDIVIDE expr .)
    INT             reduce using rule 44 (expr -> expr MDIVIDE expr .)
    (               reduce using rule 44 (expr -> expr MDIVIDE expr .)
    ,               reduce using rule 44 (expr -> expr MDIVIDE expr .)
    )               reduce using rule 44 (expr -> expr MDIVIDE expr .)
    '               shift and go to state 31


state 79

    (45) expr -> expr MTIMES expr .
    (35) expr -> expr . '
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . GEQ expr
    (40) expr -> expr . > expr
    (41) expr -> expr . LEQ expr
    (42) expr -> expr . < expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . MTIMES expr
    (46) expr -> expr . MMINUS expr
    (47) expr -> expr . MPLUS expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    ;               reduce using rule 45 (expr -> expr MTIMES expr .)
    NEQ             reduce using rule 45 (expr -> expr MTIMES expr .)
    EQ              reduce using rule 45 (expr -> expr MTIMES expr .)
    GEQ             reduce using rule 45 (expr -> expr MTIMES expr .)
    >               reduce using rule 45 (expr -> expr MTIMES expr .)
    LEQ             reduce using rule 45 (expr -> expr MTIMES expr .)
    <               reduce using rule 45 (expr -> expr MTIMES expr .)
    MDIVIDE         reduce using rule 45 (expr -> expr MTIMES expr .)
    MTIMES          reduce using rule 45 (expr -> expr MTIMES expr .)
    MMINUS          reduce using rule 45 (expr -> expr MTIMES expr .)
    MPLUS           reduce using rule 45 (expr -> expr MTIMES expr .)
    /               reduce using rule 45 (expr -> expr MTIMES expr .)
    *               reduce using rule 45 (expr -> expr MTIMES expr .)
    -               reduce using rule 45 (expr -> expr MTIMES expr .)
    +               reduce using rule 45 (expr -> expr MTIMES expr .)
    {               reduce using rule 45 (expr -> expr MTIMES expr .)
    FOR             reduce using rule 45 (expr -> expr MTIMES expr .)
    WHILE           reduce using rule 45 (expr -> expr MTIMES expr .)
    IF              reduce using rule 45 (expr -> expr MTIMES expr .)
    PRINT           reduce using rule 45 (expr -> expr MTIMES expr .)
    BREAK           reduce using rule 45 (expr -> expr MTIMES expr .)
    CONTINUE        reduce using rule 45 (expr -> expr MTIMES expr .)
    RETURN          reduce using rule 45 (expr -> expr MTIMES expr .)
    EYE             reduce using rule 45 (expr -> expr MTIMES expr .)
    ONES            reduce using rule 45 (expr -> expr MTIMES expr .)
    ZEROS           reduce using rule 45 (expr -> expr MTIMES expr .)
    ID              reduce using rule 45 (expr -> expr MTIMES expr .)
    [               reduce using rule 45 (expr -> expr MTIMES expr .)
    STRING          reduce using rule 45 (expr -> expr MTIMES expr .)
    FLOAT           reduce using rule 45 (expr -> expr MTIMES expr .)
    INT             reduce using rule 45 (expr -> expr MTIMES expr .)
    (               reduce using rule 45 (expr -> expr MTIMES expr .)
    ,               reduce using rule 45 (expr -> expr MTIMES expr .)
    )               reduce using rule 45 (expr -> expr MTIMES expr .)
    '               shift and go to state 31


state 80

    (46) expr -> expr MMINUS expr .
    (35) expr -> expr . '
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . GEQ expr
    (40) expr -> expr . > expr
    (41) expr -> expr . LEQ expr
    (42) expr -> expr . < expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . MTIMES expr
    (46) expr -> expr . MMINUS expr
    (47) expr -> expr . MPLUS expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    ;               reduce using rule 46 (expr -> expr MMINUS expr .)
    NEQ             reduce using rule 46 (expr -> expr MMINUS expr .)
    EQ              reduce using rule 46 (expr -> expr MMINUS expr .)
    GEQ             reduce using rule 46 (expr -> expr MMINUS expr .)
    >               reduce using rule 46 (expr -> expr MMINUS expr .)
    LEQ             reduce using rule 46 (expr -> expr MMINUS expr .)
    <               reduce using rule 46 (expr -> expr MMINUS expr .)
    MMINUS          reduce using rule 46 (expr -> expr MMINUS expr .)
    MPLUS           reduce using rule 46 (expr -> expr MMINUS expr .)
    -               reduce using rule 46 (expr -> expr MMINUS expr .)
    +               reduce using rule 46 (expr -> expr MMINUS expr .)
    {               reduce using rule 46 (expr -> expr MMINUS expr .)
    FOR             reduce using rule 46 (expr -> expr MMINUS expr .)
    WHILE           reduce using rule 46 (expr -> expr MMINUS expr .)
    IF              reduce using rule 46 (expr -> expr MMINUS expr .)
    PRINT           reduce using rule 46 (expr -> expr MMINUS expr .)
    BREAK           reduce using rule 46 (expr -> expr MMINUS expr .)
    CONTINUE        reduce using rule 46 (expr -> expr MMINUS expr .)
    RETURN          reduce using rule 46 (expr -> expr MMINUS expr .)
    EYE             reduce using rule 46 (expr -> expr MMINUS expr .)
    ONES            reduce using rule 46 (expr -> expr MMINUS expr .)
    ZEROS           reduce using rule 46 (expr -> expr MMINUS expr .)
    ID              reduce using rule 46 (expr -> expr MMINUS expr .)
    [               reduce using rule 46 (expr -> expr MMINUS expr .)
    STRING          reduce using rule 46 (expr -> expr MMINUS expr .)
    FLOAT           reduce using rule 46 (expr -> expr MMINUS expr .)
    INT             reduce using rule 46 (expr -> expr MMINUS expr .)
    (               reduce using rule 46 (expr -> expr MMINUS expr .)
    ,               reduce using rule 46 (expr -> expr MMINUS expr .)
    )               reduce using rule 46 (expr -> expr MMINUS expr .)
    '               shift and go to state 31
    MDIVIDE         shift and go to state 38
    MTIMES          shift and go to state 39
    /               shift and go to state 42
    *               shift and go to state 43


state 81

    (47) expr -> expr MPLUS expr .
    (35) expr -> expr . '
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . GEQ expr
    (40) expr -> expr . > expr
    (41) expr -> expr . LEQ expr
    (42) expr -> expr . < expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . MTIMES expr
    (46) expr -> expr . MMINUS expr
    (47) expr -> expr . MPLUS expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    ;               reduce using rule 47 (expr -> expr MPLUS expr .)
    NEQ             reduce using rule 47 (expr -> expr MPLUS expr .)
    EQ              reduce using rule 47 (expr -> expr MPLUS expr .)
    GEQ             reduce using rule 47 (expr -> expr MPLUS expr .)
    >               reduce using rule 47 (expr -> expr MPLUS expr .)
    LEQ             reduce using rule 47 (expr -> expr MPLUS expr .)
    <               reduce using rule 47 (expr -> expr MPLUS expr .)
    MMINUS          reduce using rule 47 (expr -> expr MPLUS expr .)
    MPLUS           reduce using rule 47 (expr -> expr MPLUS expr .)
    -               reduce using rule 47 (expr -> expr MPLUS expr .)
    +               reduce using rule 47 (expr -> expr MPLUS expr .)
    {               reduce using rule 47 (expr -> expr MPLUS expr .)
    FOR             reduce using rule 47 (expr -> expr MPLUS expr .)
    WHILE           reduce using rule 47 (expr -> expr MPLUS expr .)
    IF              reduce using rule 47 (expr -> expr MPLUS expr .)
    PRINT           reduce using rule 47 (expr -> expr MPLUS expr .)
    BREAK           reduce using rule 47 (expr -> expr MPLUS expr .)
    CONTINUE        reduce using rule 47 (expr -> expr MPLUS expr .)
    RETURN          reduce using rule 47 (expr -> expr MPLUS expr .)
    EYE             reduce using rule 47 (expr -> expr MPLUS expr .)
    ONES            reduce using rule 47 (expr -> expr MPLUS expr .)
    ZEROS           reduce using rule 47 (expr -> expr MPLUS expr .)
    ID              reduce using rule 47 (expr -> expr MPLUS expr .)
    [               reduce using rule 47 (expr -> expr MPLUS expr .)
    STRING          reduce using rule 47 (expr -> expr MPLUS expr .)
    FLOAT           reduce using rule 47 (expr -> expr MPLUS expr .)
    INT             reduce using rule 47 (expr -> expr MPLUS expr .)
    (               reduce using rule 47 (expr -> expr MPLUS expr .)
    ,               reduce using rule 47 (expr -> expr MPLUS expr .)
    )               reduce using rule 47 (expr -> expr MPLUS expr .)
    '               shift and go to state 31
    MDIVIDE         shift and go to state 38
    MTIMES          shift and go to state 39
    /               shift and go to state 42
    *               shift and go to state 43


state 82

    (48) expr -> expr / expr .
    (35) expr -> expr . '
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . GEQ expr
    (40) expr -> expr . > expr
    (41) expr -> expr . LEQ expr
    (42) expr -> expr . < expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . MTIMES expr
    (46) expr -> expr . MMINUS expr
    (47) expr -> expr . MPLUS expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    ;               reduce using rule 48 (expr -> expr / expr .)
    NEQ             reduce using rule 48 (expr -> expr / expr .)
    EQ              reduce using rule 48 (expr -> expr / expr .)
    GEQ             reduce using rule 48 (expr -> expr / expr .)
    >               reduce using rule 48 (expr -> expr / expr .)
    LEQ             reduce using rule 48 (expr -> expr / expr .)
    <               reduce using rule 48 (expr -> expr / expr .)
    MDIVIDE         reduce using rule 48 (expr -> expr / expr .)
    MTIMES          reduce using rule 48 (expr -> expr / expr .)
    MMINUS          reduce using rule 48 (expr -> expr / expr .)
    MPLUS           reduce using rule 48 (expr -> expr / expr .)
    /               reduce using rule 48 (expr -> expr / expr .)
    *               reduce using rule 48 (expr -> expr / expr .)
    -               reduce using rule 48 (expr -> expr / expr .)
    +               reduce using rule 48 (expr -> expr / expr .)
    {               reduce using rule 48 (expr -> expr / expr .)
    FOR             reduce using rule 48 (expr -> expr / expr .)
    WHILE           reduce using rule 48 (expr -> expr / expr .)
    IF              reduce using rule 48 (expr -> expr / expr .)
    PRINT           reduce using rule 48 (expr -> expr / expr .)
    BREAK           reduce using rule 48 (expr -> expr / expr .)
    CONTINUE        reduce using rule 48 (expr -> expr / expr .)
    RETURN          reduce using rule 48 (expr -> expr / expr .)
    EYE             reduce using rule 48 (expr -> expr / expr .)
    ONES            reduce using rule 48 (expr -> expr / expr .)
    ZEROS           reduce using rule 48 (expr -> expr / expr .)
    ID              reduce using rule 48 (expr -> expr / expr .)
    [               reduce using rule 48 (expr -> expr / expr .)
    STRING          reduce using rule 48 (expr -> expr / expr .)
    FLOAT           reduce using rule 48 (expr -> expr / expr .)
    INT             reduce using rule 48 (expr -> expr / expr .)
    (               reduce using rule 48 (expr -> expr / expr .)
    ,               reduce using rule 48 (expr -> expr / expr .)
    )               reduce using rule 48 (expr -> expr / expr .)
    '               shift and go to state 31


state 83

    (49) expr -> expr * expr .
    (35) expr -> expr . '
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . GEQ expr
    (40) expr -> expr . > expr
    (41) expr -> expr . LEQ expr
    (42) expr -> expr . < expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . MTIMES expr
    (46) expr -> expr . MMINUS expr
    (47) expr -> expr . MPLUS expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    ;               reduce using rule 49 (expr -> expr * expr .)
    NEQ             reduce using rule 49 (expr -> expr * expr .)
    EQ              reduce using rule 49 (expr -> expr * expr .)
    GEQ             reduce using rule 49 (expr -> expr * expr .)
    >               reduce using rule 49 (expr -> expr * expr .)
    LEQ             reduce using rule 49 (expr -> expr * expr .)
    <               reduce using rule 49 (expr -> expr * expr .)
    MDIVIDE         reduce using rule 49 (expr -> expr * expr .)
    MTIMES          reduce using rule 49 (expr -> expr * expr .)
    MMINUS          reduce using rule 49 (expr -> expr * expr .)
    MPLUS           reduce using rule 49 (expr -> expr * expr .)
    /               reduce using rule 49 (expr -> expr * expr .)
    *               reduce using rule 49 (expr -> expr * expr .)
    -               reduce using rule 49 (expr -> expr * expr .)
    +               reduce using rule 49 (expr -> expr * expr .)
    {               reduce using rule 49 (expr -> expr * expr .)
    FOR             reduce using rule 49 (expr -> expr * expr .)
    WHILE           reduce using rule 49 (expr -> expr * expr .)
    IF              reduce using rule 49 (expr -> expr * expr .)
    PRINT           reduce using rule 49 (expr -> expr * expr .)
    BREAK           reduce using rule 49 (expr -> expr * expr .)
    CONTINUE        reduce using rule 49 (expr -> expr * expr .)
    RETURN          reduce using rule 49 (expr -> expr * expr .)
    EYE             reduce using rule 49 (expr -> expr * expr .)
    ONES            reduce using rule 49 (expr -> expr * expr .)
    ZEROS           reduce using rule 49 (expr -> expr * expr .)
    ID              reduce using rule 49 (expr -> expr * expr .)
    [               reduce using rule 49 (expr -> expr * expr .)
    STRING          reduce using rule 49 (expr -> expr * expr .)
    FLOAT           reduce using rule 49 (expr -> expr * expr .)
    INT             reduce using rule 49 (expr -> expr * expr .)
    (               reduce using rule 49 (expr -> expr * expr .)
    ,               reduce using rule 49 (expr -> expr * expr .)
    )               reduce using rule 49 (expr -> expr * expr .)
    '               shift and go to state 31


state 84

    (50) expr -> expr - expr .
    (35) expr -> expr . '
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . GEQ expr
    (40) expr -> expr . > expr
    (41) expr -> expr . LEQ expr
    (42) expr -> expr . < expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . MTIMES expr
    (46) expr -> expr . MMINUS expr
    (47) expr -> expr . MPLUS expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    ;               reduce using rule 50 (expr -> expr - expr .)
    NEQ             reduce using rule 50 (expr -> expr - expr .)
    EQ              reduce using rule 50 (expr -> expr - expr .)
    GEQ             reduce using rule 50 (expr -> expr - expr .)
    >               reduce using rule 50 (expr -> expr - expr .)
    LEQ             reduce using rule 50 (expr -> expr - expr .)
    <               reduce using rule 50 (expr -> expr - expr .)
    MMINUS          reduce using rule 50 (expr -> expr - expr .)
    MPLUS           reduce using rule 50 (expr -> expr - expr .)
    -               reduce using rule 50 (expr -> expr - expr .)
    +               reduce using rule 50 (expr -> expr - expr .)
    {               reduce using rule 50 (expr -> expr - expr .)
    FOR             reduce using rule 50 (expr -> expr - expr .)
    WHILE           reduce using rule 50 (expr -> expr - expr .)
    IF              reduce using rule 50 (expr -> expr - expr .)
    PRINT           reduce using rule 50 (expr -> expr - expr .)
    BREAK           reduce using rule 50 (expr -> expr - expr .)
    CONTINUE        reduce using rule 50 (expr -> expr - expr .)
    RETURN          reduce using rule 50 (expr -> expr - expr .)
    EYE             reduce using rule 50 (expr -> expr - expr .)
    ONES            reduce using rule 50 (expr -> expr - expr .)
    ZEROS           reduce using rule 50 (expr -> expr - expr .)
    ID              reduce using rule 50 (expr -> expr - expr .)
    [               reduce using rule 50 (expr -> expr - expr .)
    STRING          reduce using rule 50 (expr -> expr - expr .)
    FLOAT           reduce using rule 50 (expr -> expr - expr .)
    INT             reduce using rule 50 (expr -> expr - expr .)
    (               reduce using rule 50 (expr -> expr - expr .)
    ,               reduce using rule 50 (expr -> expr - expr .)
    )               reduce using rule 50 (expr -> expr - expr .)
    '               shift and go to state 31
    MDIVIDE         shift and go to state 38
    MTIMES          shift and go to state 39
    /               shift and go to state 42
    *               shift and go to state 43


state 85

    (51) expr -> expr + expr .
    (35) expr -> expr . '
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . GEQ expr
    (40) expr -> expr . > expr
    (41) expr -> expr . LEQ expr
    (42) expr -> expr . < expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . MTIMES expr
    (46) expr -> expr . MMINUS expr
    (47) expr -> expr . MPLUS expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    ;               reduce using rule 51 (expr -> expr + expr .)
    NEQ             reduce using rule 51 (expr -> expr + expr .)
    EQ              reduce using rule 51 (expr -> expr + expr .)
    GEQ             reduce using rule 51 (expr -> expr + expr .)
    >               reduce using rule 51 (expr -> expr + expr .)
    LEQ             reduce using rule 51 (expr -> expr + expr .)
    <               reduce using rule 51 (expr -> expr + expr .)
    MMINUS          reduce using rule 51 (expr -> expr + expr .)
    MPLUS           reduce using rule 51 (expr -> expr + expr .)
    -               reduce using rule 51 (expr -> expr + expr .)
    +               reduce using rule 51 (expr -> expr + expr .)
    {               reduce using rule 51 (expr -> expr + expr .)
    FOR             reduce using rule 51 (expr -> expr + expr .)
    WHILE           reduce using rule 51 (expr -> expr + expr .)
    IF              reduce using rule 51 (expr -> expr + expr .)
    PRINT           reduce using rule 51 (expr -> expr + expr .)
    BREAK           reduce using rule 51 (expr -> expr + expr .)
    CONTINUE        reduce using rule 51 (expr -> expr + expr .)
    RETURN          reduce using rule 51 (expr -> expr + expr .)
    EYE             reduce using rule 51 (expr -> expr + expr .)
    ONES            reduce using rule 51 (expr -> expr + expr .)
    ZEROS           reduce using rule 51 (expr -> expr + expr .)
    ID              reduce using rule 51 (expr -> expr + expr .)
    [               reduce using rule 51 (expr -> expr + expr .)
    STRING          reduce using rule 51 (expr -> expr + expr .)
    FLOAT           reduce using rule 51 (expr -> expr + expr .)
    INT             reduce using rule 51 (expr -> expr + expr .)
    (               reduce using rule 51 (expr -> expr + expr .)
    ,               reduce using rule 51 (expr -> expr + expr .)
    )               reduce using rule 51 (expr -> expr + expr .)
    '               shift and go to state 31
    MDIVIDE         shift and go to state 38
    MTIMES          shift and go to state 39
    /               shift and go to state 42
    *               shift and go to state 43


state 86

    (7) statement -> IF expr block . ELSE block
    (8) statement -> IF expr block .
    ELSE            shift and go to state 113
    {               reduce using rule 8 (statement -> IF expr block .)
    FOR             reduce using rule 8 (statement -> IF expr block .)
    WHILE           reduce using rule 8 (statement -> IF expr block .)
    IF              reduce using rule 8 (statement -> IF expr block .)
    PRINT           reduce using rule 8 (statement -> IF expr block .)
    BREAK           reduce using rule 8 (statement -> IF expr block .)
    CONTINUE        reduce using rule 8 (statement -> IF expr block .)
    RETURN          reduce using rule 8 (statement -> IF expr block .)
    EYE             reduce using rule 8 (statement -> IF expr block .)
    ONES            reduce using rule 8 (statement -> IF expr block .)
    ZEROS           reduce using rule 8 (statement -> IF expr block .)
    ID              reduce using rule 8 (statement -> IF expr block .)
    [               reduce using rule 8 (statement -> IF expr block .)
    STRING          reduce using rule 8 (statement -> IF expr block .)
    FLOAT           reduce using rule 8 (statement -> IF expr block .)
    INT             reduce using rule 8 (statement -> IF expr block .)
    (               reduce using rule 8 (statement -> IF expr block .)
    '               reduce using rule 8 (statement -> IF expr block .)
    $end            reduce using rule 8 (statement -> IF expr block .)
    }               reduce using rule 8 (statement -> IF expr block .)


state 87

    (23) values -> expr ; .
    {               reduce using rule 23 (values -> expr ; .)
    FOR             reduce using rule 23 (values -> expr ; .)
    WHILE           reduce using rule 23 (values -> expr ; .)
    IF              reduce using rule 23 (values -> expr ; .)
    PRINT           reduce using rule 23 (values -> expr ; .)
    BREAK           reduce using rule 23 (values -> expr ; .)
    CONTINUE        reduce using rule 23 (values -> expr ; .)
    RETURN          reduce using rule 23 (values -> expr ; .)
    EYE             reduce using rule 23 (values -> expr ; .)
    ONES            reduce using rule 23 (values -> expr ; .)
    ZEROS           reduce using rule 23 (values -> expr ; .)
    ID              reduce using rule 23 (values -> expr ; .)
    [               reduce using rule 23 (values -> expr ; .)
    STRING          reduce using rule 23 (values -> expr ; .)
    FLOAT           reduce using rule 23 (values -> expr ; .)
    INT             reduce using rule 23 (values -> expr ; .)
    (               reduce using rule 23 (values -> expr ; .)
    '               reduce using rule 23 (values -> expr ; .)
    $end            reduce using rule 23 (values -> expr ; .)
    }               reduce using rule 23 (values -> expr ; .)
    ELSE            reduce using rule 23 (values -> expr ; .)


state 88

    (24) values -> expr , . values
    (23) values -> . expr ;
    (24) values -> . expr , values
    (27) expr -> . EYE ( expr )
    (28) expr -> . ONES ( expr )
    (29) expr -> . ZEROS ( expr )
    (30) expr -> . ID
    (31) expr -> . [ outerlist ]
    (32) expr -> . STRING
    (33) expr -> . FLOAT
    (34) expr -> . INT
    (35) expr -> . expr '
    (36) expr -> . ( expr )
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr GEQ expr
    (40) expr -> . expr > expr
    (41) expr -> . expr LEQ expr
    (42) expr -> . expr < expr
    (43) expr -> . ' expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    EYE             shift and go to state 15
    ONES            shift and go to state 17
    ZEROS           shift and go to state 18
    ID              shift and go to state 29
    [               shift and go to state 19
    STRING          shift and go to state 20
    FLOAT           shift and go to state 21
    INT             shift and go to state 22
    (               shift and go to state 16
    '               shift and go to state 23

    expr                           shift and go to state 48
    values                         shift and go to state 114

state 89

    (13) statement -> RETURN expr ; .
    {               reduce using rule 13 (statement -> RETURN expr ; .)
    FOR             reduce using rule 13 (statement -> RETURN expr ; .)
    WHILE           reduce using rule 13 (statement -> RETURN expr ; .)
    IF              reduce using rule 13 (statement -> RETURN expr ; .)
    PRINT           reduce using rule 13 (statement -> RETURN expr ; .)
    BREAK           reduce using rule 13 (statement -> RETURN expr ; .)
    CONTINUE        reduce using rule 13 (statement -> RETURN expr ; .)
    RETURN          reduce using rule 13 (statement -> RETURN expr ; .)
    EYE             reduce using rule 13 (statement -> RETURN expr ; .)
    ONES            reduce using rule 13 (statement -> RETURN expr ; .)
    ZEROS           reduce using rule 13 (statement -> RETURN expr ; .)
    ID              reduce using rule 13 (statement -> RETURN expr ; .)
    [               reduce using rule 13 (statement -> RETURN expr ; .)
    STRING          reduce using rule 13 (statement -> RETURN expr ; .)
    FLOAT           reduce using rule 13 (statement -> RETURN expr ; .)
    INT             reduce using rule 13 (statement -> RETURN expr ; .)
    (               reduce using rule 13 (statement -> RETURN expr ; .)
    '               reduce using rule 13 (statement -> RETURN expr ; .)
    $end            reduce using rule 13 (statement -> RETURN expr ; .)
    }               reduce using rule 13 (statement -> RETURN expr ; .)
    ELSE            reduce using rule 13 (statement -> RETURN expr ; .)


state 90

    (14) statement -> left_assign DASSIGN expr . ;
    (35) expr -> expr . '
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . GEQ expr
    (40) expr -> expr . > expr
    (41) expr -> expr . LEQ expr
    (42) expr -> expr . < expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . MTIMES expr
    (46) expr -> expr . MMINUS expr
    (47) expr -> expr . MPLUS expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    ;               shift and go to state 115
    '               shift and go to state 31
    NEQ             shift and go to state 32
    EQ              shift and go to state 33
    GEQ             shift and go to state 34
    >               shift and go to state 35
    LEQ             shift and go to state 36
    <               shift and go to state 37
    MDIVIDE         shift and go to state 38
    MTIMES          shift and go to state 39
    MMINUS          shift and go to state 40
    MPLUS           shift and go to state 41
    /               shift and go to state 42
    *               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45


state 91

    (15) statement -> left_assign TASSIGN expr . ;
    (35) expr -> expr . '
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . GEQ expr
    (40) expr -> expr . > expr
    (41) expr -> expr . LEQ expr
    (42) expr -> expr . < expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . MTIMES expr
    (46) expr -> expr . MMINUS expr
    (47) expr -> expr . MPLUS expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    ;               shift and go to state 116
    '               shift and go to state 31
    NEQ             shift and go to state 32
    EQ              shift and go to state 33
    GEQ             shift and go to state 34
    >               shift and go to state 35
    LEQ             shift and go to state 36
    <               shift and go to state 37
    MDIVIDE         shift and go to state 38
    MTIMES          shift and go to state 39
    MMINUS          shift and go to state 40
    MPLUS           shift and go to state 41
    /               shift and go to state 42
    *               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45


state 92

    (16) statement -> left_assign MASSIGN expr . ;
    (35) expr -> expr . '
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . GEQ expr
    (40) expr -> expr . > expr
    (41) expr -> expr . LEQ expr
    (42) expr -> expr . < expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . MTIMES expr
    (46) expr -> expr . MMINUS expr
    (47) expr -> expr . MPLUS expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    ;               shift and go to state 117
    '               shift and go to state 31
    NEQ             shift and go to state 32
    EQ              shift and go to state 33
    GEQ             shift and go to state 34
    >               shift and go to state 35
    LEQ             shift and go to state 36
    <               shift and go to state 37
    MDIVIDE         shift and go to state 38
    MTIMES          shift and go to state 39
    MMINUS          shift and go to state 40
    MPLUS           shift and go to state 41
    /               shift and go to state 42
    *               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45


state 93

    (17) statement -> left_assign PASSIGN expr . ;
    (35) expr -> expr . '
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . GEQ expr
    (40) expr -> expr . > expr
    (41) expr -> expr . LEQ expr
    (42) expr -> expr . < expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . MTIMES expr
    (46) expr -> expr . MMINUS expr
    (47) expr -> expr . MPLUS expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    ;               shift and go to state 118
    '               shift and go to state 31
    NEQ             shift and go to state 32
    EQ              shift and go to state 33
    GEQ             shift and go to state 34
    >               shift and go to state 35
    LEQ             shift and go to state 36
    <               shift and go to state 37
    MDIVIDE         shift and go to state 38
    MTIMES          shift and go to state 39
    MMINUS          shift and go to state 40
    MPLUS           shift and go to state 41
    /               shift and go to state 42
    *               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45


state 94

    (18) statement -> left_assign = expr . ;
    (35) expr -> expr . '
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . GEQ expr
    (40) expr -> expr . > expr
    (41) expr -> expr . LEQ expr
    (42) expr -> expr . < expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . MTIMES expr
    (46) expr -> expr . MMINUS expr
    (47) expr -> expr . MPLUS expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    ;               shift and go to state 119
    '               shift and go to state 31
    NEQ             shift and go to state 32
    EQ              shift and go to state 33
    GEQ             shift and go to state 34
    >               shift and go to state 35
    LEQ             shift and go to state 36
    <               shift and go to state 37
    MDIVIDE         shift and go to state 38
    MTIMES          shift and go to state 39
    MMINUS          shift and go to state 40
    MPLUS           shift and go to state 41
    /               shift and go to state 42
    *               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45


state 95

    (27) expr -> EYE ( expr . )
    (35) expr -> expr . '
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . GEQ expr
    (40) expr -> expr . > expr
    (41) expr -> expr . LEQ expr
    (42) expr -> expr . < expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . MTIMES expr
    (46) expr -> expr . MMINUS expr
    (47) expr -> expr . MPLUS expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    )               shift and go to state 120
    '               shift and go to state 31
    NEQ             shift and go to state 32
    EQ              shift and go to state 33
    GEQ             shift and go to state 34
    >               shift and go to state 35
    LEQ             shift and go to state 36
    <               shift and go to state 37
    MDIVIDE         shift and go to state 38
    MTIMES          shift and go to state 39
    MMINUS          shift and go to state 40
    MPLUS           shift and go to state 41
    /               shift and go to state 42
    *               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45


state 96

    (36) expr -> ( expr ) .
    ;               reduce using rule 36 (expr -> ( expr ) .)
    '               reduce using rule 36 (expr -> ( expr ) .)
    NEQ             reduce using rule 36 (expr -> ( expr ) .)
    EQ              reduce using rule 36 (expr -> ( expr ) .)
    GEQ             reduce using rule 36 (expr -> ( expr ) .)
    >               reduce using rule 36 (expr -> ( expr ) .)
    LEQ             reduce using rule 36 (expr -> ( expr ) .)
    <               reduce using rule 36 (expr -> ( expr ) .)
    MDIVIDE         reduce using rule 36 (expr -> ( expr ) .)
    MTIMES          reduce using rule 36 (expr -> ( expr ) .)
    MMINUS          reduce using rule 36 (expr -> ( expr ) .)
    MPLUS           reduce using rule 36 (expr -> ( expr ) .)
    /               reduce using rule 36 (expr -> ( expr ) .)
    *               reduce using rule 36 (expr -> ( expr ) .)
    -               reduce using rule 36 (expr -> ( expr ) .)
    +               reduce using rule 36 (expr -> ( expr ) .)
    {               reduce using rule 36 (expr -> ( expr ) .)
    FOR             reduce using rule 36 (expr -> ( expr ) .)
    WHILE           reduce using rule 36 (expr -> ( expr ) .)
    IF              reduce using rule 36 (expr -> ( expr ) .)
    PRINT           reduce using rule 36 (expr -> ( expr ) .)
    BREAK           reduce using rule 36 (expr -> ( expr ) .)
    CONTINUE        reduce using rule 36 (expr -> ( expr ) .)
    RETURN          reduce using rule 36 (expr -> ( expr ) .)
    EYE             reduce using rule 36 (expr -> ( expr ) .)
    ONES            reduce using rule 36 (expr -> ( expr ) .)
    ZEROS           reduce using rule 36 (expr -> ( expr ) .)
    ID              reduce using rule 36 (expr -> ( expr ) .)
    [               reduce using rule 36 (expr -> ( expr ) .)
    STRING          reduce using rule 36 (expr -> ( expr ) .)
    FLOAT           reduce using rule 36 (expr -> ( expr ) .)
    INT             reduce using rule 36 (expr -> ( expr ) .)
    (               reduce using rule 36 (expr -> ( expr ) .)
    ,               reduce using rule 36 (expr -> ( expr ) .)
    )               reduce using rule 36 (expr -> ( expr ) .)


state 97

    (28) expr -> ONES ( expr . )
    (35) expr -> expr . '
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . GEQ expr
    (40) expr -> expr . > expr
    (41) expr -> expr . LEQ expr
    (42) expr -> expr . < expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . MTIMES expr
    (46) expr -> expr . MMINUS expr
    (47) expr -> expr . MPLUS expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    )               shift and go to state 121
    '               shift and go to state 31
    NEQ             shift and go to state 32
    EQ              shift and go to state 33
    GEQ             shift and go to state 34
    >               shift and go to state 35
    LEQ             shift and go to state 36
    <               shift and go to state 37
    MDIVIDE         shift and go to state 38
    MTIMES          shift and go to state 39
    MMINUS          shift and go to state 40
    MPLUS           shift and go to state 41
    /               shift and go to state 42
    *               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45


state 98

    (29) expr -> ZEROS ( expr . )
    (35) expr -> expr . '
    (37) expr -> expr . NEQ expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . GEQ expr
    (40) expr -> expr . > expr
    (41) expr -> expr . LEQ expr
    (42) expr -> expr . < expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . MTIMES expr
    (46) expr -> expr . MMINUS expr
    (47) expr -> expr . MPLUS expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    )               shift and go to state 122
    '               shift and go to state 31
    NEQ             shift and go to state 32
    EQ              shift and go to state 33
    GEQ             shift and go to state 34
    >               shift and go to state 35
    LEQ             shift and go to state 36
    <               shift and go to state 37
    MDIVIDE         shift and go to state 38
    MTIMES          shift and go to state 39
    MMINUS          shift and go to state 40
    MPLUS           shift and go to state 41
    /               shift and go to state 42
    *               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45


state 99

    (56) outerlist -> [ innerlist . ]
    (59) innerlist -> innerlist . , elem
    ]               shift and go to state 123
    ,               shift and go to state 124


state 100

    (58) innerlist -> elem .
    ]               reduce using rule 58 (innerlist -> elem .)
    ,               reduce using rule 58 (innerlist -> elem .)


state 101

    (60) elem -> STRING .
    ]               reduce using rule 60 (elem -> STRING .)
    ,               reduce using rule 60 (elem -> STRING .)


state 102

    (61) elem -> FLOAT .
    ]               reduce using rule 61 (elem -> FLOAT .)
    ,               reduce using rule 61 (elem -> FLOAT .)


state 103

    (62) elem -> INT .
    ]               reduce using rule 62 (elem -> INT .)
    ,               reduce using rule 62 (elem -> INT .)


state 104

    (31) expr -> [ outerlist ] .
    ;               reduce using rule 31 (expr -> [ outerlist ] .)
    '               reduce using rule 31 (expr -> [ outerlist ] .)
    NEQ             reduce using rule 31 (expr -> [ outerlist ] .)
    EQ              reduce using rule 31 (expr -> [ outerlist ] .)
    GEQ             reduce using rule 31 (expr -> [ outerlist ] .)
    >               reduce using rule 31 (expr -> [ outerlist ] .)
    LEQ             reduce using rule 31 (expr -> [ outerlist ] .)
    <               reduce using rule 31 (expr -> [ outerlist ] .)
    MDIVIDE         reduce using rule 31 (expr -> [ outerlist ] .)
    MTIMES          reduce using rule 31 (expr -> [ outerlist ] .)
    MMINUS          reduce using rule 31 (expr -> [ outerlist ] .)
    MPLUS           reduce using rule 31 (expr -> [ outerlist ] .)
    /               reduce using rule 31 (expr -> [ outerlist ] .)
    *               reduce using rule 31 (expr -> [ outerlist ] .)
    -               reduce using rule 31 (expr -> [ outerlist ] .)
    +               reduce using rule 31 (expr -> [ outerlist ] .)
    {               reduce using rule 31 (expr -> [ outerlist ] .)
    FOR             reduce using rule 31 (expr -> [ outerlist ] .)
    WHILE           reduce using rule 31 (expr -> [ outerlist ] .)
    IF              reduce using rule 31 (expr -> [ outerlist ] .)
    PRINT           reduce using rule 31 (expr -> [ outerlist ] .)
    BREAK           reduce using rule 31 (expr -> [ outerlist ] .)
    CONTINUE        reduce using rule 31 (expr -> [ outerlist ] .)
    RETURN          reduce using rule 31 (expr -> [ outerlist ] .)
    EYE             reduce using rule 31 (expr -> [ outerlist ] .)
    ONES            reduce using rule 31 (expr -> [ outerlist ] .)
    ZEROS           reduce using rule 31 (expr -> [ outerlist ] .)
    ID              reduce using rule 31 (expr -> [ outerlist ] .)
    [               reduce using rule 31 (expr -> [ outerlist ] .)
    STRING          reduce using rule 31 (expr -> [ outerlist ] .)
    FLOAT           reduce using rule 31 (expr -> [ outerlist ] .)
    INT             reduce using rule 31 (expr -> [ outerlist ] .)
    (               reduce using rule 31 (expr -> [ outerlist ] .)
    ,               reduce using rule 31 (expr -> [ outerlist ] .)
    )               reduce using rule 31 (expr -> [ outerlist ] .)


state 105

    (57) outerlist -> outerlist , . [ innerlist ]
    [               shift and go to state 125


state 106

    (3) start -> { start } start .
    $end            reduce using rule 3 (start -> { start } start .)
    }               reduce using rule 3 (start -> { start } start .)


state 107

    (53) range -> ID . : INT
    (54) range -> ID . : ID
    :               shift and go to state 126


state 108

    (5) statement -> FOR ID = range . block
    (25) block -> . { start }
    (26) block -> . statement
    (5) statement -> . FOR ID = range block
    (6) statement -> . WHILE expr block
    (7) statement -> . IF expr block ELSE block
    (8) statement -> . IF expr block
    (9) statement -> . PRINT values
    (10) statement -> . expr ;
    (11) statement -> . BREAK ;
    (12) statement -> . CONTINUE ;
    (13) statement -> . RETURN expr ;
    (14) statement -> . left_assign DASSIGN expr ;
    (15) statement -> . left_assign TASSIGN expr ;
    (16) statement -> . left_assign MASSIGN expr ;
    (17) statement -> . left_assign PASSIGN expr ;
    (18) statement -> . left_assign = expr ;
    (27) expr -> . EYE ( expr )
    (28) expr -> . ONES ( expr )
    (29) expr -> . ZEROS ( expr )
    (30) expr -> . ID
    (31) expr -> . [ outerlist ]
    (32) expr -> . STRING
    (33) expr -> . FLOAT
    (34) expr -> . INT
    (35) expr -> . expr '
    (36) expr -> . ( expr )
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr GEQ expr
    (40) expr -> . expr > expr
    (41) expr -> . expr LEQ expr
    (42) expr -> . expr < expr
    (43) expr -> . ' expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (19) left_assign -> . ID [ indexes ]
    (20) left_assign -> . ID
    {               shift and go to state 70
    FOR             shift and go to state 5
    WHILE           shift and go to state 7
    IF              shift and go to state 9
    PRINT           shift and go to state 10
    BREAK           shift and go to state 11
    CONTINUE        shift and go to state 12
    RETURN          shift and go to state 13
    EYE             shift and go to state 15
    ONES            shift and go to state 17
    ZEROS           shift and go to state 18
    ID              shift and go to state 6
    [               shift and go to state 19
    STRING          shift and go to state 20
    FLOAT           shift and go to state 21
    INT             shift and go to state 22
    (               shift and go to state 16
    '               shift and go to state 23

    block                          shift and go to state 127
    statement                      shift and go to state 71
    expr                           shift and go to state 8
    left_assign                    shift and go to state 14

state 109

    (52) range -> INT . : ID
    (55) range -> INT . : INT
    :               shift and go to state 128


state 110

    (19) left_assign -> ID [ indexes ] .
    DASSIGN         reduce using rule 19 (left_assign -> ID [ indexes ] .)
    TASSIGN         reduce using rule 19 (left_assign -> ID [ indexes ] .)
    MASSIGN         reduce using rule 19 (left_assign -> ID [ indexes ] .)
    PASSIGN         reduce using rule 19 (left_assign -> ID [ indexes ] .)
    =               reduce using rule 19 (left_assign -> ID [ indexes ] .)


state 111

    (22) indexes -> INT , . indexes
    (21) indexes -> . INT
    (22) indexes -> . INT , indexes
    INT             shift and go to state 67

    indexes                        shift and go to state 129

state 112

    (25) block -> { start . }
    }               shift and go to state 130


state 113

    (7) statement -> IF expr block ELSE . block
    (25) block -> . { start }
    (26) block -> . statement
    (5) statement -> . FOR ID = range block
    (6) statement -> . WHILE expr block
    (7) statement -> . IF expr block ELSE block
    (8) statement -> . IF expr block
    (9) statement -> . PRINT values
    (10) statement -> . expr ;
    (11) statement -> . BREAK ;
    (12) statement -> . CONTINUE ;
    (13) statement -> . RETURN expr ;
    (14) statement -> . left_assign DASSIGN expr ;
    (15) statement -> . left_assign TASSIGN expr ;
    (16) statement -> . left_assign MASSIGN expr ;
    (17) statement -> . left_assign PASSIGN expr ;
    (18) statement -> . left_assign = expr ;
    (27) expr -> . EYE ( expr )
    (28) expr -> . ONES ( expr )
    (29) expr -> . ZEROS ( expr )
    (30) expr -> . ID
    (31) expr -> . [ outerlist ]
    (32) expr -> . STRING
    (33) expr -> . FLOAT
    (34) expr -> . INT
    (35) expr -> . expr '
    (36) expr -> . ( expr )
    (37) expr -> . expr NEQ expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr GEQ expr
    (40) expr -> . expr > expr
    (41) expr -> . expr LEQ expr
    (42) expr -> . expr < expr
    (43) expr -> . ' expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr MTIMES expr
    (46) expr -> . expr MMINUS expr
    (47) expr -> . expr MPLUS expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (19) left_assign -> . ID [ indexes ]
    (20) left_assign -> . ID
    {               shift and go to state 70
    FOR             shift and go to state 5
    WHILE           shift and go to state 7
    IF              shift and go to state 9
    PRINT           shift and go to state 10
    BREAK           shift and go to state 11
    CONTINUE        shift and go to state 12
    RETURN          shift and go to state 13
    EYE             shift and go to state 15
    ONES            shift and go to state 17
    ZEROS           shift and go to state 18
    ID              shift and go to state 6
    [               shift and go to state 19
    STRING          shift and go to state 20
    FLOAT           shift and go to state 21
    INT             shift and go to state 22
    (               shift and go to state 16
    '               shift and go to state 23

    expr                           shift and go to state 8
    block                          shift and go to state 131
    statement                      shift and go to state 71
    left_assign                    shift and go to state 14

state 114

    (24) values -> expr , values .
    {               reduce using rule 24 (values -> expr , values .)
    FOR             reduce using rule 24 (values -> expr , values .)
    WHILE           reduce using rule 24 (values -> expr , values .)
    IF              reduce using rule 24 (values -> expr , values .)
    PRINT           reduce using rule 24 (values -> expr , values .)
    BREAK           reduce using rule 24 (values -> expr , values .)
    CONTINUE        reduce using rule 24 (values -> expr , values .)
    RETURN          reduce using rule 24 (values -> expr , values .)
    EYE             reduce using rule 24 (values -> expr , values .)
    ONES            reduce using rule 24 (values -> expr , values .)
    ZEROS           reduce using rule 24 (values -> expr , values .)
    ID              reduce using rule 24 (values -> expr , values .)
    [               reduce using rule 24 (values -> expr , values .)
    STRING          reduce using rule 24 (values -> expr , values .)
    FLOAT           reduce using rule 24 (values -> expr , values .)
    INT             reduce using rule 24 (values -> expr , values .)
    (               reduce using rule 24 (values -> expr , values .)
    '               reduce using rule 24 (values -> expr , values .)
    $end            reduce using rule 24 (values -> expr , values .)
    }               reduce using rule 24 (values -> expr , values .)
    ELSE            reduce using rule 24 (values -> expr , values .)


state 115

    (14) statement -> left_assign DASSIGN expr ; .
    {               reduce using rule 14 (statement -> left_assign DASSIGN expr ; .)
    FOR             reduce using rule 14 (statement -> left_assign DASSIGN expr ; .)
    WHILE           reduce using rule 14 (statement -> left_assign DASSIGN expr ; .)
    IF              reduce using rule 14 (statement -> left_assign DASSIGN expr ; .)
    PRINT           reduce using rule 14 (statement -> left_assign DASSIGN expr ; .)
    BREAK           reduce using rule 14 (statement -> left_assign DASSIGN expr ; .)
    CONTINUE        reduce using rule 14 (statement -> left_assign DASSIGN expr ; .)
    RETURN          reduce using rule 14 (statement -> left_assign DASSIGN expr ; .)
    EYE             reduce using rule 14 (statement -> left_assign DASSIGN expr ; .)
    ONES            reduce using rule 14 (statement -> left_assign DASSIGN expr ; .)
    ZEROS           reduce using rule 14 (statement -> left_assign DASSIGN expr ; .)
    ID              reduce using rule 14 (statement -> left_assign DASSIGN expr ; .)
    [               reduce using rule 14 (statement -> left_assign DASSIGN expr ; .)
    STRING          reduce using rule 14 (statement -> left_assign DASSIGN expr ; .)
    FLOAT           reduce using rule 14 (statement -> left_assign DASSIGN expr ; .)
    INT             reduce using rule 14 (statement -> left_assign DASSIGN expr ; .)
    (               reduce using rule 14 (statement -> left_assign DASSIGN expr ; .)
    '               reduce using rule 14 (statement -> left_assign DASSIGN expr ; .)
    $end            reduce using rule 14 (statement -> left_assign DASSIGN expr ; .)
    }               reduce using rule 14 (statement -> left_assign DASSIGN expr ; .)
    ELSE            reduce using rule 14 (statement -> left_assign DASSIGN expr ; .)


state 116

    (15) statement -> left_assign TASSIGN expr ; .
    {               reduce using rule 15 (statement -> left_assign TASSIGN expr ; .)
    FOR             reduce using rule 15 (statement -> left_assign TASSIGN expr ; .)
    WHILE           reduce using rule 15 (statement -> left_assign TASSIGN expr ; .)
    IF              reduce using rule 15 (statement -> left_assign TASSIGN expr ; .)
    PRINT           reduce using rule 15 (statement -> left_assign TASSIGN expr ; .)
    BREAK           reduce using rule 15 (statement -> left_assign TASSIGN expr ; .)
    CONTINUE        reduce using rule 15 (statement -> left_assign TASSIGN expr ; .)
    RETURN          reduce using rule 15 (statement -> left_assign TASSIGN expr ; .)
    EYE             reduce using rule 15 (statement -> left_assign TASSIGN expr ; .)
    ONES            reduce using rule 15 (statement -> left_assign TASSIGN expr ; .)
    ZEROS           reduce using rule 15 (statement -> left_assign TASSIGN expr ; .)
    ID              reduce using rule 15 (statement -> left_assign TASSIGN expr ; .)
    [               reduce using rule 15 (statement -> left_assign TASSIGN expr ; .)
    STRING          reduce using rule 15 (statement -> left_assign TASSIGN expr ; .)
    FLOAT           reduce using rule 15 (statement -> left_assign TASSIGN expr ; .)
    INT             reduce using rule 15 (statement -> left_assign TASSIGN expr ; .)
    (               reduce using rule 15 (statement -> left_assign TASSIGN expr ; .)
    '               reduce using rule 15 (statement -> left_assign TASSIGN expr ; .)
    $end            reduce using rule 15 (statement -> left_assign TASSIGN expr ; .)
    }               reduce using rule 15 (statement -> left_assign TASSIGN expr ; .)
    ELSE            reduce using rule 15 (statement -> left_assign TASSIGN expr ; .)


state 117

    (16) statement -> left_assign MASSIGN expr ; .
    {               reduce using rule 16 (statement -> left_assign MASSIGN expr ; .)
    FOR             reduce using rule 16 (statement -> left_assign MASSIGN expr ; .)
    WHILE           reduce using rule 16 (statement -> left_assign MASSIGN expr ; .)
    IF              reduce using rule 16 (statement -> left_assign MASSIGN expr ; .)
    PRINT           reduce using rule 16 (statement -> left_assign MASSIGN expr ; .)
    BREAK           reduce using rule 16 (statement -> left_assign MASSIGN expr ; .)
    CONTINUE        reduce using rule 16 (statement -> left_assign MASSIGN expr ; .)
    RETURN          reduce using rule 16 (statement -> left_assign MASSIGN expr ; .)
    EYE             reduce using rule 16 (statement -> left_assign MASSIGN expr ; .)
    ONES            reduce using rule 16 (statement -> left_assign MASSIGN expr ; .)
    ZEROS           reduce using rule 16 (statement -> left_assign MASSIGN expr ; .)
    ID              reduce using rule 16 (statement -> left_assign MASSIGN expr ; .)
    [               reduce using rule 16 (statement -> left_assign MASSIGN expr ; .)
    STRING          reduce using rule 16 (statement -> left_assign MASSIGN expr ; .)
    FLOAT           reduce using rule 16 (statement -> left_assign MASSIGN expr ; .)
    INT             reduce using rule 16 (statement -> left_assign MASSIGN expr ; .)
    (               reduce using rule 16 (statement -> left_assign MASSIGN expr ; .)
    '               reduce using rule 16 (statement -> left_assign MASSIGN expr ; .)
    $end            reduce using rule 16 (statement -> left_assign MASSIGN expr ; .)
    }               reduce using rule 16 (statement -> left_assign MASSIGN expr ; .)
    ELSE            reduce using rule 16 (statement -> left_assign MASSIGN expr ; .)


state 118

    (17) statement -> left_assign PASSIGN expr ; .
    {               reduce using rule 17 (statement -> left_assign PASSIGN expr ; .)
    FOR             reduce using rule 17 (statement -> left_assign PASSIGN expr ; .)
    WHILE           reduce using rule 17 (statement -> left_assign PASSIGN expr ; .)
    IF              reduce using rule 17 (statement -> left_assign PASSIGN expr ; .)
    PRINT           reduce using rule 17 (statement -> left_assign PASSIGN expr ; .)
    BREAK           reduce using rule 17 (statement -> left_assign PASSIGN expr ; .)
    CONTINUE        reduce using rule 17 (statement -> left_assign PASSIGN expr ; .)
    RETURN          reduce using rule 17 (statement -> left_assign PASSIGN expr ; .)
    EYE             reduce using rule 17 (statement -> left_assign PASSIGN expr ; .)
    ONES            reduce using rule 17 (statement -> left_assign PASSIGN expr ; .)
    ZEROS           reduce using rule 17 (statement -> left_assign PASSIGN expr ; .)
    ID              reduce using rule 17 (statement -> left_assign PASSIGN expr ; .)
    [               reduce using rule 17 (statement -> left_assign PASSIGN expr ; .)
    STRING          reduce using rule 17 (statement -> left_assign PASSIGN expr ; .)
    FLOAT           reduce using rule 17 (statement -> left_assign PASSIGN expr ; .)
    INT             reduce using rule 17 (statement -> left_assign PASSIGN expr ; .)
    (               reduce using rule 17 (statement -> left_assign PASSIGN expr ; .)
    '               reduce using rule 17 (statement -> left_assign PASSIGN expr ; .)
    $end            reduce using rule 17 (statement -> left_assign PASSIGN expr ; .)
    }               reduce using rule 17 (statement -> left_assign PASSIGN expr ; .)
    ELSE            reduce using rule 17 (statement -> left_assign PASSIGN expr ; .)


state 119

    (18) statement -> left_assign = expr ; .
    {               reduce using rule 18 (statement -> left_assign = expr ; .)
    FOR             reduce using rule 18 (statement -> left_assign = expr ; .)
    WHILE           reduce using rule 18 (statement -> left_assign = expr ; .)
    IF              reduce using rule 18 (statement -> left_assign = expr ; .)
    PRINT           reduce using rule 18 (statement -> left_assign = expr ; .)
    BREAK           reduce using rule 18 (statement -> left_assign = expr ; .)
    CONTINUE        reduce using rule 18 (statement -> left_assign = expr ; .)
    RETURN          reduce using rule 18 (statement -> left_assign = expr ; .)
    EYE             reduce using rule 18 (statement -> left_assign = expr ; .)
    ONES            reduce using rule 18 (statement -> left_assign = expr ; .)
    ZEROS           reduce using rule 18 (statement -> left_assign = expr ; .)
    ID              reduce using rule 18 (statement -> left_assign = expr ; .)
    [               reduce using rule 18 (statement -> left_assign = expr ; .)
    STRING          reduce using rule 18 (statement -> left_assign = expr ; .)
    FLOAT           reduce using rule 18 (statement -> left_assign = expr ; .)
    INT             reduce using rule 18 (statement -> left_assign = expr ; .)
    (               reduce using rule 18 (statement -> left_assign = expr ; .)
    '               reduce using rule 18 (statement -> left_assign = expr ; .)
    $end            reduce using rule 18 (statement -> left_assign = expr ; .)
    }               reduce using rule 18 (statement -> left_assign = expr ; .)
    ELSE            reduce using rule 18 (statement -> left_assign = expr ; .)


state 120

    (27) expr -> EYE ( expr ) .
    ;               reduce using rule 27 (expr -> EYE ( expr ) .)
    '               reduce using rule 27 (expr -> EYE ( expr ) .)
    NEQ             reduce using rule 27 (expr -> EYE ( expr ) .)
    EQ              reduce using rule 27 (expr -> EYE ( expr ) .)
    GEQ             reduce using rule 27 (expr -> EYE ( expr ) .)
    >               reduce using rule 27 (expr -> EYE ( expr ) .)
    LEQ             reduce using rule 27 (expr -> EYE ( expr ) .)
    <               reduce using rule 27 (expr -> EYE ( expr ) .)
    MDIVIDE         reduce using rule 27 (expr -> EYE ( expr ) .)
    MTIMES          reduce using rule 27 (expr -> EYE ( expr ) .)
    MMINUS          reduce using rule 27 (expr -> EYE ( expr ) .)
    MPLUS           reduce using rule 27 (expr -> EYE ( expr ) .)
    /               reduce using rule 27 (expr -> EYE ( expr ) .)
    *               reduce using rule 27 (expr -> EYE ( expr ) .)
    -               reduce using rule 27 (expr -> EYE ( expr ) .)
    +               reduce using rule 27 (expr -> EYE ( expr ) .)
    {               reduce using rule 27 (expr -> EYE ( expr ) .)
    FOR             reduce using rule 27 (expr -> EYE ( expr ) .)
    WHILE           reduce using rule 27 (expr -> EYE ( expr ) .)
    IF              reduce using rule 27 (expr -> EYE ( expr ) .)
    PRINT           reduce using rule 27 (expr -> EYE ( expr ) .)
    BREAK           reduce using rule 27 (expr -> EYE ( expr ) .)
    CONTINUE        reduce using rule 27 (expr -> EYE ( expr ) .)
    RETURN          reduce using rule 27 (expr -> EYE ( expr ) .)
    EYE             reduce using rule 27 (expr -> EYE ( expr ) .)
    ONES            reduce using rule 27 (expr -> EYE ( expr ) .)
    ZEROS           reduce using rule 27 (expr -> EYE ( expr ) .)
    ID              reduce using rule 27 (expr -> EYE ( expr ) .)
    [               reduce using rule 27 (expr -> EYE ( expr ) .)
    STRING          reduce using rule 27 (expr -> EYE ( expr ) .)
    FLOAT           reduce using rule 27 (expr -> EYE ( expr ) .)
    INT             reduce using rule 27 (expr -> EYE ( expr ) .)
    (               reduce using rule 27 (expr -> EYE ( expr ) .)
    ,               reduce using rule 27 (expr -> EYE ( expr ) .)
    )               reduce using rule 27 (expr -> EYE ( expr ) .)


state 121

    (28) expr -> ONES ( expr ) .
    ;               reduce using rule 28 (expr -> ONES ( expr ) .)
    '               reduce using rule 28 (expr -> ONES ( expr ) .)
    NEQ             reduce using rule 28 (expr -> ONES ( expr ) .)
    EQ              reduce using rule 28 (expr -> ONES ( expr ) .)
    GEQ             reduce using rule 28 (expr -> ONES ( expr ) .)
    >               reduce using rule 28 (expr -> ONES ( expr ) .)
    LEQ             reduce using rule 28 (expr -> ONES ( expr ) .)
    <               reduce using rule 28 (expr -> ONES ( expr ) .)
    MDIVIDE         reduce using rule 28 (expr -> ONES ( expr ) .)
    MTIMES          reduce using rule 28 (expr -> ONES ( expr ) .)
    MMINUS          reduce using rule 28 (expr -> ONES ( expr ) .)
    MPLUS           reduce using rule 28 (expr -> ONES ( expr ) .)
    /               reduce using rule 28 (expr -> ONES ( expr ) .)
    *               reduce using rule 28 (expr -> ONES ( expr ) .)
    -               reduce using rule 28 (expr -> ONES ( expr ) .)
    +               reduce using rule 28 (expr -> ONES ( expr ) .)
    {               reduce using rule 28 (expr -> ONES ( expr ) .)
    FOR             reduce using rule 28 (expr -> ONES ( expr ) .)
    WHILE           reduce using rule 28 (expr -> ONES ( expr ) .)
    IF              reduce using rule 28 (expr -> ONES ( expr ) .)
    PRINT           reduce using rule 28 (expr -> ONES ( expr ) .)
    BREAK           reduce using rule 28 (expr -> ONES ( expr ) .)
    CONTINUE        reduce using rule 28 (expr -> ONES ( expr ) .)
    RETURN          reduce using rule 28 (expr -> ONES ( expr ) .)
    EYE             reduce using rule 28 (expr -> ONES ( expr ) .)
    ONES            reduce using rule 28 (expr -> ONES ( expr ) .)
    ZEROS           reduce using rule 28 (expr -> ONES ( expr ) .)
    ID              reduce using rule 28 (expr -> ONES ( expr ) .)
    [               reduce using rule 28 (expr -> ONES ( expr ) .)
    STRING          reduce using rule 28 (expr -> ONES ( expr ) .)
    FLOAT           reduce using rule 28 (expr -> ONES ( expr ) .)
    INT             reduce using rule 28 (expr -> ONES ( expr ) .)
    (               reduce using rule 28 (expr -> ONES ( expr ) .)
    ,               reduce using rule 28 (expr -> ONES ( expr ) .)
    )               reduce using rule 28 (expr -> ONES ( expr ) .)


state 122

    (29) expr -> ZEROS ( expr ) .
    ;               reduce using rule 29 (expr -> ZEROS ( expr ) .)
    '               reduce using rule 29 (expr -> ZEROS ( expr ) .)
    NEQ             reduce using rule 29 (expr -> ZEROS ( expr ) .)
    EQ              reduce using rule 29 (expr -> ZEROS ( expr ) .)
    GEQ             reduce using rule 29 (expr -> ZEROS ( expr ) .)
    >               reduce using rule 29 (expr -> ZEROS ( expr ) .)
    LEQ             reduce using rule 29 (expr -> ZEROS ( expr ) .)
    <               reduce using rule 29 (expr -> ZEROS ( expr ) .)
    MDIVIDE         reduce using rule 29 (expr -> ZEROS ( expr ) .)
    MTIMES          reduce using rule 29 (expr -> ZEROS ( expr ) .)
    MMINUS          reduce using rule 29 (expr -> ZEROS ( expr ) .)
    MPLUS           reduce using rule 29 (expr -> ZEROS ( expr ) .)
    /               reduce using rule 29 (expr -> ZEROS ( expr ) .)
    *               reduce using rule 29 (expr -> ZEROS ( expr ) .)
    -               reduce using rule 29 (expr -> ZEROS ( expr ) .)
    +               reduce using rule 29 (expr -> ZEROS ( expr ) .)
    {               reduce using rule 29 (expr -> ZEROS ( expr ) .)
    FOR             reduce using rule 29 (expr -> ZEROS ( expr ) .)
    WHILE           reduce using rule 29 (expr -> ZEROS ( expr ) .)
    IF              reduce using rule 29 (expr -> ZEROS ( expr ) .)
    PRINT           reduce using rule 29 (expr -> ZEROS ( expr ) .)
    BREAK           reduce using rule 29 (expr -> ZEROS ( expr ) .)
    CONTINUE        reduce using rule 29 (expr -> ZEROS ( expr ) .)
    RETURN          reduce using rule 29 (expr -> ZEROS ( expr ) .)
    EYE             reduce using rule 29 (expr -> ZEROS ( expr ) .)
    ONES            reduce using rule 29 (expr -> ZEROS ( expr ) .)
    ZEROS           reduce using rule 29 (expr -> ZEROS ( expr ) .)
    ID              reduce using rule 29 (expr -> ZEROS ( expr ) .)
    [               reduce using rule 29 (expr -> ZEROS ( expr ) .)
    STRING          reduce using rule 29 (expr -> ZEROS ( expr ) .)
    FLOAT           reduce using rule 29 (expr -> ZEROS ( expr ) .)
    INT             reduce using rule 29 (expr -> ZEROS ( expr ) .)
    (               reduce using rule 29 (expr -> ZEROS ( expr ) .)
    ,               reduce using rule 29 (expr -> ZEROS ( expr ) .)
    )               reduce using rule 29 (expr -> ZEROS ( expr ) .)


state 123

    (56) outerlist -> [ innerlist ] .
    ]               reduce using rule 56 (outerlist -> [ innerlist ] .)
    ,               reduce using rule 56 (outerlist -> [ innerlist ] .)


state 124

    (59) innerlist -> innerlist , . elem
    (60) elem -> . STRING
    (61) elem -> . FLOAT
    (62) elem -> . INT
    STRING          shift and go to state 101
    FLOAT           shift and go to state 102
    INT             shift and go to state 103

    elem                           shift and go to state 132

state 125

    (57) outerlist -> outerlist , [ . innerlist ]
    (58) innerlist -> . elem
    (59) innerlist -> . innerlist , elem
    (60) elem -> . STRING
    (61) elem -> . FLOAT
    (62) elem -> . INT
    STRING          shift and go to state 101
    FLOAT           shift and go to state 102
    INT             shift and go to state 103

    innerlist                      shift and go to state 133
    elem                           shift and go to state 100

state 126

    (53) range -> ID : . INT
    (54) range -> ID : . ID
    INT             shift and go to state 135
    ID              shift and go to state 134


state 127

    (5) statement -> FOR ID = range block .
    {               reduce using rule 5 (statement -> FOR ID = range block .)
    FOR             reduce using rule 5 (statement -> FOR ID = range block .)
    WHILE           reduce using rule 5 (statement -> FOR ID = range block .)
    IF              reduce using rule 5 (statement -> FOR ID = range block .)
    PRINT           reduce using rule 5 (statement -> FOR ID = range block .)
    BREAK           reduce using rule 5 (statement -> FOR ID = range block .)
    CONTINUE        reduce using rule 5 (statement -> FOR ID = range block .)
    RETURN          reduce using rule 5 (statement -> FOR ID = range block .)
    EYE             reduce using rule 5 (statement -> FOR ID = range block .)
    ONES            reduce using rule 5 (statement -> FOR ID = range block .)
    ZEROS           reduce using rule 5 (statement -> FOR ID = range block .)
    ID              reduce using rule 5 (statement -> FOR ID = range block .)
    [               reduce using rule 5 (statement -> FOR ID = range block .)
    STRING          reduce using rule 5 (statement -> FOR ID = range block .)
    FLOAT           reduce using rule 5 (statement -> FOR ID = range block .)
    INT             reduce using rule 5 (statement -> FOR ID = range block .)
    (               reduce using rule 5 (statement -> FOR ID = range block .)
    '               reduce using rule 5 (statement -> FOR ID = range block .)
    $end            reduce using rule 5 (statement -> FOR ID = range block .)
    }               reduce using rule 5 (statement -> FOR ID = range block .)
    ELSE            reduce using rule 5 (statement -> FOR ID = range block .)


state 128

    (52) range -> INT : . ID
    (55) range -> INT : . INT
    ID              shift and go to state 137
    INT             shift and go to state 136


state 129

    (22) indexes -> INT , indexes .
    ]               reduce using rule 22 (indexes -> INT , indexes .)


state 130

    (25) block -> { start } .
    {               reduce using rule 25 (block -> { start } .)
    FOR             reduce using rule 25 (block -> { start } .)
    WHILE           reduce using rule 25 (block -> { start } .)
    IF              reduce using rule 25 (block -> { start } .)
    PRINT           reduce using rule 25 (block -> { start } .)
    BREAK           reduce using rule 25 (block -> { start } .)
    CONTINUE        reduce using rule 25 (block -> { start } .)
    RETURN          reduce using rule 25 (block -> { start } .)
    EYE             reduce using rule 25 (block -> { start } .)
    ONES            reduce using rule 25 (block -> { start } .)
    ZEROS           reduce using rule 25 (block -> { start } .)
    ID              reduce using rule 25 (block -> { start } .)
    [               reduce using rule 25 (block -> { start } .)
    STRING          reduce using rule 25 (block -> { start } .)
    FLOAT           reduce using rule 25 (block -> { start } .)
    INT             reduce using rule 25 (block -> { start } .)
    (               reduce using rule 25 (block -> { start } .)
    '               reduce using rule 25 (block -> { start } .)
    $end            reduce using rule 25 (block -> { start } .)
    }               reduce using rule 25 (block -> { start } .)
    ELSE            reduce using rule 25 (block -> { start } .)


state 131

    (7) statement -> IF expr block ELSE block .
    {               reduce using rule 7 (statement -> IF expr block ELSE block .)
    FOR             reduce using rule 7 (statement -> IF expr block ELSE block .)
    WHILE           reduce using rule 7 (statement -> IF expr block ELSE block .)
    IF              reduce using rule 7 (statement -> IF expr block ELSE block .)
    PRINT           reduce using rule 7 (statement -> IF expr block ELSE block .)
    BREAK           reduce using rule 7 (statement -> IF expr block ELSE block .)
    CONTINUE        reduce using rule 7 (statement -> IF expr block ELSE block .)
    RETURN          reduce using rule 7 (statement -> IF expr block ELSE block .)
    EYE             reduce using rule 7 (statement -> IF expr block ELSE block .)
    ONES            reduce using rule 7 (statement -> IF expr block ELSE block .)
    ZEROS           reduce using rule 7 (statement -> IF expr block ELSE block .)
    ID              reduce using rule 7 (statement -> IF expr block ELSE block .)
    [               reduce using rule 7 (statement -> IF expr block ELSE block .)
    STRING          reduce using rule 7 (statement -> IF expr block ELSE block .)
    FLOAT           reduce using rule 7 (statement -> IF expr block ELSE block .)
    INT             reduce using rule 7 (statement -> IF expr block ELSE block .)
    (               reduce using rule 7 (statement -> IF expr block ELSE block .)
    '               reduce using rule 7 (statement -> IF expr block ELSE block .)
    $end            reduce using rule 7 (statement -> IF expr block ELSE block .)
    }               reduce using rule 7 (statement -> IF expr block ELSE block .)
    ELSE            reduce using rule 7 (statement -> IF expr block ELSE block .)


state 132

    (59) innerlist -> innerlist , elem .
    ]               reduce using rule 59 (innerlist -> innerlist , elem .)
    ,               reduce using rule 59 (innerlist -> innerlist , elem .)


state 133

    (57) outerlist -> outerlist , [ innerlist . ]
    (59) innerlist -> innerlist . , elem
    ]               shift and go to state 138
    ,               shift and go to state 124


state 134

    (54) range -> ID : ID .
    {               reduce using rule 54 (range -> ID : ID .)
    FOR             reduce using rule 54 (range -> ID : ID .)
    WHILE           reduce using rule 54 (range -> ID : ID .)
    IF              reduce using rule 54 (range -> ID : ID .)
    PRINT           reduce using rule 54 (range -> ID : ID .)
    BREAK           reduce using rule 54 (range -> ID : ID .)
    CONTINUE        reduce using rule 54 (range -> ID : ID .)
    RETURN          reduce using rule 54 (range -> ID : ID .)
    EYE             reduce using rule 54 (range -> ID : ID .)
    ONES            reduce using rule 54 (range -> ID : ID .)
    ZEROS           reduce using rule 54 (range -> ID : ID .)
    ID              reduce using rule 54 (range -> ID : ID .)
    [               reduce using rule 54 (range -> ID : ID .)
    STRING          reduce using rule 54 (range -> ID : ID .)
    FLOAT           reduce using rule 54 (range -> ID : ID .)
    INT             reduce using rule 54 (range -> ID : ID .)
    (               reduce using rule 54 (range -> ID : ID .)
    '               reduce using rule 54 (range -> ID : ID .)


state 135

    (53) range -> ID : INT .
    {               reduce using rule 53 (range -> ID : INT .)
    FOR             reduce using rule 53 (range -> ID : INT .)
    WHILE           reduce using rule 53 (range -> ID : INT .)
    IF              reduce using rule 53 (range -> ID : INT .)
    PRINT           reduce using rule 53 (range -> ID : INT .)
    BREAK           reduce using rule 53 (range -> ID : INT .)
    CONTINUE        reduce using rule 53 (range -> ID : INT .)
    RETURN          reduce using rule 53 (range -> ID : INT .)
    EYE             reduce using rule 53 (range -> ID : INT .)
    ONES            reduce using rule 53 (range -> ID : INT .)
    ZEROS           reduce using rule 53 (range -> ID : INT .)
    ID              reduce using rule 53 (range -> ID : INT .)
    [               reduce using rule 53 (range -> ID : INT .)
    STRING          reduce using rule 53 (range -> ID : INT .)
    FLOAT           reduce using rule 53 (range -> ID : INT .)
    INT             reduce using rule 53 (range -> ID : INT .)
    (               reduce using rule 53 (range -> ID : INT .)
    '               reduce using rule 53 (range -> ID : INT .)


state 136

    (55) range -> INT : INT .
    {               reduce using rule 55 (range -> INT : INT .)
    FOR             reduce using rule 55 (range -> INT : INT .)
    WHILE           reduce using rule 55 (range -> INT : INT .)
    IF              reduce using rule 55 (range -> INT : INT .)
    PRINT           reduce using rule 55 (range -> INT : INT .)
    BREAK           reduce using rule 55 (range -> INT : INT .)
    CONTINUE        reduce using rule 55 (range -> INT : INT .)
    RETURN          reduce using rule 55 (range -> INT : INT .)
    EYE             reduce using rule 55 (range -> INT : INT .)
    ONES            reduce using rule 55 (range -> INT : INT .)
    ZEROS           reduce using rule 55 (range -> INT : INT .)
    ID              reduce using rule 55 (range -> INT : INT .)
    [               reduce using rule 55 (range -> INT : INT .)
    STRING          reduce using rule 55 (range -> INT : INT .)
    FLOAT           reduce using rule 55 (range -> INT : INT .)
    INT             reduce using rule 55 (range -> INT : INT .)
    (               reduce using rule 55 (range -> INT : INT .)
    '               reduce using rule 55 (range -> INT : INT .)


state 137

    (52) range -> INT : ID .
    {               reduce using rule 52 (range -> INT : ID .)
    FOR             reduce using rule 52 (range -> INT : ID .)
    WHILE           reduce using rule 52 (range -> INT : ID .)
    IF              reduce using rule 52 (range -> INT : ID .)
    PRINT           reduce using rule 52 (range -> INT : ID .)
    BREAK           reduce using rule 52 (range -> INT : ID .)
    CONTINUE        reduce using rule 52 (range -> INT : ID .)
    RETURN          reduce using rule 52 (range -> INT : ID .)
    EYE             reduce using rule 52 (range -> INT : ID .)
    ONES            reduce using rule 52 (range -> INT : ID .)
    ZEROS           reduce using rule 52 (range -> INT : ID .)
    ID              reduce using rule 52 (range -> INT : ID .)
    [               reduce using rule 52 (range -> INT : ID .)
    STRING          reduce using rule 52 (range -> INT : ID .)
    FLOAT           reduce using rule 52 (range -> INT : ID .)
    INT             reduce using rule 52 (range -> INT : ID .)
    (               reduce using rule 52 (range -> INT : ID .)
    '               reduce using rule 52 (range -> INT : ID .)


state 138

    (57) outerlist -> outerlist , [ innerlist ] .
    ]               reduce using rule 57 (outerlist -> outerlist , [ innerlist ] .)
    ,               reduce using rule 57 (outerlist -> outerlist , [ innerlist ] .)
